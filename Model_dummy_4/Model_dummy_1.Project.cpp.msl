# 1 "Model_dummy_1.Project.msl"



# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 1
 
 
 
 





# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\generic.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\generic.base.msl" 1
 


















 
 
 
 
 
 
 
 
 
 
 

 TYPE Generic "builtin: type variable";
  
  
  

 TYPE Integer "builtin: positive and negative Natural Numbers";

 TYPE Real "builtin: Real numbers";

 TYPE Char "builtin: ASCII character";

 TYPE String 
  "builtin: Char* (implemented as atomic type for efficiency reasons)";

 TYPE Bottom "builtin: bottom type" = ENUM {null};
  
  
  
  

 TYPE Boolean "builtin: Logic type" = ENUM {True, False};

 
 
 

 TYPE TypeDeclarationType
 "builtin: type of TYPE declaration statement";
 TYPE ClassDeclarationType
 "builtin: type of CLASS declaration statement";

 TYPE ObjectDeclarationType
 "builtin: type of OBJ declaration statement";

 TYPE DeclarationType
 "type of a declaration (TYPE, CLASS, or OBJ) statement"
 = UNION {TypeDeclarationType, ClassDeclarationType, ObjectDeclarationType};

 TYPE ExpressionType
 "builtin: type of expressions";

 TYPE EquationType
 "builtin: type of equations";

 TYPE GenericIntervalType
 "Generic Interval"
 
 
 
 = RECORD 
   {
    lowerBound: Generic;   
    upperBound: Generic;   
    lowerIncluded: Boolean;
    upperIncluded: Boolean;
   };

 TYPE RealIntervalType "Interval of real numbers"
 SUBSUMES GenericIntervalType =
 RECORD 
 {
  lowerBound: Real;  
  upperBound: Real;  
  lowerIncluded: Boolean;
  upperIncluded: Boolean;
 };

 
 
 

 TYPE UnitType 
 "The type of physical units. For the time being, a string"
 = String;

 TYPE QuantityType
 "The different physical quantities. For the time being, string"
 = String;

 TYPE CausalityType
 " Causality of entities"
 
 
 
 
 = ENUM {CIN, COUT, CINOUT};

 TYPE PhysicalNatureType
 "The nature of physical variables FIELD is used (in the physicalDAE context) to denote parameters and constants"
 = ENUM {ACROSS, THROUGH, FIELD};

 TYPE PhysicalQuantityType 
 "The type of any physical quantity" 
 =
 RECORD
 {
  quantity   : QuantityType;
  unit       : UnitType;
  interval   : RealIntervalType;
  value      : Real;
  causality  : CausalityType;
  nature     : PhysicalNatureType;
 };

  
  
  

 TYPE InterfaceDeclarationType
 "declarations within an interface" = DeclarationType;

 TYPE ParameterDeclarationType
 "declarations within parameter section" = DeclarationType;

 TYPE ModelDeclarationType
 "declarations within sub_models section" = DeclarationType;

 TYPE CouplingStatementType
 "parameter coupling and connect() statements" = EquationType;

 TYPE GenericModelType 
 "The signature of the generic part of any (whatever the formalism) model"
 = 
 RECORD
 { 
  comments   : String;
  interface  : SET_OF (InterfaceDeclarationType); 
    
  parameters : SET_OF (ParameterDeclarationType); 
    
 };

 TYPE DAEModelType 
 "The signature of a Differential Algebraic Equation (DAE) model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };
 
 TYPE PhysicalDAEModelType 
 "The signature of a physicalDAEModelType model"
 
 
 
 
 
 
 EXTENDS GenericModelType WITH
 RECORD
 {
  independent : SET_OF (ObjectDeclarationType);  
  state       : SET_OF (PhysicalQuantityType);  
                                        
                                        
                                        
  initial     : SET_OF (EquationType);
  equations   : SET_OF (EquationType);
  terminal    : SET_OF (EquationType);
 };

 TYPE CoupledModelType "The signature of a coupled (network) model"
 EXTENDS GenericModelType WITH
 RECORD
 {
  sub_models : SET_OF (ModelDeclarationType);
  coupling   : SET_OF (CouplingStatementType);
 };
  

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\generic.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\generic.quantity.si.msl" 1
 


















 
 
 
 
 

 

   CLASS Angle
   "A class for angle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Angle";
    unit      <- "rad";
    displayunit <- "deg";
   :};

   CLASS SolidAngle
   "A class for SolidAngle"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SolidAngle";
    unit      <- "sr";
   :};

   TYPE StringType
   "The class for all kind of strings + some extra's"
   =
   RECORD
   {
    quantity   : QuantityType;
    value      : String;
    unit       : UnitType;
   };

   CLASS Date
   "A class for date"
   SPECIALISES StringType :=
   {:
    quantity  <- "Date";
   :};

   CLASS Time
   "A class for time"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Time";
    unit      <- "d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS Length
   "A class for Length"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Length";
    unit      <- "m";
   :};

   CLASS Area
   "A class for Area"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Area";
    unit      <- "m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS Volume
   "Volume"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Volume";
    unit      <- "m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS AngularVelocity
   "A class for AngularVelocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularVelocity";
    unit      <- "rad/d";
   :};

   CLASS Velocity
   "A class for Velocity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Velocity";
    unit      <- "m/d";
   :};

 
 
 

   CLASS Rate
   "A class for rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Rate";
    unit      <- "dUnit/dt";
   :};

   CLASS FlowRate
   "Flow rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity <- "FlowRate";
    unit     <- "m3/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS FlowRateRate
   "Flow rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity <- "FlowRateRate";
    unit     <- "m3/d2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 
 

   CLASS Ratio
   "A class for ratio"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Ratio";
    unit      <- "dUnit/dUnit";
   :};

   CLASS AngularAcceleration
   "A class for AngularAcceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AngularAcceleration";
    unit      <- "rad/d2";
   :};

   CLASS Acceleration
   "A class for Acceleration"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Acceleration";
    unit      <- "m/d2";
   :};

 

   CLASS Frequency
   "The type of frequency"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Frequency";
    unit      <- "Hz";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 

   CLASS Mass
   "A class for Mass"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SludgeMass
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgeMass";
   unit     <- "kg SS";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS SludgePerDay
   "Sludge production"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "SludgePerDay";
   unit     <- "kg SS/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};
 
   CLASS Density
   "A class for Density"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Density";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceDensity
   "A class for Areal Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Areal Density";
    unit      <- "g/m2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};
   
   CLASS SpecificVolume
   "Specific volume ((density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificVolume";
    unit      <- "m3/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   CLASS SpecificArea
   "Specific area ((surface density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificArea";
    unit      <- "m2/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

      CLASS SpecificLength
   "Specific length ((length density)^-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "SpecificLength";
    unit      <- "m/g";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
   :};

   
   CLASS LinearDensity
   "A class for LinearDensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearDensity";
    unit      <- "g/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MomentOfInertia
   "A class for MomentOfInertia"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfInertia";
    unit      <- "g*m2";
   :};

   CLASS Momentum
   "A class for Momentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m/d";
   :};

   CLASS Force
   "A class for Force"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Force";
    unit      <- "N";
   :};

   CLASS AngularMomentum
   "A class for AngularMomentum"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "g*m2/d";
   :};

   CLASS MomentOfForce
   "A class for MomentOfForce"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MomentOfForce";
    unit      <- "N*m";
   :};

   CLASS PressureDifference
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF; :};
   :};

   
   CLASS Pressure
   "A class for Pressure"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "Pa";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS NormalStress
   "A class for NormalStress"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NormalStress";
    unit      <- "Pa";
   :};

   CLASS Diffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/d";
   :};

   CLASS DynamicViscosity
   "A class for DynamicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DynamicViscosity";
    unit      <- "Pa*d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS KinematicViscosity
   "A class for KinematicViscosity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KinematicViscosity";
    unit      <- "m2/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS SurfaceTension
   "A class for SurfaceTension"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceTension";
    unit      <- "N/m";
   :};
   
   CLASS Energy
   "A class for Energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Energy";
    unit      <- "J";
   :};

   CLASS Power
   "A class for Power"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Power";
    unit      <- "W";
   :};

   CLASS EnergyIndex
   "Aeration and Pumping energy"
   SPECIALISES PhysicalQuantityType:=
   {:
   quantity <- "EnergyIndex";
   unit     <- "kWh/d";
   interval <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF:};
   :};

   CLASS FiltrationResistance SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "filtration resistance";
    unit      <- "1/m";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

   CLASS SpecificAreaVolume
   "Mass per time unit"
   SPECIALISES PhysicalQuantityType :=
   {:
   quantity  <- "specific area per volume";
   unit      <- "1/m";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
   CLASS KelvinTemperature
   "A class for KelvinTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity    <- "KelvinTemperature";
    unit        <- "K";
    interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS CelsiusTemperature
   "A class for CelsiusTemperature"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CelsiusTemperature";
    unit      <- "degC";
    interval  <- {: lowerBound <- -273.15; upperBound <- PLUS_INF; :};
   :};

   CLASS LinearExpansionCoefficient
   "A class for LinearExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LinearExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS CubicExpansionCoefficient
   "A class for CubicExpansionCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CubicExpansionCoefficient";
    unit      <- "1/K";
   :};

   CLASS RelativePressureCoefficient
   "A class for RelativePressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RelativePressureCoefficient";
    unit      <- "1/K";
   :};

   CLASS PressureCoefficient
   "A class for PressureCoefficient"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PressureCoefficient";
    unit      <- "Pa/K";
   :};

   CLASS IsothermalCompressibility
   "A class for IsothermalCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsothermalCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS IsentropicCompressibility
   "A class for IsentropicCompressibility"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicCompressibility";
    unit      <- "1/Pa";
   :};

   CLASS Heat = Energy;

   CLASS HeatFlowRate
   "A class for HeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatFlowRate";
    unit      <- "W";
   :};

   CLASS DensityOfHeatFlowRate
   "A class for DensityOfHeatFlowRate"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "DensityOfHeatFlowRate";
    unit      <- "W/m2";
   :};

   CLASS ThermalConductivity
   "A class for ThermalConductivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductivity";
    unit      <- "W/(m*K)";
   :};

   CLASS CoefficientOfHeatTransfer
   "A class for CoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "CoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS SurfaceCoefficientOfHeatTransfer
   "A class for SurfaceCoefficientOfHeatTransfer"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SurfaceCoefficientOfHeatTransfer";
    unit      <- "W/(m2*K)";
   :};

   CLASS ThermalInsulance
   "A class for ThermalInsulance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalInsulance";
    unit      <- "m2*K/W";
   :};

   CLASS ThermalResistance
   "A class for ThermalResistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalResistance";
    unit      <- "K/W";
   :};

   CLASS ThermalConductance
   "A class for ThermalConductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalConductance";
    unit      <- "W/K";
   :};

   CLASS ThermalDiffusivity
   "A class for ThermalDiffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ThermalDiffusivity";
    unit      <- "m2/d";
   :};

   CLASS HeatCapacity
   "A class for HeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "HeatCapacity";
    unit      <- "J/K";
   :};

   CLASS SpecificHeatCapacity
   "A class for SpecificHeatCapacity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificHeatCapacity";
    unit      <- "J/(g*K)";
   :};

 
 
 

   CLASS RatioOfspecificHeatCapacities
   "A class for RatioOfSpecificHeatCapacities"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RatioOfSpecificHeatCapacities";
    unit      <- "-";
   :};

   CLASS IsentropicExponent
   "A class for IsentropicExponent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "IsentropicExponent";
    unit      <- "-";
   :};

   CLASS Entropy
   "A class for Entropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Entropy";
    unit      <- "J/K";
   :};

   CLASS SpecificEntropy
   "A class for SpecificEntropy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEntropy";
    unit      <- "J/(g*K)";
   :};

   CLASS SpecificEnergy
   "A class for SpecificEnergy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SpecificEnergy";
    unit      <- "J/g";
   :};

 
 
 
 

   CLASS ThermodynamicEnergy         = Energy;
   CLASS HelmholtzFreeEnergy         = Energy;
   CLASS GibbsFreeEnergy             = Energy;
   CLASS Enthalpy                    = Energy;

   CLASS SpecificThermodynamicEnergy = SpecificEnergy;
   CLASS SpecificHelmholtzFreeEnergy = SpecificEnergy;
   CLASS SpecificGibbsFreeEnergy     = SpecificEnergy;
   CLASS SpecificEnthalpy            = SpecificEnergy;

   CLASS PlanckFunction
   "A class for PlanckFunction"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PlanckFunction";
    unit      <- "J/g";
   :};

 
   CLASS ElectricCurrent
   "A class for ElectricCurrent"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCurrent";
    unit      <- "A";
   :};

   CLASS ElectricCharge
   "A class for ElectricCharge"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricCharge";
    unit      <- "C";
   :};

   CLASS ElectricPotential
   "A class for ElectricPotential"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ElectricPotential";
    unit      <- "V";
   :};

   CLASS Capacitance
   "A class for Capacitance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Capacitance";
    unit      <- "F";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Inductance
   "A class for Inductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Inductance";
    unit      <- "H";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Resistance
   "A class for Resistance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Resistance";
    unit      <- "Ohm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS Conductance
   "A class for Conductance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Conductance";
    unit      <- "S";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS LuminousIntensity
   "A class for LuminousIntensity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LuminousIntensity";
    unit      <- "cd";
   :};

 

   CLASS AmountOfSubstance
   "A class for AmountOfSubstance"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "AmountOfSubstance";
    unit      <- "mol";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

 

   CLASS pH
   "A class for pH"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pH";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

   CLASS Concentration
   "A class for concentration"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "g/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};

 
 

   CLASS ReynoldsNumber
   "A class for ReynoldsNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "ReynoldsNumber";
    unit      <- "-";
   :};

   CLASS EulerNumber
   "A class for EulerNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "EulerNumber";
    unit      <- "-";
   :};

   CLASS FroudeNumber
   "A class for FroudeNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FroudeNumber";
    unit      <- "-";
   :};

   CLASS GrashofNumber
   "A class for GrashofNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "GrashofNumber";
    unit      <- "-";
   :};

   CLASS WeberNumber
   "A class for WeberNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "WeberNumber";
    unit      <- "-";
   :};

   CLASS MachNumber
   "A class for MachNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "MachNumber";
    unit      <- "-";
   :};

   CLASS KnudsenNumber
   "A class for KnudsenNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "KnudsenNumber";
    unit      <- "-";
   :};

   CLASS StrouhalNumber
   "A class for StrouhalNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StrouhalNumber";
    unit      <- "-";
   :};

 
   CLASS FourierNumber
   "A class for FourierNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "FourierNumber";
    unit      <- "-";
   :};

   CLASS PecletNumber
   "A class for PecletNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PecletNumber";
    unit      <- "-";
   :};

   CLASS RayleighNumber
   "A class for RayleighNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "RayleighNumber";
    unit      <- "-";
   :};

   CLASS NusseltNumber
   "A class for NusseltNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "NusseltNumber";
    unit      <- "-";
   :};

   CLASS BiotNumber = NusseltNumber;
 
 
 

   CLASS StantonNumber
   "A class for StantonNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "StantonNumber";
    unit      <- "-";
   :};

 
   CLASS PrandtlNumber
   "A class for PrandtlNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "PrandtlNumber";
    unit      <- "-";
   :};

   CLASS SchmidtNumber
   "A class for SchmidtNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "SchmidtNumber";
    unit      <- "-";
   :};

   CLASS LewisNumber
   "A class for LewisNumber"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "LewisNumber";
    unit      <- "-";
   :};

 
 
 

 
 
 

 
 
 
 
 

 



































































 
 
 
   CLASS PartialPressureInAir
   "A class for Partial Pressure in air"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Pressure";
    unit      <- "atm";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS MolecularDiffusivity
   "A class for Diffusivity"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Diffusivity";
    unit      <- "m2/s";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};


# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\generic.msl" 2



# 10 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.quantity.msl" 1
 
 
 
 
 





 
 
 
 
 
 

 CLASS MassFlux
 "Mass per time unit"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity  <- "MassFlux";
  unit      <- "g/d";
  interval  <- {: lowerBound <- MIN_INF; upperBound <- PLUS_INF :};
  nature <- "THROUGH";
 :};

 CLASS ArealFlux
 "Mass per unit of surface and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ArealFlux";
  unit     <- "g/(m2*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};
 
CLASS ArealFluxHa
 "Mass per unit of surface and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ArealFlux";
  unit     <- "kg/(ha*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

 

 

  CLASS PhosphateHalfSatCoeff
    "Phosphate half saturation coeff"
    SPECIALISES PhysicalQuantityType :=
    {:
      quantity  <- "K_HPO4";
      unit      <- "gHPO4-P/m3";
      interval  <- {: lowerBound <- 0; upperBound <- 10 :};
      :};
	  
	   CLASS NitrogenHalfSatCoeff
      "Nitrogen half-saturation coeff"
      SPECIALISES PhysicalQuantityType :=
      {:
        quantity  <- "K_N";
        unit      <- "g N/m3";
        interval  <- {: lowerBound <- 0; upperBound <- 10 :};  
        :};

		  CLASS AmmoniaHalfSatCoeff
      "Ammonia half-saturation coeff for algae"
      SPECIALISES PhysicalQuantityType :=
      {:
        quantity  <- "K_NH";
        unit      <- "gNH4-N/m3";
        interval  <- {: lowerBound <- 0; upperBound <- 10 :};
       
      :};
	  
 CLASS OxygenHalfSatCoeff
   "Oxygen half-saturation coeff"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_O2";
     unit      <- "gO2/m3";
     interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};   
  

 CLASS NitriteHalfSatCoeffForDenitrifHetero
  "Nitrite half-saturation coeff for denitrifying heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NO";
    unit      <- "gNO2-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 2 :};
  :};    
  
		
  CLASS YieldForAutotrophicBiomass
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- 4.57 :};
  :};

  CLASS YieldForHeterotrophicBiomass
  "A class for YieldForHeterotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_H";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS FractOfBiomassLeadingToPartProd
  "Fraction of biomass leading to particulate products"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "F_P";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInBiomass
  "Mass of N per mass of COD in biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XB";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

  CLASS MassOfNitrogenPerMassOfCODInProdFromBiomass
  "Mass of N per mass of COD in products from biomass" 
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I_XP";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 0.2 :};
  :};    

 

  CLASS MaxSpecifGrowthRateHetero
  "Maximum specific growth rate for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

  CLASS MaxSpecifGrowthRateAutotr
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 5 :};
  :};    

  CLASS HalfSatCoeff
  "Half-saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 1000000 :};
  :};    

  CLASS HalfSatCoeffForHetero
  "Half-saturation coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_S";
    unit      <- "gCOD/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

  CLASS OxygenHalfSatCoeffForHetero
  "Oxygen half-saturation coeff for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OH";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS NitrateHalfSatCoeffForDenitrifHetero
  "Nitrate half-saturation coeff for denitrifying heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NO";
    unit      <- "gNO3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 2 :};
  :};    

  CLASS OxygenHalfSatCoeffForAutotr
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};    

  CLASS AmmonHalfSatCoeffForAutotr
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS HalfSatCoeffForHydrolSlowBioDegradeSubstr
  "Half saturation constant for hydrolysis of slowly biodegradable substrate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_X";
    unit      <- "gCOD/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS MaxSpecificHydrolysisRate
  "Maximum specific hydrolysis rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_h";
    unit      <- "gCOD/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS AmmonificationRate
  "Ammonification rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_a";
    unit      <- "m3/(gCOD*d)";
    interval  <- {: lowerBound <- 0; upperBound <- 0.25 :};
  :};    

  CLASS DecayCoeffHeterotr
  "Decay coefficient for heterotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_H";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

  CLASS DecayCoeffAutotr
  "Decay coefficient for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "B_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 25 :};
  :};    

 

  CLASS DissolvedComponent

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ParticulateComponent

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "X";
    unit      <- "g/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
    nature <- "ACROSS";
  :};    

  CLASS ConversionFactor

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "g/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS NitrogenConversionFactor

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gN/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};

  CLASS PhosphorusConversionFactor

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "I";
    unit      <- "gP/gCOD";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
    
  CLASS MaxGrowthRate
  "Maximum growth rate"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 20 :};
  :};    

  CLASS RateConstant
  "Rate constant"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Q_or_B_or_K";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- 100 :};
  :};    

 
 

  CLASS ChemOxDemand

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "COD";
    unit      <- "gO2/m3";
  :};    
  
  CLASS BiolOxDemand

  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "BOD_5_20";
    unit      <- "gO2/m3";
  :};    

  CLASS NitrifOxDemand
  "Nitrification oxygen demand"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "NOD";
    unit      <- "gO2/m3";
  :};    

  CLASS DissolvedOxygen
  "A class for the ammount of dissolved oxygen"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity    <- "DO";
    unit        <- "gO2/m3";
    displayunit <- "gO2/m3";
    interval    <- {: lowerBound <- 0; upperBound <- 15 :};
  :};

 
 

 CLASS Yield
 "A class for Yield"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Yield";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS GrowthRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "GrowthRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

  CLASS ProcessRate
 "GrowthRate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "ProcessRate";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :}; 
 CLASS Fraction
 "Fraction"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Fraction";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1:};
 :};

 CLASS SaturationCoefficient
 "Saturation coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "K";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 100:};
 :};

 CLASS DecayCoefficient
 "Decay coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "B";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 20:};
 :};

 CLASS CorrectionFactor
 "CorrectionFactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS ReductionFactor
 "Reductionfactor"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "eta";
  unit     <- "-";
  interval  <- {: lowerBound <- 0; upperBound <- 1 :};
 :};

 CLASS MaxSpecAmmonRate
 "Maximum specific ammonification rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "MaxSpecAmmonRate";
  unit     <- "m3/(gCOD*d)";
  interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
 :};

 CLASS OxygenTransferCoefficient
 "Oxygen Transfer Coefficient"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "Kla";
  unit     <- "1/d";
  interval  <- {: lowerBound <- 0; upperBound <- 5000 :};
 :};

CLASS OxygenUptakeRate
 "Oxygen Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "OUR";
  unit     <- "g/(m3.d)";
 :};

CLASS NitrateUptakeRate
 "Nitrate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NUR";
  unit     <- "g/(m3.d)";
 :};

 CLASS NitrateProductionRate
 "Nitrate Production Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "NPR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS AmmoniumUptakeRate
 "Ammonium Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "AUR";
  unit     <- "g/(m3.d)";
 :};
 
CLASS PhosphateUptakeRate
 "Phosphate Uptake Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PUR";
  unit     <- "g/(m3.d)";
 :};  

CLASS PhosphateReleaseRate
 "Phosphate Release Rate"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "PRR";
  unit     <- "g/(m3.d)";
 :};   
CLASS ElectricalEnergy
   "A class for electrical energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Electrical energy";
    unit      <- "kWh";
    :};

CLASS TransferRateEnergy
   "A class for transfer rate per unit of energy"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Transfer rate per energy";
    unit      <- "g/kWh";
    :};
  
CLASS Dollar
   "dollars"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "dollar";
    unit      <- "$";
    :};

CLASS Euro
   "Euro"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "euro";
    unit      <- "E";
    :};

CLASS HenryCoefficient
 "A class for the Henry coefficient in atm"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity    <- "HenryCoefficient";
  unit        <- "atm.m3.Mol-1";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
 :};
 
 
CLASS HenryCoefficientPa
 "A class for the Henry coefficient in pascal"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity    <- "HenryCoefficient";
  unit        <- "Pa.m3.Mol-1";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
 :};
 
 
CLASS DimensionlessHenryCoefficient
 "A class for the dimensionless Henry coefficient"
 SPECIALISES PhysicalQuantityType := 
 {:
  quantity    <- "DimensionlessHenryCoefficient";
  unit        <- "";
  interval    <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};
 

CLASS MassOfNitrogenPerMassOfCOD
 "Mass of N per mass of COD"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "I_";
   unit      <- "gN/gCOD";
   interval  <- {: lowerBound <- 0; upperBound <- 0.2; :};
 :};    

 CLASS MolarHalfSatCoeff
 "Half-saturation coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_S_";
   unit      <- "mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS InhibitionCoeff
 "Inhibition coefficient for components expressed in g.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "g.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   

 CLASS MolarInhibitionCoeff
 "Inhibition coefficient for components expressed in mol.m-3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};    

 CLASS TemperatureCoefficient
 "Temperature coefficient for reaction rate"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "TemperatureCoefficient";
   unit      <- "-";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS MolConcentration
 "Concentration in Mol per m3"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "MolConcentration";
   unit      <- "mol.m-3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :}; 
 
 CLASS MolFlowRate
 "Gas flow rate in Mol per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "MolFlowRate";
   unit      <- "mol.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 CLASS GasFlowRate
 "Gas flow rate in m3 per day"
 SPECIALISES PhysicalQuantityType :=
 {: 
   quantity  <- "GasFlowRate";
   unit      <- "m3.d-1";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};

 




  CLASS MonodTerm
  "A class for Monod-like terms"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "S / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    

  CLASS InhibitionTerm
  "A class for inhibtion terms of the ASM-models"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K / ( K + S)";
    unit      <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- 1:};
  :};    



CLASS LengthFlux
 "Mass per unit of length and per unit of time"
 SPECIALISES PhysicalQuantityType :=
 {:
  quantity <- "LengthFlux";
  unit     <- "g/(m*d)";
  interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
 :};

CLASS BurgerDispersion
 "Time per unit of surface"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "b_mix";
   unit      <- "d/m2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};

CLASS BurgerSolidsStress
"A class for the parameter of the solids stress function"
SPECIALISES PhysicalQuantityType :=
{:
   quantity  <- "Alpha";
   unit      <- "m2/s2";
   interval  <- {: lowerbound <- 0; upperbound <- PLUS_INF; :};
 :};
 
 
 
 
  CLASS YieldForAutotrophicBiomassForMampaeyA
  "A class for YieldForAutotrophicBiomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Y_A";
    unit      <- "gCOD/gN";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS MaxSpecifDenitrifyRateForMampaeyB
  "Maximum specific growth rate for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Mu_A";
    unit      <- "1/d";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};    
  
  CLASS AmmonHalfSatCoeffForAutotrForMampaeyA
  "Ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_NH";
    unit      <- "gNH3-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS OxygenHalfSatCoeffForAutotrForMampaeyA
  "Oxygen half-saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_OA";
    unit      <- "gO2/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};  
  
  CLASS NSaturationCoefficientForMampaey
  "Saturation coefficient"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "K";
    unit     <- "-";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};
  
 
  CLASS FreeAmmoniaSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};

  CLASS FreeNitrousAcidSatCoeffForAutotr
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- 10 :};
  :};
  
  CLASS bCoeffForRatkowsky
  "b coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/[(d^0.5)*(deg C)]";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
 
  CLASS cCoeffForRatkowsky
  "c coefficient of Ratkowsky temperature correction"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity <- "eta";
    unit     <- "1/degC";
    interval  <- {: lowerBound <- 0; upperBound <- 1 :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeff
  "Inhibition coefficient for free Ammonia"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};   
 
 CLASS FreeNitrousAcidInhibitionCoeff
 "Inhibition coefficient for free nitrous acid"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NitricOxideInhibitionCoeffForDenitrification
 "Inhibition coefficient for nitric oxide substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 CLASS NHalfSatCoeffForDenitrification
 "Half saturation coefficient for N substances during denitrification"
 SPECIALISES PhysicalQuantityType :=
 {:
   quantity  <- "K_I_";
   unit      <- "gN/m3";
   interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
 :};   
 
 
  
 
  CLASS FreeAmmoniaSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeNitrousAcidSatCoeffForAutotrModif
  "Free ammonium half saturation coeff for autotrophic biomass"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_FNA";
    unit      <- "gFA-N/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
  :};
  
  CLASS FreeAmmoniaInhibitionCoeffModif
  "Inhibition coefficient for free Ammonia in the modified competitive term"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "K_I_";
    unit      <- "gN/m3";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
  :};  
  
   CLASS FreeNitrousAcidInhibitionCoeffModif
   "Inhibition coefficient for free nitrous acid"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  
   
   CLASS NitricOxideInhibitionCoeffForDenitrificationModif
   "Inhibition coefficient for nitric oxide substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};  

   CLASS NHalfSatCoeffForDenitrificationModif
   "Half saturation coefficient for N substances during denitrification"
   SPECIALISES PhysicalQuantityType :=
   {:
     quantity  <- "K_I_";
     unit      <- "gN/m3";
     interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :}; 




# 12 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.splitters_combiners.msl" 1
 
 
 
 
 
 
CLASS AbsTwoSplitter_Eindhoven_in
  (* icon = "two_flow_splitter" *)
  "absolute two way splitter"
 
  
 
  EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
   comments <- "A model for an absolute splitter into two flows";
   interface <-
    { 
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
     OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
	   OBJ Q_Out2 (* terminal = "in_2"; manip = "1" *) "Max Outflow2 rate" : FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
    };
   parameters <- 
    { 
	   OBJ Q_Out1_max "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
	   
    };
    
   state <-
    {
     OBJ Q_Out1 "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
     OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
     OBJ Q_Out2_Help (* hidden = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    };
 
   equations <-
    {
     state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In)
                    THEN 0
                    ELSE IF ((state.Q_In - state.Q_Out2_Help) > parameters.Q_Out1_max) 
 				   		THEN parameters.Q_Out1_max
 						ELSE state.Q_In - state.Q_Out2_Help;
 
     state.Q_Out2_Help = IF (interface.Q_Out2 > state.Q_In)
                       	THEN state.Q_In
                       	ELSE IF (state.Q_In > (interface.Q_Out2 + parameters.Q_Out1_max))
 							 THEN (state.Q_In - parameters.Q_Out1_max)
 							 ELSE interface.Q_Out2;
 
     state.f_Out1 = IF (state.Q_In == 0)
 			 	   THEN 0
 			 	   ELSE state.Q_Out1 / state.Q_In ;
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       interface.Outflow2[Comp_Index] =
       - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out1) ;};
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       interface.Outflow1[Comp_Index] =
       - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};
 
    }; 
  :};

 CLASS SewRelTwoSplitter
 (* icon = "two_fraction_splitter" *)
 "relative splitter"

 
						
 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutSewTerminal := {: causality <- "COUT" :};
	  OBJ f_Out2 (* manip = "1"; terminal = "in_2" *) "Fraction of the fluxes going to outflow2" : 
	 			Fraction := {: causality <- "CIN" :};
   };

  parameters <-
   { 
   };
   
  equations <-
   {
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * (1-interface.f_Out2);}; 

    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (interface.f_Out2);};   
 
   }; 
 
 :};


 CLASS SewAbsTwoSplitter
 (* icon = "two_flow_splitter" *)
 "absolute two way splitter"

 
 
 
 

 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Q_Out2 (* manip = "1"; terminal = "in_2" *) "Outflow 2 rate" : 
	 			FlowRate := {: causality <- "CIN" :};
   };
  parameters <- 
   { 
   };
   
  state <-
   {
    OBJ Q_Out1 "Outflow 1 rate" : FlowRate ;
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ Q_Out2_Help (* hidden = "1" *) "Help variable for outflow2 rate" : FlowRate ;
   };

  equations <-
   {

    state.Q_Out2_Help = IF(interface.Q_Out2 > state.Q_i)
                      THEN state.Q_i
                      ELSE interface.Q_Out2;
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_i)
                 THEN 0
                 ELSE state.Q_i - state.Q_Out2_Help ;
				 
	  state.f_Out1 = IF (state.Q_i == 0)
			 THEN 0
			 ELSE state.Q_Out1 / state.Q_i ;

    interface.Outflow1[H2O_sew] = - state.Q_Out1 
      / 0.000001 ; 
    interface.Outflow2[H2O] = - state.Q_Out2_Help
      / 0.000001 ;

    {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * (state.f_Out1) ;};

    {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * (1-state.f_Out1) ;};

   }; 
 :};

 CLASS SewTwoCombiner
 (* icon = "two_combiner" *)  
 "two combiner"
 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutSewTerminal := {: causality <- "COUT" :};
   };

  equations <-
   {
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index];};   
   }; 
 :};
 
 
  CLASS SewThreeCombiner
 (* icon = "three_combiner" *)  
 "three combiner"
 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutSewTerminal := {: causality <- "COUT" :};
   };

  equations <-
   {
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index];};   
   }; 
 :};
 


 CLASS SewRelThreeSplitter
 (* icon = "three_fraction_splitter" *)
 "relative three splitter"

 
						
 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutSewTerminal := {: causality <- "COUT" :};
	  OBJ f_Out2 (* manip = "1"; terminal = "in_2" *) "Fraction of the fluxes going to outflow2" : 
	 			Fraction := {: causality <- "CIN" :};
    OBJ f_Out3 (* manip = "1"; terminal = "in_2" *) "Fraction of the fluxes going to outflow3" : 
	 			Fraction := {: causality <- "CIN" :};
   };

  parameters <- 
   { 
   };
   
  equations <-
   {
     {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (interface.f_Out2);};   
 
     {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow3[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (interface.f_Out3);};   
 
     {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] =
    - state.inFluxPerSewComponent[s_comp_index] * (1 - (interface.f_Out2 + interface.f_Out3) );};  
   }; 
 :};
 
 CLASS SewRel_15_Splitter
 (* icon = "three_fraction_splitter" *)
 "relative splitter with 15 outputs"

 
						
 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into 15 flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_1" *) "Outflow2" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow3 (* terminal = "out_1" *) "Outflow3" : OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Outflow4 (* terminal = "out_1" *) "Outflow4" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow5 (* terminal = "out_1" *) "Outflow5" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow6 (* terminal = "out_2" *) "Outflow6" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow7 (* terminal = "out_2" *) "Outflow7" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow8 (* terminal = "out_2" *) "Outflow8" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow9 (* terminal = "out_2" *) "Outflow9" : OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Outflow10 (* terminal = "out_2" *) "Outflow10" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow11 (* terminal = "out_3" *) "Outflow11" : OutSewTerminal := {: causality <- "COUT" :};
  	OBJ Outflow12 (* terminal = "out_3" *) "Outflow12" : OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Outflow13 (* terminal = "out_3" *) "Outflow13" : OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Outflow14 (* terminal = "out_3" *) "Outflow14" : OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Outflow15 (* terminal = "out_3" *) "Outflow15" : OutSewTerminal := {: causality <- "COUT" :};
   };

  parameters <- 
   { 
    OBJ f_Out1 "Fraction of the fluxes going to outflow1" : Fraction := {: value <- 0.1 :};
  	OBJ f_Out2 "Fraction of the fluxes going to outflow2" : Fraction := {: value <- 0.1 :};
    OBJ f_Out3 "Fraction of the fluxes going to outflow3" : Fraction := {: value <- 0.8 :};
  	OBJ f_Out4 "Fraction of the fluxes going to outflow4" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out5 "Fraction of the fluxes going to outflow5" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out6 "Fraction of the fluxes going to outflow6" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out7 "Fraction of the fluxes going to outflow7" : Fraction := {: value <- 0.8 :};
  	OBJ f_Out8 "Fraction of the fluxes going to outflow8" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out9 "Fraction of the fluxes going to outflow9" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out10 "Fraction of the fluxes going to outflow10" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out11 "Fraction of the fluxes going to outflow11" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out12 "Fraction of the fluxes going to outflow12" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out13 "Fraction of the fluxes going to outflow13" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out14 "Fraction of the fluxes going to outflow14" : Fraction := {: value <- 0.8 :};
	  OBJ f_Out15 "Fraction of the fluxes going to outflow15" : Fraction := {: value <- 0.8 :};
	  OBJ f_check "Must be <= 1" : Real ;
   };
   
     initial <-
   {
    parameters.f_check = parameters.f_Out1 + parameters.f_Out2 + parameters.f_Out3 + parameters.f_Out4 + parameters.f_Out5
					   + parameters.f_Out6 + parameters.f_Out7 + parameters.f_Out8 + parameters.f_Out9 + parameters.f_Out10
					   + parameters.f_Out11 + parameters.f_Out12 + parameters.f_Out13 + parameters.f_Out14 + parameters.f_Out15;
   };
   
  equations <-
   {
      {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out1);};
   
      {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out2);};   
 
      {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow3[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out3);};  
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow4[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out4);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow5[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out5);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow6[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out6);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow7[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out7);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow8[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out8);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow9[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out9);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow10[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out10);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow11[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out11);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow12[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out12);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow13[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out13);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow14[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out14);};
	  
	  {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      interface.Outflow15[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] *
      (parameters.f_Out15);}; 
   }; 
 :};


 CLASS SewAbsThreeSplitter
 (* icon = "three_flow_splitter" *)
 "absolute three way splitter"

 
 
 

 EXTENDS SewerAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InSewTerminal := {: causality <- "CIN" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutSewTerminal := {: causality <- "COUT" :};
	  OBJ Q_Out2 (* manip = "1"; terminal = "in_2" *) "Outflow2 rate" : 
	 			FlowRate := {: causality <- "CIN" :};
    OBJ Q_Out3 (* manip = "1"; terminal = "in_2" *) "Outflow3 rate" : 
	 			FlowRate := {: causality <- "CIN" :};
   };

  parameters <- 
   { 
   };

  state <-
   {
    OBJ Q_Out1 "Outflow1 rate" : FlowRate ;
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Help (* hidden = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Help (* hidden = "1" *) "Help variable for outflow3 rate" : FlowRate ;
   };

  equations <-
   {
 

    state.Q_Out1 = state.Q_i - (state.Q_Out2_Help + state.Q_Out3_Help);

    state.Q_Out2_Help = IF( interface.Q_Out2 > state.Q_i)
                      THEN state.Q_i
                      ELSE interface.Q_Out2;

    state.Q_Out3_Help = IF( (interface.Q_Out2 + interface.Q_Out3) > state.Q_i)
                      THEN state.Q_i - state.Q_Out2_Help
                      ELSE interface.Q_Out3;

    state.f_Out1 = 1 - (state.f_Out2 + state.f_Out3) ;
    state.f_Out2 = IF (state.Q_i == 0)
			 THEN 0
			 ELSE state.Q_Out2_Help /state.Q_i ; 
    state.f_Out3 = IF (state.Q_i == 0)
			 THEN 0
			 ELSE state.Q_Out3_Help / state.Q_i ;

    interface.Outflow1[H2O_sew] = - state.Q_Out1 
      / 0.000001 ; 
    interface.Outflow2[H2O_sew] = - state.Q_Out2_Help
      / 0.000001 ;
    interface.Outflow3[H2O_sew] = - state.Q_Out3_Help
      / 0.000001 ; 

    {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * state.f_Out1 ;};

    {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * state.f_Out2 ;};

    {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow3[s_comp_index] =
      - state.inFluxPerSewComponent[s_comp_index] * state.f_Out3 ;};
   }; 
 :};

 CLASS RivRelTwoSplitter
 (* icon = "two_fraction_splitter" *)
 "relative splitter"

 
						
 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
   };

  parameters <-
   { 
    OBJ f_Out2 "Fraction of the fluxes going to outflow2" : Fraction := {: value <- 0.9; group <- "Operational" :};
   };
   
  equations <-
   {
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1-parameters.f_Out2);}; 

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] *
      (parameters.f_Out2);};   
 
   }; 
 
 :};


 CLASS RivAbsTwoSplitter
 (* icon = "two_flow_splitter" *)
 "absolute two way splitter"

 
 
 
 

 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	  OBJ Q_Out2 (* manip = "1"; terminal = "in_2" *) "Q_Out2" : 
         FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
   };
   
  state <-
   {
    OBJ Q_Out1 "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Help (* hidden = "1" *) "Help variable for outflow2 rate" : FlowRate ;
   };

  equations <-
   {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In)
                   THEN 0
                   ELSE state.Q_In - state.Q_Out2_Help ;

    state.Q_Out2_Help = IF(interface.Q_Out2 > state.Q_In)
                      	THEN state.Q_In
                      	ELSE interface.Q_Out2;

    state.f_Out2 = IF (state.Q_In == 0)
			 	   THEN 0
			 	   ELSE state.Q_Out2_Help / state.Q_In ;

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

   }; 
 :};
 
 
 CLASS RivTwoCombiner
 (* icon = "two_combiner" *)  
 "two combiner"
 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  equations <-
   {
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   
   }; 
 :};

 CLASS RivRelThreeSplitter
 (* icon = "three_fraction_splitter" *)
 "relative three splitter"

 
						
 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
   };

  parameters <- 
   { 
    OBJ f_Out2 "Fraction of the fluxes going to outflow2" : Fraction := {: value <- 0.1 ; group <- "Operational" :};
    OBJ f_Out3 "Fraction of the fluxes going to outflow3" : Fraction := {: value <- 0.8 ; group <- "Operational" :};
   };
   
  equations <-
   {
     {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] *
      (parameters.f_Out2);};   
 
     {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] *
      (parameters.f_Out3);};   
 
     {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow1[Comp_Index] =
    - state.InFluxPerComponent[Comp_Index] * (1 - (parameters.f_Out2 + parameters.f_Out3) );};  
   }; 

 :};


 CLASS RivAbsThreeSplitter
 (* icon = "three_flow_splitter" *)
 "absolute three way splitter"

 
 
 

 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
   };

  parameters <- 
   { 
    OBJ Q_Out2 "Outflow2 rate" : FlowRate := {: value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 "Outflow3 rate" : FlowRate := {: value <- 50 ; group <- "Operational" :};
   };

  state <-
   {
    OBJ Q_Out1 "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Help (* hidden = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Help (* hidden = "1" *) "Help variable for outflow3 rate" : FlowRate ;
   };

  equations <-
   {
 

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Help + state.Q_Out3_Help);

    state.Q_Out2_Help = IF( parameters.Q_Out2 > state.Q_In)
                      	THEN state.Q_In
                      	ELSE parameters.Q_Out2;

    state.Q_Out3_Help = IF( (parameters.Q_Out2+parameters.Q_Out3) > state.Q_In)
                      	THEN state.Q_In - state.Q_Out2_Help
                      	ELSE parameters.Q_Out3;

    state.f_Out1 = IF (state.Q_In == 0)
			 	   THEN 0
			 	   ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
			 	   THEN 0
			 	   ELSE state.Q_Out2_Help /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
			 	   THEN 0
			 	   ELSE state.Q_Out3_Help / state.Q_In ;

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};
   }; 
 :};
 
 
 CLASS RivThreeCombiner
 (* icon = "three_combiner" *)  
 "three combiner"
 EXTENDS RivAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InRivTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };

  equations <-
   {
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   
   }; 
 :};
# 13 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.convertors.msl" 1
 
 
 
 
 




CLASS CtoF
  (* icon = "Connector" *)
  "cf_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts concentrations into fluxes";
    interface <-
     {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InWWTPConcTerminal := {: causality <- "CIN" ; group <- "Influent" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     };

    parameters <-
     {
      
      


     };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

initial <-
   {
     
   };


    equations <-
    {
     {interface.Outflow[IndexOfSolvent] = - interface.Inflow[IndexOfSolvent] 
      / 0.000001 ;}; 

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
     interface.Outflow[Comp_Index] = - interface.Inflow[Comp_Index] * 
     interface.Inflow[IndexOfSolvent];};
    
   };
 :};

CLASS FtoC
  (* icon = "Connector" *)
  "fc_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts fluxes into concentrations";
    interface <-
    {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutWWTPConcTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    };

    parameters <-
    {

     


    };

    state <-
    {
     OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
     OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
    };

    independent <- 
    {
      OBJ t "Time": Time := {: group <- "Time" :};
    };

initial <-
   {
   
   };

    equations <-
    {
     {interface.Outflow[IndexOfSolvent] = interface.Inflow[IndexOfSolvent] * 0.000001;}; 

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);};

     {state.Q_In = state.InFluxPerComponent[IndexOfSolvent] * 0.000001 ;}; 

     {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
						  THEN 0
						  ELSE interface.Inflow[Comp_Index] / state.Q_In ;};
    
   };
 :};
 
 CLASS SewCtoF
  (* icon = "Connector" *)
  "cf_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts concentrations into fluxes";
    interface <-
     {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InSewConcTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutSewTerminal := {: causality <- "COUT" :};
     };

    parameters <-
     {
      
       


     };

    independent <- 
     {
      OBJ t "Time": Time ;
     };

initial <-
   {
    
   };


    equations <-
    {
     {interface.Outflow[H2O_sew] = - interface.Inflow[H2O_sew] 
      / 0.000001 ;}; 

     {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
     interface.Outflow[s_comp_index] = - interface.Inflow[s_comp_index] * 
     interface.Inflow[H2O_sew];};
    
   };
 :};

 
CLASS SewFtoC
  (* icon = "Connector" *)
  "fc_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts fluxes into concentrations";
    interface <-
    {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InSewTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutSewConcTerminal := {: causality <- "COUT" :};
    };

    parameters <-
    {

     


    };

    state <-
    {
     OBJ Q_In "Influent flow rate" : FlowRate ;
     OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : SewMassFluxVector;
    };

    independent <- 
    {
      OBJ t "Time": Time ;
    };

initial <-
   {
    
   };

    equations <-
    {

     {interface.Outflow[H2O_sew] = interface.Inflow[H2O_sew] * 0.000001;}; 

   {FOREACH Comp_Index IN {1 .. NrOfSewComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER InSewTerminal IN {SelectByType(interface,InSewTerminal)}:
            (InSewTerminal[Comp_Index]);};

     {state.Q_In = state.InFluxPerComponent[H2O_sew] *0.000001 ;}; 

     {FOREACH Comp_Index IN {2 .. NrOfSewComponents}:
      interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
						  THEN 0
						  ELSE interface.Inflow[Comp_Index] / state.Q_In ;};
    
   };
 :};
 
 CLASS RivCtoF
  (* icon = "Connector" *)
  "cf_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts concentrations into fluxes";
    interface <-
     {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InRivConcTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutRivTerminal := {: causality <- "COUT" :};
     };

    parameters <-
     {
      
      


     };

    independent <- 
     {
      OBJ t "Time": Time ;
     };

initial <-
   {
   
   };


    equations <-
    {
     {interface.Outflow[rH2O] = - interface.Inflow[rH2O] 
      / 0.000001 ;}; 

     {FOREACH Comp_Index IN {2 .. RivNrOfComponents}:
     interface.Outflow[Comp_Index] = - interface.Inflow[Comp_Index] * 
     interface.Inflow[rH2O];};

     
   };
 :};

CLASS RivFtoC
  (* icon = "Connector" *)
  "fc_convertor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "Converts fluxes into concentrations";
    interface <-
    {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InRivTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutRivConcTerminal := {: causality <- "COUT" :};
    };

    parameters <-
    {

    


    };

    state <-
    {
     OBJ Q_In "Influent flow rate" : FlowRate ;
     OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : RivMassFluxVector;
    };

    independent <- 
    {
      OBJ t "Time": Time ;
    };

initial <-
   {
    
   };

    equations <-
    {

     {interface.Outflow[rH2O] = interface.Inflow[rH2O] * 0.000001;}; 

   {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
            (In_RivTerminal[Comp_Index]);};

     {state.Q_In = state.InFluxPerComponent[rH2O] * 0.000001 ;}; 

     {FOREACH Comp_Index IN {2 .. RivNrOfComponents}:
      interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
						  THEN 0
						  ELSE interface.Inflow[Comp_Index] / state.Q_In ;};    
   };
 :};
 

# 14 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.connectors.msl" 1


 CLASS Sew_WWTPin
 (* icon = "Connector" *)
 "Generator of WWTP infuent pollutograph"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InSewTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutSewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };
  
  parameters <-
  {
   OBJ ID_Q_1h (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_Q_COD (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_Q_CODs (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_Q_TSS (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_Q_NH4 (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_Q_PO4 (* hidden = "1" *) "ID for buffer" : Real;
   OBJ ID_dilu (* hidden = "1" *) "ID for buffer" : Real;
   
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 30 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, dilution factor" : Fraction := {: value <- 0.7 ; group <- "_Dilution" :};
   OBJ alpha_CODs "Alpha for CODs, dilution factor" : Fraction := {: value <- 0.75 ; group <- "_Dilution" :};
   OBJ alpha_TSS "Alpha for TSS, dilution factor" : Fraction := {: value <- 0.5 ; group <- "_Dilution" :};
   OBJ alpha_NH4 "Alpha for NH4, dilution factor" : Fraction := {: value <- 0.95 ; group <- "_Dilution" :};
   OBJ alpha_PO4 "Alpha for PO4, dilution factor" : Fraction := {: value <- 0.7 ; group <- "_Dilution" :};
   
   OBJ beta_COD "Beta for COD, replenishment factor" : Fraction := {: value <- 0.5 ; group <- "_Replenishment" :};
   OBJ beta_CODs "Beta for CODs, replenishment factor" : Fraction := {: value <- 0.35 ; group <- "_Replenishment" :};
   OBJ beta_TSS "Beta for TSS, replenishment factor" : Fraction := {: value <- 0.4 ; group <- "_Replenishment" :};
   OBJ beta_NH4 "Beta for NH4, replenishment factor" : Fraction := {: value <- 0.6 ; group <- "_Replenishment" :};
   OBJ beta_PO4 "Beta for PO4, replenishment factor" : Fraction := {: value <- 0.5 ; group <- "_Replenishment" :};
   OBJ window_COD "Window length for COD, replenishment factor" : Time := {: value <- 1.5 ; group <- "_Replenishment" :};
   OBJ window_CODs "Window length for COD, replenishment factor" : Time := {: value <- 2 ; group <- "_Replenishment" :};
   OBJ window_TSS "Window length for COD, replenishment factor" : Time := {: value <- 2 ; group <- "_Replenishment" :};
   OBJ window_NH4 "Window length for COD, replenishment factor" : Time := {: value <- 2 ; group <- "_Replenishment" :};
   OBJ window_PO4 "Window length for COD, replenishment factor" : Time := {: value <- 2 ; group <- "_Replenishment" :};
   OBJ window_dilu "Window length for dilution factor" : Time := {: value <- 0.083333333 ; group <- "_Dilution" :};
   
   OBJ peak_COD "Peak factor for COD" : Real := {: value <- 2.5 ; group <- "_Peaks" :};
   OBJ peak_CODs "Peak factor for CODs" : Real := {: value <- 1.2 ; group <- "_Peaks" :};
   OBJ peak_TSS "Peak factor for TSS" : Real := {: value <- 2.5 ; group <- "_Peaks" :};
   OBJ peak_NH4 "Peak factor for NH4" : Real := {: value <- 1.2 ; group <- "_Peaks" :};
   OBJ peak_PO4 "Peak factor for PO4" : Real := {: value <- 1.5 ; group <- "_Peaks" :};
   OBJ Q_peak "Flow value for start of peak concentration" : FlowRate := {: value <- 240000 ; group <- "_Peaks" :};
   OBJ t_max_peak "Maximum duration of peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   OBJ t_COD_peak "Duration of COD peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   OBJ t_CODs_peak "Duration of CODs peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   OBJ t_TSS_peak "Duration of TSS peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   OBJ t_NH4_peak "Duration of NH4 peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   OBJ t_PO4_peak "Duration of PO4 peak concentration" : Time := {: value <- 0.20833333 ; group <- "_Peaks" :};
   
   OBJ Q_95_norm_H00 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H01 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.02 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H02 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H03 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.97 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H04 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.94 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H05 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.89 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H06 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.84 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H07 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H08 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.77 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H09 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.76 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H10 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H11 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.89 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H12 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H13 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H14 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.15 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H15 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.18 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H16 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.18 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H17 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.17 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H18 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.13 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H19 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H20 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H21 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.05 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H22 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.05 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H23 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
			  
   OBJ COD_norm_H00 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H01 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.02 ; group <- "COD_norm" :};
	 OBJ COD_norm_H02 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H03 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.97 ; group <- "COD_norm" :};
	 OBJ COD_norm_H04 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.94 ; group <- "COD_norm" :};
	 OBJ COD_norm_H05 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H06 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.84 ; group <- "COD_norm" :};
	 OBJ COD_norm_H07 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H08 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.77 ; group <- "COD_norm" :};
	 OBJ COD_norm_H09 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H10 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H11 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.15 ; group <- "COD_norm" :};
	 OBJ COD_norm_H12 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H13 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H14 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H15 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H16 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H17 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.17 ; group <- "COD_norm" :};
	 OBJ COD_norm_H18 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.13 ; group <- "COD_norm" :};
	 OBJ COD_norm_H19 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.09 ; group <- "COD_norm" :};
	 OBJ COD_norm_H20 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H21 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H22 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H23 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	  
	 OBJ CODs_norm_H00 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H01 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H02 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H03 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.97 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H04 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.94 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H05 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H06 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.84 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H07 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.80 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H08 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.77 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H09 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.76 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H10 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H11 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.15 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H12 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.76 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H13 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.80 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H14 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H15 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H16 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H17 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.17 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H18 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.13 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H19 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.09 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H20 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H21 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.05 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H22 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.05 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H23 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 
	 OBJ TSS_norm_H00 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H01 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.02 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H02 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H03 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.97 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H04 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.94 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H05 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H06 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.84 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H07 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H08 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.77 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H09 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H10 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H11 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.15 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H12 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H13 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H14 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H15 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H16 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H17 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.17 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H18 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.13 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H19 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.09 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H20 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H21 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H22 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H23 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 
	 OBJ NH4_norm_H00 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H01 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H02 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H03 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H04 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H05 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H06 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.84 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H07 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.80 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H08 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.77 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H09 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.76 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H10 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H11 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.15 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H12 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.76 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H13 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.80 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H14 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H15 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H16 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H17 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.17 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H18 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H19 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H20 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H21 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.05 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H22 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.05 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H23 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 
	 OBJ PO4_norm_H00 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H01 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H02 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H03 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H04 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H05 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H06 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.84 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H07 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.80 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H08 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.77 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H09 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.76 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H10 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H11 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.15 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H12 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.76 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H13 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.80 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H14 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H15 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H16 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H17 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.17 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H18 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H19 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H20 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H21 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.05 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H22 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.05 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H23 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 
	 OBJ Q_95_norm (* hidden = "1" *) "Normalized Q hourly pattern, 95%ile" : HourlyDailyPattern ; 
   OBJ COD_norm (* hidden = "1" *) "Normalized COD hourly pattern, average" : HourlyDailyPattern;  
   OBJ CODs_norm (* hidden = "1" *) "Normalized CODs hourly pattern, average" : HourlyDailyPattern;  
	 OBJ TSS_norm (* hidden = "1" *) "Normalized TSS hourly pattern, average" : HourlyDailyPattern; 
	 OBJ NH4_norm (* hidden = "1" *) "Normalized NH4 hourly pattern, average" : HourlyDailyPattern;  
	 OBJ PO4_norm (* hidden = "1" *) "Normalized PO4 hourly pattern, average" : HourlyDailyPattern;
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "Results" :};
   OBJ Q_integral "Q in integral" : Volume;
   OBJ Buffer_Q_integral_1h (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_Q_integral_COD (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_Q_integral_CODs (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_Q_integral_TSS (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_Q_integral_NH4 (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_Q_integral_PO4 (* hidden = "1" *) "Buffer for Q in integral" : Real;
   OBJ Buffer_dilu (* hidden = "1" *) "Buffer for dilution" : Real;
   OBJ V_1h "V in last hour" : Volume;
   OBJ V_COD "V for COD replenishment" : Volume;
   OBJ V_CODs "V for COD replenishment" : Volume;
   OBJ V_TSS "V for COD replenishment" : Volume;
   OBJ V_NH4 "V for COD replenishment" : Volume;
   OBJ V_PO4 "V for COD replenishment" : Volume;
   OBJ V_1hp "V in last hour previous" : Volume;
   OBJ V_CODp "V for COD replenishment previous" : Volume;
   OBJ V_CODsp "V for COD replenishment previous" : Volume;
   OBJ V_TSSp "V for COD replenishment previous" : Volume;
   OBJ V_NH4p "V for COD replenishment previous" : Volume;
   OBJ V_PO4p "V for COD replenishment previous" : Volume;
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
   OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
   
   OBJ COD "COD" : Concentration := {: group <- "Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "Results" :};
   
   OBJ diluh (* hidden = "0" *) "Dilution factor" : Real;
   OBJ diluhh (* hidden = "0" *) "Dilution factor" : Real;
   OBJ dilu "Dilution factor" : Fraction;
   
   OBJ replCODh (* hidden = "0" *) "Replenishment factor COD" : Real;
   OBJ replCODsh (* hidden = "0" *) "Replenishment factor CODs" : Real;
   OBJ replTSSh (* hidden = "0" *) "Replenishment factor TSS" : Real;
   OBJ replNH4h (* hidden = "0" *) "Replenishment factor NH4" : Real;
   OBJ replPO4h (* hidden = "0" *) "Replenishment factor PO4" : Real;
   OBJ replCOD "Replenishment factor COD" : Fraction;
   OBJ replCODs "Replenishment factor CODs" : Fraction;
   OBJ replTSS "Replenishment factor TSS" : Fraction;
   OBJ replNH4 "Replenishment factor NH4" : Fraction;
   OBJ replPO4 "Replenishment factor PO4" : Fraction;
   
   OBJ t_start (* hidden = "0" *)"Peak start" : Real;
   OBJ peak_COD_factor (* hidden = "0" *)"Peak COD" : Real;
   OBJ peak_CODs_factor (* hidden = "0" *)"Peak CODs" : Real;
   OBJ peak_TSS_factor (* hidden = "0" *)"Peak TSS" : Real;
   OBJ peak_NH4_factor (* hidden = "0" *)"Peak NH4" : Real;
   OBJ peak_PO4_factor (* hidden = "0" *)"Peak PO4" : Real;
  };
  
  initial <-
  {
    
    











   
    
    parameters.ID_Q_1h = MSLUBufferCreate(0.05, 0);
	  parameters.ID_Q_COD = MSLUBufferCreate(parameters.window_COD, 0);
	  parameters.ID_Q_CODs = MSLUBufferCreate(parameters.window_CODs, 0);
	  parameters.ID_Q_TSS = MSLUBufferCreate(parameters.window_TSS, 0);
  	parameters.ID_Q_NH4 = MSLUBufferCreate(parameters.window_NH4, 0);
	  parameters.ID_Q_PO4 = MSLUBufferCreate(parameters.window_PO4, 0);
	  parameters.ID_dilu = MSLUBufferCreate(parameters.window_dilu, 0);
    
	 parameters.Q_95_norm[H00] = parameters.Q_95_norm_H00;
	 parameters.Q_95_norm[H01] = parameters.Q_95_norm_H01;
	 parameters.Q_95_norm[H02] = parameters.Q_95_norm_H02;
	 parameters.Q_95_norm[H03] = parameters.Q_95_norm_H03;
	 parameters.Q_95_norm[H04] = parameters.Q_95_norm_H04;
	 parameters.Q_95_norm[H05] = parameters.Q_95_norm_H05;
	 parameters.Q_95_norm[H06] = parameters.Q_95_norm_H06;
	 parameters.Q_95_norm[H07] = parameters.Q_95_norm_H07;
	 parameters.Q_95_norm[H08] = parameters.Q_95_norm_H08;
	 parameters.Q_95_norm[H09] = parameters.Q_95_norm_H09;
	 parameters.Q_95_norm[H10] = parameters.Q_95_norm_H10;
	 parameters.Q_95_norm[H11] = parameters.Q_95_norm_H11;
	 parameters.Q_95_norm[H12] = parameters.Q_95_norm_H12;
	 parameters.Q_95_norm[H13] = parameters.Q_95_norm_H13;
	 parameters.Q_95_norm[H14] = parameters.Q_95_norm_H14;
	 parameters.Q_95_norm[H15] = parameters.Q_95_norm_H15;
	 parameters.Q_95_norm[H16] = parameters.Q_95_norm_H16;
	 parameters.Q_95_norm[H17] = parameters.Q_95_norm_H17;
	 parameters.Q_95_norm[H18] = parameters.Q_95_norm_H18;
	 parameters.Q_95_norm[H19] = parameters.Q_95_norm_H19;
	 parameters.Q_95_norm[H20] = parameters.Q_95_norm_H20;
	 parameters.Q_95_norm[H21] = parameters.Q_95_norm_H21;
	 parameters.Q_95_norm[H22] = parameters.Q_95_norm_H22;
	 parameters.Q_95_norm[H23] = parameters.Q_95_norm_H23;
	 
	 parameters.COD_norm[H00] = parameters.COD_norm_H00;
	 parameters.COD_norm[H01] = parameters.COD_norm_H01;
	 parameters.COD_norm[H02] = parameters.COD_norm_H02;
	 parameters.COD_norm[H03] = parameters.COD_norm_H03;
	 parameters.COD_norm[H04] = parameters.COD_norm_H04;
	 parameters.COD_norm[H05] = parameters.COD_norm_H05;
	 parameters.COD_norm[H06] = parameters.COD_norm_H06;
	 parameters.COD_norm[H07] = parameters.COD_norm_H07;
	 parameters.COD_norm[H08] = parameters.COD_norm_H08;
	 parameters.COD_norm[H09] = parameters.COD_norm_H09;
	 parameters.COD_norm[H10] = parameters.COD_norm_H10;
	 parameters.COD_norm[H11] = parameters.COD_norm_H11;
	 parameters.COD_norm[H12] = parameters.COD_norm_H12;
	 parameters.COD_norm[H13] = parameters.COD_norm_H13;
	 parameters.COD_norm[H14] = parameters.COD_norm_H14;
	 parameters.COD_norm[H15] = parameters.COD_norm_H15;
	 parameters.COD_norm[H16] = parameters.COD_norm_H16;
	 parameters.COD_norm[H17] = parameters.COD_norm_H17;
	 parameters.COD_norm[H18] = parameters.COD_norm_H18;
	 parameters.COD_norm[H19] = parameters.COD_norm_H19;
	 parameters.COD_norm[H20] = parameters.COD_norm_H20;
	 parameters.COD_norm[H21] = parameters.COD_norm_H21;
	 parameters.COD_norm[H22] = parameters.COD_norm_H22;
	 parameters.COD_norm[H23] = parameters.COD_norm_H23;
	 
	 parameters.CODs_norm[H00] = parameters.CODs_norm_H00;
	 parameters.CODs_norm[H01] = parameters.CODs_norm_H01;
	 parameters.CODs_norm[H02] = parameters.CODs_norm_H02;
	 parameters.CODs_norm[H03] = parameters.CODs_norm_H03;
	 parameters.CODs_norm[H04] = parameters.CODs_norm_H04;
	 parameters.CODs_norm[H05] = parameters.CODs_norm_H05;
	 parameters.CODs_norm[H06] = parameters.CODs_norm_H06;
	 parameters.CODs_norm[H07] = parameters.CODs_norm_H07;
	 parameters.CODs_norm[H08] = parameters.CODs_norm_H08;
	 parameters.CODs_norm[H09] = parameters.CODs_norm_H09;
	 parameters.CODs_norm[H10] = parameters.CODs_norm_H10;
	 parameters.CODs_norm[H11] = parameters.CODs_norm_H11;
	 parameters.CODs_norm[H12] = parameters.CODs_norm_H12;
	 parameters.CODs_norm[H13] = parameters.CODs_norm_H13;
	 parameters.CODs_norm[H14] = parameters.CODs_norm_H14;
	 parameters.CODs_norm[H15] = parameters.CODs_norm_H15;
	 parameters.CODs_norm[H16] = parameters.CODs_norm_H16;
	 parameters.CODs_norm[H17] = parameters.CODs_norm_H17;
	 parameters.CODs_norm[H18] = parameters.CODs_norm_H18;
	 parameters.CODs_norm[H19] = parameters.CODs_norm_H19;
	 parameters.CODs_norm[H20] = parameters.CODs_norm_H20;
	 parameters.CODs_norm[H21] = parameters.CODs_norm_H21;
	 parameters.CODs_norm[H22] = parameters.CODs_norm_H22;
	 parameters.CODs_norm[H23] = parameters.CODs_norm_H23;
	 
	 parameters.TSS_norm[H00] = parameters.TSS_norm_H00;
	 parameters.TSS_norm[H01] = parameters.TSS_norm_H01;
	 parameters.TSS_norm[H02] = parameters.TSS_norm_H02;
	 parameters.TSS_norm[H03] = parameters.TSS_norm_H03;
	 parameters.TSS_norm[H04] = parameters.TSS_norm_H04;
	 parameters.TSS_norm[H05] = parameters.TSS_norm_H05;
	 parameters.TSS_norm[H06] = parameters.TSS_norm_H06;
	 parameters.TSS_norm[H07] = parameters.TSS_norm_H07;
	 parameters.TSS_norm[H08] = parameters.TSS_norm_H08;
	 parameters.TSS_norm[H09] = parameters.TSS_norm_H09;
	 parameters.TSS_norm[H10] = parameters.TSS_norm_H10;
	 parameters.TSS_norm[H11] = parameters.TSS_norm_H11;
	 parameters.TSS_norm[H12] = parameters.TSS_norm_H12;
	 parameters.TSS_norm[H13] = parameters.TSS_norm_H13;
	 parameters.TSS_norm[H14] = parameters.TSS_norm_H14;
	 parameters.TSS_norm[H15] = parameters.TSS_norm_H15;
	 parameters.TSS_norm[H16] = parameters.TSS_norm_H16;
	 parameters.TSS_norm[H17] = parameters.TSS_norm_H17;
	 parameters.TSS_norm[H18] = parameters.TSS_norm_H18;
	 parameters.TSS_norm[H19] = parameters.TSS_norm_H19;
	 parameters.TSS_norm[H20] = parameters.TSS_norm_H20;
	 parameters.TSS_norm[H21] = parameters.TSS_norm_H21;
	 parameters.TSS_norm[H22] = parameters.TSS_norm_H22;
	 parameters.TSS_norm[H23] = parameters.TSS_norm_H23;
	 
	 parameters.NH4_norm[H00] = parameters.NH4_norm_H00;
	 parameters.NH4_norm[H01] = parameters.NH4_norm_H01;
	 parameters.NH4_norm[H02] = parameters.NH4_norm_H02;
	 parameters.NH4_norm[H03] = parameters.NH4_norm_H03;
	 parameters.NH4_norm[H04] = parameters.NH4_norm_H04;
	 parameters.NH4_norm[H05] = parameters.NH4_norm_H05;
	 parameters.NH4_norm[H06] = parameters.NH4_norm_H06;
	 parameters.NH4_norm[H07] = parameters.NH4_norm_H07;
	 parameters.NH4_norm[H08] = parameters.NH4_norm_H08;
	 parameters.NH4_norm[H09] = parameters.NH4_norm_H09;
	 parameters.NH4_norm[H10] = parameters.NH4_norm_H10;
	 parameters.NH4_norm[H11] = parameters.NH4_norm_H11;
	 parameters.NH4_norm[H12] = parameters.NH4_norm_H12;
	 parameters.NH4_norm[H13] = parameters.NH4_norm_H13;
	 parameters.NH4_norm[H14] = parameters.NH4_norm_H14;
	 parameters.NH4_norm[H15] = parameters.NH4_norm_H15;
	 parameters.NH4_norm[H16] = parameters.NH4_norm_H16;
	 parameters.NH4_norm[H17] = parameters.NH4_norm_H17;
	 parameters.NH4_norm[H18] = parameters.NH4_norm_H18;
	 parameters.NH4_norm[H19] = parameters.NH4_norm_H19;
	 parameters.NH4_norm[H20] = parameters.NH4_norm_H20;
	 parameters.NH4_norm[H21] = parameters.NH4_norm_H21;
	 parameters.NH4_norm[H22] = parameters.NH4_norm_H22;
	 parameters.NH4_norm[H23] = parameters.NH4_norm_H23;
	 
	 parameters.PO4_norm[H00] = parameters.PO4_norm_H00;
	 parameters.PO4_norm[H01] = parameters.PO4_norm_H01;
	 parameters.PO4_norm[H02] = parameters.PO4_norm_H02;
	 parameters.PO4_norm[H03] = parameters.PO4_norm_H03;
	 parameters.PO4_norm[H04] = parameters.PO4_norm_H04;
	 parameters.PO4_norm[H05] = parameters.PO4_norm_H05;
	 parameters.PO4_norm[H06] = parameters.PO4_norm_H06;
	 parameters.PO4_norm[H07] = parameters.PO4_norm_H07;
	 parameters.PO4_norm[H08] = parameters.PO4_norm_H08;
	 parameters.PO4_norm[H09] = parameters.PO4_norm_H09;
	 parameters.PO4_norm[H10] = parameters.PO4_norm_H10;
	 parameters.PO4_norm[H11] = parameters.PO4_norm_H11;
	 parameters.PO4_norm[H12] = parameters.PO4_norm_H12;
	 parameters.PO4_norm[H13] = parameters.PO4_norm_H13;
	 parameters.PO4_norm[H14] = parameters.PO4_norm_H14;
	 parameters.PO4_norm[H15] = parameters.PO4_norm_H15;
	 parameters.PO4_norm[H16] = parameters.PO4_norm_H16;
	 parameters.PO4_norm[H17] = parameters.PO4_norm_H17;
	 parameters.PO4_norm[H18] = parameters.PO4_norm_H18;
	 parameters.PO4_norm[H19] = parameters.PO4_norm_H19;
	 parameters.PO4_norm[H20] = parameters.PO4_norm_H20;
	 parameters.PO4_norm[H21] = parameters.PO4_norm_H21;
	 parameters.PO4_norm[H22] = parameters.PO4_norm_H22;
	 parameters.PO4_norm[H23] = parameters.PO4_norm_H23;
  };

  equations <-
  {
   state.Q_in = interface.Inflow[H2O_sew] / 1000000;
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
   
   state.Buffer_Q_integral_1h = MSLUBufferPut(parameters.ID_Q_1h, independent.t, state.Q_integral);
   state.Buffer_Q_integral_COD = MSLUBufferPut(parameters.ID_Q_COD, independent.t, state.Q_integral);
   state.Buffer_Q_integral_CODs = MSLUBufferPut(parameters.ID_Q_CODs, independent.t, state.Q_integral);
   state.Buffer_Q_integral_TSS = MSLUBufferPut(parameters.ID_Q_TSS, independent.t, state.Q_integral);
   state.Buffer_Q_integral_NH4 = MSLUBufferPut(parameters.ID_Q_NH4, independent.t, state.Q_integral);
   state.Buffer_Q_integral_PO4 = MSLUBufferPut(parameters.ID_Q_PO4, independent.t, state.Q_integral);
   
   state.V_1hp = MSLUBufferGet(parameters.ID_Q_1h, (independent.t - 0.041666667));
   state.V_CODp = MSLUBufferGet(parameters.ID_Q_COD, (independent.t - parameters.window_COD));
   state.V_CODsp = MSLUBufferGet(parameters.ID_Q_CODs, (independent.t - parameters.window_CODs));
   state.V_TSSp = MSLUBufferGet(parameters.ID_Q_TSS, (independent.t - parameters.window_TSS));
   state.V_NH4p = MSLUBufferGet(parameters.ID_Q_NH4, (independent.t - parameters.window_NH4));
   state.V_PO4p = MSLUBufferGet(parameters.ID_Q_PO4, (independent.t - parameters.window_PO4));
   
   state.V_1h = state.Q_integral - state.V_1hp;
   state.V_COD = state.Q_integral - state.V_CODp;
   state.V_CODs = state.Q_integral - state.V_CODsp;
   state.V_TSS = state.Q_integral - state.V_TSSp;
   state.V_NH4 = state.Q_integral - state.V_NH4p;
   state.V_PO4 = state.Q_integral - state.V_PO4p;
      
   state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.Timestep = floor(state.Daytime) + 1;
   
   state.diluh = IF (state.V_1h > 1)
   			   	 THEN parameters.Q_95_av * parameters.Q_95_norm[state.Timestep] / (state.V_1h * 24)
				 ELSE 1;
   state.Buffer_dilu = MSLUBufferPut(parameters.ID_dilu, independent.t, state.diluh);
   state.diluhh = MSLUBufferGet(parameters.ID_dilu, (independent.t - parameters.window_dilu));
   state.dilu = IF (state.diluhh > 1)
   			    THEN 1
				ELSE IF (state.diluhh <= 0.01)
				     THEN 0.01
					 ELSE state.diluhh;
				
   state.replCODh = parameters.Q_95_av * parameters.window_COD / state.V_COD;
   state.replCOD = IF (state.replCODh > 1)
   			       THEN 1
				   ELSE state.replCODh;
				   
   state.replCODsh = parameters.Q_95_av * parameters.window_CODs / state.V_CODs;
   state.replCODs = IF (state.replCODsh > 1)
   			       THEN 1
				   ELSE state.replCODsh;
				   
   state.replTSSh = parameters.Q_95_av * parameters.window_TSS / state.V_TSS;
   state.replTSS = IF (state.replTSSh > 1)
   			       THEN 1
				   ELSE state.replTSSh;
				   
   state.replNH4h = parameters.Q_95_av * parameters.window_NH4 / state.V_NH4;
   state.replNH4 = IF (state.replNH4h > 1)
   			       THEN 1
				   ELSE state.replNH4h;
				   
   state.replPO4h = parameters.Q_95_av * parameters.window_PO4 / state.V_PO4;
   state.replPO4 = IF (state.replPO4h > 1)
   			       THEN 1
				   ELSE state.replPO4h;
   
   state.t_start = IF ((previous(state.t_start) == 0) && (state.Q_in > parameters.Q_peak))
   				   THEN independent.t
				   ELSE IF ((previous(state.t_start) > 0) && ((independent.t - state.t_start) > parameters.t_max_peak))
				   		THEN 0
					    ELSE previous(state.t_start);
						
   state.peak_COD_factor = IF ((independent.t - state.t_start) < parameters.t_COD_peak)
   					       THEN parameters.peak_COD
					       ELSE 1;
   state.peak_CODs_factor = IF ((independent.t - state.t_start) < parameters.t_CODs_peak)
   					       THEN parameters.peak_CODs
					       ELSE 1;
   state.peak_TSS_factor = IF ((independent.t - state.t_start) < parameters.t_TSS_peak)
   					       THEN parameters.peak_TSS
					       ELSE 1;
   state.peak_NH4_factor = IF ((independent.t - state.t_start) < parameters.t_NH4_peak)
   					       THEN parameters.peak_NH4
					       ELSE 1;
   state.peak_PO4_factor = IF ((independent.t - state.t_start) < parameters.t_PO4_peak)
   					       THEN parameters.peak_PO4
					       ELSE 1;
   				
   state.COD = parameters.COD_av * parameters.COD_norm[state.Timestep] 
   			 * (parameters.alpha_COD * (state.dilu - 1) + 1)  
			 * (parameters.beta_COD * (state.replCOD - 1) + 1)  
			 * state.peak_COD_factor;  

   state.CODs = parameters.CODs_av * parameters.CODs_norm[state.Timestep] 
   			 * (parameters.alpha_CODs * (state.dilu - 1) + 1)  
			 * (parameters.beta_CODs * (state.replCODs - 1) + 1)  
			 * state.peak_CODs_factor;  
			 
   state.TSS = parameters.TSS_av * parameters.TSS_norm[state.Timestep] 
   			 * (parameters.alpha_TSS * (state.dilu - 1) + 1)  
			 * (parameters.beta_TSS * (state.replTSS - 1) + 1)  
			 * state.peak_TSS_factor;  
			 
   state.NH4 = parameters.NH4_av * parameters.NH4_norm[state.Timestep] 
   			 * (parameters.alpha_NH4 * (state.dilu - 1) + 1)  
			 * (parameters.beta_NH4 * (state.replNH4 - 1) + 1)  
			 * state.peak_NH4_factor;  
			 
   state.PO4 = parameters.PO4_av * parameters.PO4_norm[state.Timestep] 
   			 * (parameters.alpha_PO4 * (state.dilu - 1) + 1)  
			 * (parameters.beta_PO4 * (state.replPO4 - 1) + 1)  
			 * state.peak_PO4_factor;  

   interface.Outflow[H2O_sew] = -interface.Inflow[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};

 CLASS Sew_WWTPin_2
 (* icon = "Connector" *)
 "Generator of WWTP infuent pollutograph, second version"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InSewTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutSewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	  OBJ FD (* terminal = "in_2" *) "Filling Degree" : 
      Real  := {: causality <- "CIN" ; group <- "Influent" :};
  };
  
  parameters <-
  {
   OBJ Q_event "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ Qsw_event8 "Flow sw value for start of event8" : FlowRate := {: value <- 12000 ; group <- "_Events" :};
	 OBJ Qsw_event9 "Flow sw value for start of event9" : FlowRate := {: value <- 96000 ; group <- "_Events" :};
	 OBJ FD_event "Filling degree value for start of event3" : Real := {: value <- 0.21 ; group <- "_Events" :};
	 OBJ T_Average "Averaging time for Q_mean" : Time := {: value <- 0.02083; group <- "_Events" :};
	 
   OBJ Q_95_av "Daily average Q, 95%ile" : FlowRate := {: value <- 70000 ; group <- "_Averages" :};
   OBJ COD_av "COD daily average concentration" : Concentration := {: value <- 642 ; group <- "_Averages" :};
   OBJ CODs_av "CODs daily average concentration" : Concentration := {: value <- 197.3 ; group <- "_Averages" :};
   OBJ TSS_av "TSS daily average concentration" : Concentration := {: value <- 289.6 ; group <- "_Averages" :};
   OBJ NH4_av "NH4 daily average concentration" : Concentration := {: value <- 35 ; group <- "_Averages" :};
   OBJ PO4_av "PO4 daily average concentration" : Concentration := {: value <- 7 ; group <- "_Averages" :};
   
   OBJ alpha_COD "Alpha for COD, proc2" : Fraction := {: value <- 0.8 ; group <- "_proc2" :};
   OBJ alpha_CODs "Alpha for CODs, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_TSS "Alpha for TSS, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_NH4 "Alpha for NH4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   OBJ alpha_PO4 "Alpha for PO4, proc2" : Fraction := {: value <- 1 ; group <- "_proc2" :};
   
   OBJ beta_COD "Beta for COD, proc3" : Fraction := {: value <- 0.8 ; group <- "_proc3" :};
   OBJ beta_CODs "Beta for CODs, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_TSS "Beta for TSS, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_NH4 "Beta for NH4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
   OBJ beta_PO4 "Beta for PO4, proc3" : Fraction := {: value <- 1 ; group <- "_proc3" :};
	 
	 OBJ proc4_slope1_COD "Slope1 for COD, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_CODs "Slope1 for CODs, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_TSS "Slope1 for TSS, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_NH4 "Slope1 for NH4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
   OBJ proc4_slope1_PO4 "Slope1 for PO4, proc4" : Fraction := {: value <- 0.576 ; group <- "_proc4" :};
	 
	 OBJ proc4_slope2_COD "Slope2 for COD, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_CODs "Slope2 for CODs, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_TSS "Slope2 for TSS, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_NH4 "Slope2 for NH4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
   OBJ proc4_slope2_PO4 "Slope2 for PO4, proc4" : Fraction := {: value <- 0.288 ; group <- "_proc4" :};
	 
   OBJ window_proc4_COD "Window length for COD, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_CODs "Window length for CODs, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_TSS "Window length for TSS, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_NH4 "Window length for NH4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
   OBJ window_proc4_PO4 "Window length for PO4, proc4" : Time := {: value <- 0.8333 ; group <- "_proc4" :};
	 
	 OBJ proc5_slope_CODs "Slope for CODs, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_NH4 "Slope for NH4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
   OBJ proc5_slope_PO4 "Slope for PO4, proc5" : Fraction := {: value <- 0.576 ; group <- "_proc5" :};
	 
   OBJ window_proc5_CODs "Window length for CODs, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_NH4 "Window length for NH4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
   OBJ window_proc5_PO4 "Window length for PO4, proc5" : Time := {: value <- 1.0833 ; group <- "_proc5" :};
	 
	 OBJ Q_proc6 "Flow value for start of event" : FlowRate := {: value <- 96000 ; group <- "_proc6" :};
	 OBJ peak_COD_high "Proc6 high COD peak concentration" : Concentration := {: value <- 600 ; group <- "_proc6" :};
	 OBJ peak_COD_low "Proc6 low COD peak concentration" : Concentration := {: value <- 300 ; group <- "_proc6" :};
	 OBJ proc6_slope1_COD "Slope1 for COD, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_COD "Slope2 for COD, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ peak_TSS_high "Proc6 high TSS peak concentration" : Concentration := {: value <- 200 ; group <- "_proc6" :};
	 OBJ peak_TSS_low "Proc6 low TSS peak concentration" : Concentration := {: value <- 100 ; group <- "_proc6" :};
	 OBJ proc6_slope1_TSS "Slope1 for TSS, proc6" : Real := {: value <- 1728 ; group <- "_proc6" :};
	 OBJ proc6_slope2_TSS "Slope2 for TSS, proc6" : Real := {: value <- 1296 ; group <- "_proc6" :};
	 OBJ proc6_t1_COD "Time1 for COD high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_COD "Time2 for COD low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 OBJ proc6_t1_TSS "Time1 for TSS high, proc6" : Time := {: value <- 0.5 ; group <- "_proc6" :};
	 OBJ proc6_t2_TSS "Time2 for TSS low, proc6" : Time := {: value <- 1.5 ; group <- "_proc6" :};
	 
	 OBJ proc7_slope1_COD "Slope1 for COD, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_COD "Slope2 for COD, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
	 OBJ proc7_slope1_TSS "Slope1 for TSS, proc7" : Real := {: value <- 2880 ; group <- "_proc7" :};
	 OBJ proc7_slope2_TSS "Slope2 for TSS, proc7" : Real := {: value <- 720 ; group <- "_proc7" :};
   
   OBJ Q_95_norm_H00 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.04 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H01 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.00 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H02 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.94 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H03 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.87 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H04 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.80 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H05 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.75 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H06 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.72 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H07 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.74 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H08 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.84 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H09 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 0.97 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H10 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H11 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H12 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.11 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H13 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H14 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.15 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H15 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.14 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H16 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.10 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H17 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H18 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H19 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.07 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H20 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H21 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.09 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H22 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.08 ; group <- "Q_95_norm" :};
	 OBJ Q_95_norm_H23 (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : Real := {: value <- 1.06 ; group <- "Q_95_norm" :};
	 
	 OBJ NH4_norm_H00 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H01 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H02 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H03 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H04 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H05 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H06 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H07 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H08 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H09 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H10 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H11 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H12 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H13 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H14 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H15 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H16 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H17 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H18 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H19 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H20 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H21 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H22 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 OBJ NH4_norm_H23 (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "NH4_norm" :};
	 
	 OBJ COD_norm_H00 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.02 ; group <- "COD_norm" :};
	 OBJ COD_norm_H01 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H02 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.97 ; group <- "COD_norm" :};
	 OBJ COD_norm_H03 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.94 ; group <- "COD_norm" :};
	 OBJ COD_norm_H04 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H05 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.84 ; group <- "COD_norm" :};
	 OBJ COD_norm_H06 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H07 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.77 ; group <- "COD_norm" :};
	 OBJ COD_norm_H08 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.76 ; group <- "COD_norm" :};
	 OBJ COD_norm_H09 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.80 ; group <- "COD_norm" :};
	 OBJ COD_norm_H10 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 0.89 ; group <- "COD_norm" :};
	 OBJ COD_norm_H11 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.00 ; group <- "COD_norm" :};
	 OBJ COD_norm_H12 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.10 ; group <- "COD_norm" :};
	 OBJ COD_norm_H13 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.15 ; group <- "COD_norm" :};
	 OBJ COD_norm_H14 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H15 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.18 ; group <- "COD_norm" :};
	 OBJ COD_norm_H16 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.17 ; group <- "COD_norm" :};
	 OBJ COD_norm_H17 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.13 ; group <- "COD_norm" :};
	 OBJ COD_norm_H18 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.09 ; group <- "COD_norm" :};
	 OBJ COD_norm_H19 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H20 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H21 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.05 ; group <- "COD_norm" :};
	 OBJ COD_norm_H22 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 OBJ COD_norm_H23 (* hidden = "0" *) "Normalized COD hourly pattern, average" : Real := {: value <- 1.07 ; group <- "COD_norm" :};
	 
	 OBJ CODs_norm_H00 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H01 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H02 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H03 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.99 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H04 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.97 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H05 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.94 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H06 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.92 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H07 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.89 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H08 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.87 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H09 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.91 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H10 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H11 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.09 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H12 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.13 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H13 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.10 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H14 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.04 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H15 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H16 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H17 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.02 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H18 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.06 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H19 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.07 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H20 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.03 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H21 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 1.00 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H22 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 OBJ CODs_norm_H23 (* hidden = "0" *) "Normalized CODs hourly pattern, average" : Real := {: value <- 0.98 ; group <- "CODs_norm" :};
	 
	 OBJ PO4_norm_H00 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H01 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H02 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H03 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.99 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H04 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.97 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H05 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.94 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H06 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.92 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H07 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.89 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H08 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.87 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H09 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.91 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H10 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H11 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.09 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H12 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.13 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H13 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.10 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H14 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.04 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H15 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H16 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H17 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.02 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H18 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.06 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H19 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.07 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H20 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.03 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H21 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 1.00 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H22 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 OBJ PO4_norm_H23 (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : Real := {: value <- 0.98 ; group <- "PO4_norm" :};
	 
	 OBJ TSS_norm_H00 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.02 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H01 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H02 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.97 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H03 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.94 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H04 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H05 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.84 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H06 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H07 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.77 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H08 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.76 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H09 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.80 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H10 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 0.89 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H11 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.00 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H12 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.10 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H13 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.15 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H14 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H15 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.18 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H16 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.17 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H17 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.13 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H18 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.09 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H19 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H20 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H21 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.05 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H22 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 OBJ TSS_norm_H23 (* hidden = "0" *) "Normalized TSS hourly pattern, average" : Real := {: value <- 1.07 ; group <- "TSS_norm" :};
	 
	 OBJ Q_95_norm (* hidden = "0" *) "Normalized Q hourly pattern, 95%ile" : HourlyDailyPattern := {: group <- "z" :}; 
   OBJ COD_norm (* hidden = "0" *) "Normalized COD hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
   OBJ CODs_norm (* hidden = "0" *) "Normalized CODs hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ TSS_norm (* hidden = "0" *) "Normalized TSS hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :}; 
	 OBJ NH4_norm (* hidden = "0" *) "Normalized NH4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};  
	 OBJ PO4_norm (* hidden = "0" *) "Normalized PO4 hourly pattern, average" : HourlyDailyPattern := {: group <- "z" :};
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate := {: group <- "_Results" :};
   OBJ Q_integral "Q in integral" : Volume;
	 OBJ Qsw "Qsw" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_DWF_UB "Q DWF UB" : FlowRate := {: group <- "_Results" :};
	 OBJ Q_mean "Averaged influent flow rate" : FlowRate := {: group <- "_Results" :};
   
   OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
   OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
   OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
	 
	 OBJ event "Type of event" : Integer;
	 OBJ event8 "1 yes, 0 no" : Integer;
	 OBJ event8_h "1 yes, 0 no" : Integer;
	 OBJ t_start_event8 (* hidden = "0" *) "Time since event8 start" : Time;
	 OBJ t_end_event8_h (* hidden = "0" *) "Time since event8_h end" : Time;
   
   OBJ COD "COD" : Concentration := {: group <- "_Results" :};
   OBJ CODs "CODs" : Concentration := {: group <- "_Results" :};
   OBJ TSS "TSS" : Concentration := {: group <- "_Results" :};
   OBJ NH4 "NH4" : Concentration := {: group <- "_Results" :};
   OBJ PO4 "PO4" : Concentration := {: group <- "_Results" :};
   
   OBJ proc1_NH4 (* hidden = "0" *) "DWF, NH4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_NH4 (* hidden = "0" *) "Dilution in large events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc3_NH4 (* hidden = "0" *) "Dilution in medium events, NH4" : Real := {: group <- "_Process" :};
   OBJ proc4_NH4 (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc4_NH4_h (* hidden = "0" *) "Replenishment large and medium events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_NH4 (* hidden = "0" *) "Dilution and replenishment small events, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_NH4 (* hidden = "0" *) "Dilution and replenishment first small event, NH4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_NH4 (* hidden = "0" *) "Dilution and replenishment second small event, NH4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_CODs (* hidden = "0" *) "DWF, CODs" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_CODs (* hidden = "0" *) "Dilution in large events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc3_CODs (* hidden = "0" *) "Dilution in medium events, CODs" : Real := {: group <- "_Process" :};
   OBJ proc4_CODs (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc4_CODs_h (* hidden = "0" *) "Replenishment large and medium events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_CODs (* hidden = "0" *) "Dilution and replenishment small events, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_CODs (* hidden = "0" *) "Dilution and replenishment first small event, CODs" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_CODs (* hidden = "0" *) "Dilution and replenishment second small event, CODs" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_PO4 (* hidden = "0" *) "DWF, PO4" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_PO4 (* hidden = "0" *) "Dilution in large events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc3_PO4 (* hidden = "0" *) "Dilution in medium events, PO4" : Real := {: group <- "_Process" :};
   OBJ proc4_PO4 (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc4_PO4_h (* hidden = "0" *) "Replenishment large and medium events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_PO4 (* hidden = "0" *) "Dilution and replenishment small events, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_1_PO4 (* hidden = "0" *) "Dilution and replenishment first small event, PO4" : Real := {: group <- "_Process" :};
	 OBJ proc5_2_PO4 (* hidden = "0" *) "Dilution and replenishment second small event, PO4" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_COD (* hidden = "0" *) "DWF, COD" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_COD (* hidden = "0" *) "Dilution in large events, COD" : Real := {: group <- "_Process" :};
   OBJ proc3_COD (* hidden = "0" *) "Dilution in medium events, COD" : Real := {: group <- "_Process" :};
   OBJ proc4_COD (* hidden = "0" *) "Replenishment large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc6_COD_h (* hidden = "0" *) "Resuspention large and medium events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 OBJ proc7_COD_h (* hidden = "0" *) "Resuspention small events, COD" : Real := {: group <- "_Process" :};
	 
	 OBJ proc1_TSS (* hidden = "0" *) "DWF, TSS" : Concentration := {: group <- "_Process" :};
	 OBJ proc2_TSS (* hidden = "0" *) "Dilution in large events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc3_TSS (* hidden = "0" *) "Dilution in medium events, TSS" : Real := {: group <- "_Process" :};
   OBJ proc4_TSS (* hidden = "0" *) "Replenishment large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc6_TSS_h (* hidden = "0" *) "Resuspention large and medium events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 OBJ proc7_TSS_h (* hidden = "0" *) "Resuspention small events, TSS" : Real := {: group <- "_Process" :};
	 
	 OBJ t_proc4 (* hidden = "1" *) "Time since proc4 start" : Time;
	 OBJ t_start_proc4 (* hidden = "1" *)"Proc4 start" : Time;
	 OBJ t_event39 (* hidden = "1" *)"Time since event3 or event9 end" : Time;
	 OBJ t_end_event39 (* hidden = "1" *)"Event3 or event9 end" : Time;
	 OBJ t_start_proc5_1 (* hidden = "1" *)"Proc5_1 start" : Time;
	 OBJ t_start_proc5_2 (* hidden = "1" *)"Proc5_2 start" : Time;
	};
  
  initial <-
  { 
	 state.proc2_NH4 = 1;
	 state.proc3_NH4 = 1;
	 state.proc4_NH4 = 1;
	 state.proc5_NH4 = 1;
	 state.proc2_CODs = 1;
	 state.proc3_CODs = 1;
	 state.proc4_CODs = 1;
	 state.proc5_CODs = 1;
	 state.proc2_PO4 = 1;
	 state.proc3_PO4 = 1;
	 state.proc4_PO4 = 1;
	 state.proc5_PO4 = 1;
	 state.proc2_COD = 1;
	 state.proc3_COD = 1;
	 state.proc4_COD = 1;
	 state.proc2_TSS = 1;
	 state.proc3_TSS = 1;
	 state.proc4_TSS = 1;
	 
	 parameters.Q_95_norm[H00] = parameters.Q_95_norm_H00;
	 parameters.Q_95_norm[H01] = parameters.Q_95_norm_H01;
	 parameters.Q_95_norm[H02] = parameters.Q_95_norm_H02;
	 parameters.Q_95_norm[H03] = parameters.Q_95_norm_H03;
	 parameters.Q_95_norm[H04] = parameters.Q_95_norm_H04;
	 parameters.Q_95_norm[H05] = parameters.Q_95_norm_H05;
	 parameters.Q_95_norm[H06] = parameters.Q_95_norm_H06;
	 parameters.Q_95_norm[H07] = parameters.Q_95_norm_H07;
	 parameters.Q_95_norm[H08] = parameters.Q_95_norm_H08;
	 parameters.Q_95_norm[H09] = parameters.Q_95_norm_H09;
	 parameters.Q_95_norm[H10] = parameters.Q_95_norm_H10;
	 parameters.Q_95_norm[H11] = parameters.Q_95_norm_H11;
	 parameters.Q_95_norm[H12] = parameters.Q_95_norm_H12;
	 parameters.Q_95_norm[H13] = parameters.Q_95_norm_H13;
	 parameters.Q_95_norm[H14] = parameters.Q_95_norm_H14;
	 parameters.Q_95_norm[H15] = parameters.Q_95_norm_H15;
	 parameters.Q_95_norm[H16] = parameters.Q_95_norm_H16;
	 parameters.Q_95_norm[H17] = parameters.Q_95_norm_H17;
	 parameters.Q_95_norm[H18] = parameters.Q_95_norm_H18;
	 parameters.Q_95_norm[H19] = parameters.Q_95_norm_H19;
	 parameters.Q_95_norm[H20] = parameters.Q_95_norm_H20;
	 parameters.Q_95_norm[H21] = parameters.Q_95_norm_H21;
	 parameters.Q_95_norm[H22] = parameters.Q_95_norm_H22;
	 parameters.Q_95_norm[H23] = parameters.Q_95_norm_H23;
	 
	 parameters.NH4_norm[H00] = parameters.NH4_norm_H00;
	 parameters.NH4_norm[H01] = parameters.NH4_norm_H01;
	 parameters.NH4_norm[H02] = parameters.NH4_norm_H02;
	 parameters.NH4_norm[H03] = parameters.NH4_norm_H03;
	 parameters.NH4_norm[H04] = parameters.NH4_norm_H04;
	 parameters.NH4_norm[H05] = parameters.NH4_norm_H05;
	 parameters.NH4_norm[H06] = parameters.NH4_norm_H06;
	 parameters.NH4_norm[H07] = parameters.NH4_norm_H07;
	 parameters.NH4_norm[H08] = parameters.NH4_norm_H08;
	 parameters.NH4_norm[H09] = parameters.NH4_norm_H09;
	 parameters.NH4_norm[H10] = parameters.NH4_norm_H10;
	 parameters.NH4_norm[H11] = parameters.NH4_norm_H11;
	 parameters.NH4_norm[H12] = parameters.NH4_norm_H12;
	 parameters.NH4_norm[H13] = parameters.NH4_norm_H13;
	 parameters.NH4_norm[H14] = parameters.NH4_norm_H14;
	 parameters.NH4_norm[H15] = parameters.NH4_norm_H15;
	 parameters.NH4_norm[H16] = parameters.NH4_norm_H16;
	 parameters.NH4_norm[H17] = parameters.NH4_norm_H17;
	 parameters.NH4_norm[H18] = parameters.NH4_norm_H18;
	 parameters.NH4_norm[H19] = parameters.NH4_norm_H19;
	 parameters.NH4_norm[H20] = parameters.NH4_norm_H20;
	 parameters.NH4_norm[H21] = parameters.NH4_norm_H21;
	 parameters.NH4_norm[H22] = parameters.NH4_norm_H22;
	 parameters.NH4_norm[H23] = parameters.NH4_norm_H23;
	 
	 parameters.COD_norm[H00] = parameters.COD_norm_H00;
	 parameters.COD_norm[H01] = parameters.COD_norm_H01;
	 parameters.COD_norm[H02] = parameters.COD_norm_H02;
	 parameters.COD_norm[H03] = parameters.COD_norm_H03;
	 parameters.COD_norm[H04] = parameters.COD_norm_H04;
	 parameters.COD_norm[H05] = parameters.COD_norm_H05;
	 parameters.COD_norm[H06] = parameters.COD_norm_H06;
	 parameters.COD_norm[H07] = parameters.COD_norm_H07;
	 parameters.COD_norm[H08] = parameters.COD_norm_H08;
	 parameters.COD_norm[H09] = parameters.COD_norm_H09;
	 parameters.COD_norm[H10] = parameters.COD_norm_H10;
	 parameters.COD_norm[H11] = parameters.COD_norm_H11;
	 parameters.COD_norm[H12] = parameters.COD_norm_H12;
	 parameters.COD_norm[H13] = parameters.COD_norm_H13;
	 parameters.COD_norm[H14] = parameters.COD_norm_H14;
	 parameters.COD_norm[H15] = parameters.COD_norm_H15;
	 parameters.COD_norm[H16] = parameters.COD_norm_H16;
	 parameters.COD_norm[H17] = parameters.COD_norm_H17;
	 parameters.COD_norm[H18] = parameters.COD_norm_H18;
	 parameters.COD_norm[H19] = parameters.COD_norm_H19;
	 parameters.COD_norm[H20] = parameters.COD_norm_H20;
	 parameters.COD_norm[H21] = parameters.COD_norm_H21;
	 parameters.COD_norm[H22] = parameters.COD_norm_H22;
	 parameters.COD_norm[H23] = parameters.COD_norm_H23;
	 
	 parameters.CODs_norm[H00] = parameters.CODs_norm_H00;
	 parameters.CODs_norm[H01] = parameters.CODs_norm_H01;
	 parameters.CODs_norm[H02] = parameters.CODs_norm_H02;
	 parameters.CODs_norm[H03] = parameters.CODs_norm_H03;
	 parameters.CODs_norm[H04] = parameters.CODs_norm_H04;
	 parameters.CODs_norm[H05] = parameters.CODs_norm_H05;
	 parameters.CODs_norm[H06] = parameters.CODs_norm_H06;
	 parameters.CODs_norm[H07] = parameters.CODs_norm_H07;
	 parameters.CODs_norm[H08] = parameters.CODs_norm_H08;
	 parameters.CODs_norm[H09] = parameters.CODs_norm_H09;
	 parameters.CODs_norm[H10] = parameters.CODs_norm_H10;
	 parameters.CODs_norm[H11] = parameters.CODs_norm_H11;
	 parameters.CODs_norm[H12] = parameters.CODs_norm_H12;
	 parameters.CODs_norm[H13] = parameters.CODs_norm_H13;
	 parameters.CODs_norm[H14] = parameters.CODs_norm_H14;
	 parameters.CODs_norm[H15] = parameters.CODs_norm_H15;
	 parameters.CODs_norm[H16] = parameters.CODs_norm_H16;
	 parameters.CODs_norm[H17] = parameters.CODs_norm_H17;
	 parameters.CODs_norm[H18] = parameters.CODs_norm_H18;
	 parameters.CODs_norm[H19] = parameters.CODs_norm_H19;
	 parameters.CODs_norm[H20] = parameters.CODs_norm_H20;
	 parameters.CODs_norm[H21] = parameters.CODs_norm_H21;
	 parameters.CODs_norm[H22] = parameters.CODs_norm_H22;
	 parameters.CODs_norm[H23] = parameters.CODs_norm_H23;
	 
	 parameters.PO4_norm[H00] = parameters.PO4_norm_H00;
	 parameters.PO4_norm[H01] = parameters.PO4_norm_H01;
	 parameters.PO4_norm[H02] = parameters.PO4_norm_H02;
	 parameters.PO4_norm[H03] = parameters.PO4_norm_H03;
	 parameters.PO4_norm[H04] = parameters.PO4_norm_H04;
	 parameters.PO4_norm[H05] = parameters.PO4_norm_H05;
	 parameters.PO4_norm[H06] = parameters.PO4_norm_H06;
	 parameters.PO4_norm[H07] = parameters.PO4_norm_H07;
	 parameters.PO4_norm[H08] = parameters.PO4_norm_H08;
	 parameters.PO4_norm[H09] = parameters.PO4_norm_H09;
	 parameters.PO4_norm[H10] = parameters.PO4_norm_H10;
	 parameters.PO4_norm[H11] = parameters.PO4_norm_H11;
	 parameters.PO4_norm[H12] = parameters.PO4_norm_H12;
	 parameters.PO4_norm[H13] = parameters.PO4_norm_H13;
	 parameters.PO4_norm[H14] = parameters.PO4_norm_H14;
	 parameters.PO4_norm[H15] = parameters.PO4_norm_H15;
	 parameters.PO4_norm[H16] = parameters.PO4_norm_H16;
	 parameters.PO4_norm[H17] = parameters.PO4_norm_H17;
	 parameters.PO4_norm[H18] = parameters.PO4_norm_H18;
	 parameters.PO4_norm[H19] = parameters.PO4_norm_H19;
	 parameters.PO4_norm[H20] = parameters.PO4_norm_H20;
	 parameters.PO4_norm[H21] = parameters.PO4_norm_H21;
	 parameters.PO4_norm[H22] = parameters.PO4_norm_H22;
	 parameters.PO4_norm[H23] = parameters.PO4_norm_H23;
	 
	 parameters.TSS_norm[H00] = parameters.TSS_norm_H00;
	 parameters.TSS_norm[H01] = parameters.TSS_norm_H01;
	 parameters.TSS_norm[H02] = parameters.TSS_norm_H02;
	 parameters.TSS_norm[H03] = parameters.TSS_norm_H03;
	 parameters.TSS_norm[H04] = parameters.TSS_norm_H04;
	 parameters.TSS_norm[H05] = parameters.TSS_norm_H05;
	 parameters.TSS_norm[H06] = parameters.TSS_norm_H06;
	 parameters.TSS_norm[H07] = parameters.TSS_norm_H07;
	 parameters.TSS_norm[H08] = parameters.TSS_norm_H08;
	 parameters.TSS_norm[H09] = parameters.TSS_norm_H09;
	 parameters.TSS_norm[H10] = parameters.TSS_norm_H10;
	 parameters.TSS_norm[H11] = parameters.TSS_norm_H11;
	 parameters.TSS_norm[H12] = parameters.TSS_norm_H12;
	 parameters.TSS_norm[H13] = parameters.TSS_norm_H13;
	 parameters.TSS_norm[H14] = parameters.TSS_norm_H14;
	 parameters.TSS_norm[H15] = parameters.TSS_norm_H15;
	 parameters.TSS_norm[H16] = parameters.TSS_norm_H16;
	 parameters.TSS_norm[H17] = parameters.TSS_norm_H17;
	 parameters.TSS_norm[H18] = parameters.TSS_norm_H18;
	 parameters.TSS_norm[H19] = parameters.TSS_norm_H19;
	 parameters.TSS_norm[H20] = parameters.TSS_norm_H20;
	 parameters.TSS_norm[H21] = parameters.TSS_norm_H21;
	 parameters.TSS_norm[H22] = parameters.TSS_norm_H22;
	 parameters.TSS_norm[H23] = parameters.TSS_norm_H23;
  };

  equations <-
  {
   state.Q_in = interface.Inflow[H2O_sew] / 1000000;
   DERIV(state.Q_integral,[independent.t]) = state.Q_in;
	 state.Q_DWF_UB = parameters.Q_95_av * parameters.Q_95_norm[state.Timestep];
	 state.Qsw = IF (state.Q_in < state.Q_DWF_UB)
	 						THEN 0
	 						ELSE state.Q_in - state.Q_DWF_UB;
	 state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.Timestep = floor(state.Daytime) + 1;
	 DERIV(state.Q_mean,[independent.t]) = (state.Q_in - state.Q_mean) / parameters.T_Average;
	 
	  
	 state.event = IF (state.Q_in < state.Q_DWF_UB)
	 							THEN 0
	 							ELSE IF (interface.FD > parameters.FD_event)
	 							 		THEN 3
	 									 ELSE IF ((state.Qsw > parameters.Qsw_event9) && (state.Q_mean > previous(state.Q_mean)))
	 												THEN 9
	 									 		 ELSE 0;
	 
	 state.event8_h = IF ((state.Qsw > parameters.Qsw_event8) && (state.event < 3) && (state.proc4_NH4 > 0.6))
	 								 THEN 1
	 								 ELSE 0;
	 state.event8 = IF (((state.event8_h == 1) || ((independent.t - state.t_end_event8_h) < 0.25)) && (state.event < 3) && (state.t_event39 > 0.25))
	 							 THEN 1
	 							 ELSE 0;
	 state.t_start_event8 = IF ((previous(state.event8) == 0) && (state.event8 == 1))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_start_event8);
	 state.t_end_event8_h = IF ((previous(state.event8_h) == 1) && (state.event8_h == 0))
	 										   THEN independent.t
				   				 		  ELSE previous(state.t_end_event8_h);
	 
	  
	 state.proc1_NH4 = parameters.NH4_av * parameters.NH4_norm[state.Timestep];
   
   state.proc2_NH4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_NH4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_NH4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_NH4) == 1) && (state.proc4_NH4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_NH4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_NH4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_NH4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_NH4)
	 																   THEN previous(state.proc4_NH4) + parameters.proc4_slope1_NH4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_NH4) + parameters.proc4_slope2_NH4 * (independent.t - previous(independent.t));
	 
	 state.proc4_NH4 = IF (state.proc4_NH4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_NH4_h;
	 
	 state.proc5_NH4 = 1 + state.proc5_1_NH4 + state.proc5_2_NH4;
	 state.proc5_1_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_NH4 / 2))
	 												 THEN previous(state.proc5_1_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_NH4)
	 															THEN previous(state.proc5_1_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_NH4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_NH4 / 2))
	 												 		 THEN previous(state.proc5_2_NH4) - parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_NH4)
	 																	 THEN previous(state.proc5_2_NH4) + parameters.proc5_slope_NH4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_NH4) && (previous(state.proc5_2_NH4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.NH4 = state.proc1_NH4 * state.proc2_NH4 * state.proc3_NH4 * state.proc4_NH4 * state.proc5_NH4;
	 
	  
	 state.proc1_CODs = parameters.CODs_av * parameters.CODs_norm[state.Timestep];
   
   state.proc2_CODs = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_CODs = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_CODs * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_CODs) == 1) && (state.proc4_CODs < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_CODs_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_CODs)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_CODs)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_CODs)
	 																   THEN previous(state.proc4_CODs) + parameters.proc4_slope1_CODs * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_CODs) + parameters.proc4_slope2_CODs * (independent.t - previous(independent.t));
	 
	 state.proc4_CODs = IF (state.proc4_CODs_h > 1)
	 									THEN 1
	 									ELSE state.proc4_CODs_h;
	 
	 state.proc5_CODs = 1 + state.proc5_1_CODs + state.proc5_2_CODs;
	 state.proc5_1_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_CODs / 2))
	 												 THEN previous(state.proc5_1_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_CODs)
	 															THEN previous(state.proc5_1_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_CODs = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_CODs / 2))
	 												 		 THEN previous(state.proc5_2_CODs) - parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_CODs)
	 																	 THEN previous(state.proc5_2_CODs) + parameters.proc5_slope_CODs * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_CODs) && (previous(state.proc5_2_CODs) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.CODs = state.proc1_CODs * state.proc2_CODs * state.proc3_CODs * state.proc4_CODs * state.proc5_CODs;
	 
	  
	 state.proc1_PO4 = parameters.PO4_av * parameters.PO4_norm[state.Timestep];
   
   state.proc2_PO4 = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_PO4 = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_PO4 * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.t_proc4 = independent.t - previous(state.t_start_proc4);
	 state.t_start_proc4 = IF ((previous(state.proc4_PO4) == 1) && (state.proc4_PO4 < 1))
	 										  	  THEN independent.t
				   				 		 		ELSE previous(state.t_start_proc4);
	 
	 state.proc4_PO4_h = IF ((state.event == 3) || (state.event == 9))
	 									  THEN 1
	 									  ELSE IF (previous(state.event) == 3)
	 											   THEN previous(state.proc2_PO4)
	 											   ELSE IF (previous(state.event) == 9)
	 											 		   THEN previous(state.proc3_PO4)
	 											 		   ELSE IF (state.t_proc4 < parameters.window_proc4_PO4)
	 																   THEN previous(state.proc4_PO4) + parameters.proc4_slope1_PO4 * (independent.t - previous(independent.t))
	 																   ELSE previous(state.proc4_PO4) + parameters.proc4_slope2_PO4 * (independent.t - previous(independent.t));
	 
	 state.proc4_PO4 = IF (state.proc4_PO4_h > 1)
	 									THEN 1
	 									ELSE state.proc4_PO4_h;
	 
	 state.proc5_PO4 = 1 + state.proc5_1_PO4 + state.proc5_2_PO4;
	 state.proc5_1_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF ((independent.t - state.t_start_proc5_1) < (parameters.window_proc5_PO4 / 2))
	 												 THEN previous(state.proc5_1_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 ELSE IF ((independent.t - state.t_start_proc5_1) < parameters.window_proc5_PO4)
	 															THEN previous(state.proc5_1_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 															ELSE 0;
	 
	 state.proc5_2_PO4 = IF (state.event8 == 0)
	 									  THEN 0
	 									  ELSE IF (state.t_start_proc5_2 <= state.t_start_proc5_1)
	 												 THEN 0
	 												 ELSE IF ((independent.t - state.t_start_proc5_2) < (parameters.window_proc5_PO4 / 2))
	 												 		 THEN previous(state.proc5_2_PO4) - parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 												 		 ELSE IF ((independent.t - state.t_start_proc5_2) < parameters.window_proc5_PO4)
	 																	 THEN previous(state.proc5_2_PO4) + parameters.proc5_slope_PO4 * (independent.t - previous(independent.t))
	 																	 ELSE 0;
   				
   state.t_start_proc5_1 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && (previous(state.t_start_proc5_2) == state.t_start_proc5_2))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_1);
	 
	 state.t_start_proc5_2 = IF ((previous(state.event8) == 0) && (state.event8 == 1) && ((independent.t - previous(state.t_start_proc5_1)) < parameters.window_proc5_PO4) && (previous(state.proc5_2_PO4) == 0))
	 										 	 THEN independent.t
				   				 			 ELSE previous(state.t_start_proc5_2);
	 
	 state.PO4 = state.proc1_PO4 * state.proc2_PO4 * state.proc3_PO4 * state.proc4_PO4 * state.proc5_PO4;
	 
	  
	 state.proc1_COD = parameters.COD_av * parameters.COD_norm[state.Timestep];
   
   state.proc2_COD = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_COD = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_COD * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_COD = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_COD)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_COD)
	 											 		 ELSE IF (previous(state.proc4_COD) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_COD)
	 																 		 THEN previous(state.proc4_COD) + parameters.proc4_slope1_COD * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_COD) + parameters.proc4_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_COD)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_COD)
	 														  THEN parameters.peak_COD_low
	 														  ELSE parameters.peak_COD_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_COD_h) - parameters.proc6_slope1_COD * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_COD_h) - parameters.proc6_slope2_COD * (independent.t - previous(independent.t));
	 
	 state.proc6_COD = IF (state.proc6_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc6_COD_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_COD_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_COD_h) + parameters.proc7_slope1_COD * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_COD_h) - parameters.proc7_slope2_COD * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_COD = IF (state.proc7_COD_h < 0)
	 									THEN 0
	 									ELSE state.proc7_COD_h;
	 
	 state.COD = state.proc1_COD * state.proc2_COD * state.proc3_COD * state.proc4_COD + state.proc6_COD + state.proc7_COD;
	 
	  
	 state.proc1_TSS = parameters.TSS_av * parameters.TSS_norm[state.Timestep];
   
   state.proc2_TSS = IF (state.event == 3)
   			    	 		 THEN (parameters.alpha_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;	
	 
	 state.proc3_TSS = IF (state.event == 9)
   			    	 		 THEN (parameters.beta_TSS * (state.Q_DWF_UB / state.Q_in - 1) + 1)
							  		 ELSE 1;		
   
	 state.proc4_TSS = IF ((state.event == 3) || (state.event == 9))
	 									THEN 1
	 									ELSE IF (previous(state.event) == 3)
	 											 THEN previous(state.proc2_TSS)
	 											 ELSE IF (previous(state.event) == 9)
	 											 		 THEN previous(state.proc3_TSS)
	 											 		 ELSE IF (previous(state.proc4_TSS) >= 1)
	 																 THEN 1
	 																 ELSE IF (state.t_proc4 < parameters.window_proc4_TSS)
	 																 		 THEN previous(state.proc4_TSS) + parameters.proc4_slope1_TSS * (independent.t - previous(independent.t))
	 																 		 ELSE previous(state.proc4_TSS) + parameters.proc4_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS_h = IF (((state.event == 3) || (state.event == 9)) && (previous(state.event) < 3))
	 									  THEN IF (state.t_event39 < parameters.proc6_t1_TSS)
	 											   THEN 0
	 											   ELSE IF (state.t_event39 < parameters.proc6_t2_TSS)
	 														  THEN parameters.peak_TSS_low
	 														  ELSE parameters.peak_TSS_high
	 									  ELSE IF (((state.event == 3) || (state.event == 9)) && (state.Q_in > parameters.Q_proc6))
	 											   THEN previous(state.proc6_TSS_h) - parameters.proc6_slope1_TSS * (independent.t - previous(independent.t))
	 											   ELSE previous(state.proc6_TSS_h) - parameters.proc6_slope2_TSS * (independent.t - previous(independent.t));
	 
	 state.proc6_TSS = IF (state.proc6_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc6_TSS_h;
	 
	 state.t_end_event39 = IF (((previous(state.event) == 3) || (previous(state.event) == 9)) && (state.event < 3))
	 											THEN independent.t
				   				 		 ELSE previous(state.t_end_event39);
	 state.t_event39 = independent.t - state.t_end_event39;
	 
	 state.proc7_TSS_h = IF (((state.event == 3) || (state.event == 9)) || (state.t_event39 < 1.5))
	 										THEN 0
	 										ELSE IF (state.event8 == 1)
	 												 THEN IF ((independent.t - state.t_start_event8) < 0.1333)
	 															THEN previous(state.proc7_TSS_h) + parameters.proc7_slope1_TSS * (independent.t - previous(independent.t))
	 															ELSE previous(state.proc7_TSS_h) - parameters.proc7_slope2_TSS * (independent.t - previous(independent.t))
	 												 ELSE 0;
	 
	 state.proc7_TSS = IF (state.proc7_TSS_h < 0)
	 									THEN 0
	 									ELSE state.proc7_TSS_h;
	 
	 state.TSS = state.proc1_TSS * state.proc2_TSS * state.proc3_TSS * state.proc4_TSS + state.proc6_TSS + state.proc7_TSS;

   interface.Outflow[H2O_sew] = -interface.Inflow[H2O_sew];
   interface.Outflow[COD_part] = -(state.COD - state.CODs) * state.Q_in;
   interface.Outflow[COD_sol] = -state.CODs * state.Q_in;
   interface.Outflow[X_TSS_sew] = -state.TSS * state.Q_in;
   interface.Outflow[NH4_sew] = -state.NH4 * state.Q_in;
   interface.Outflow[PO4_sew] = -state.PO4 * state.Q_in;
   
 };

:};

CLASS SewCSO_to_DuflowSimple
 (* icon = "CSO" *)
 "a Kosim to Duflow Simple influent transformer for CSOs with fixed concentration"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InSewTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
    
    
   OBJ O2_CSO "O2 concentration in CSO" : Concentration := {: value <- 2 ; group <- "CSO concentrations" :};
   OBJ BOD_CSO "BOD concentration in CSO" : Concentration := {: value <- 47.1 ; group <- "CSO concentrations" :};
   OBJ COD_CSO "COD concentration in CSO" : Concentration := {: value <- 161.7 ; group <- "CSO concentrations" :};
   OBJ NH4_CSO "NH4 concentration in CSO" : Concentration := {: value <- 3.2 ; group <- "CSO concentrations" :};
    
   OBJ fBOD1_BOD "Fraction of BODfast in BOD" : Fraction := {: value <- 0.85 ; group <- "Fractionation" :};
   OBJ fBOD2_CODmBOD "Fraction of BODslow in COD minus BOD" : Fraction := {: value <- 0.4 ; group <- "Fractionation" :};
   OBJ fBOD1p_BODf "Fraction of BOD1p in BODfast" : Fraction := {: value <- 0.3 ; group <- "Fractionation" :};
   OBJ fBOD2p_BODs "Fraction of BOD2p in BODslow" : Fraction := {: value <- 0.5 ; group <- "Fractionation" :};
   OBJ settling "Settling efficiency for BOD2" : Fraction := {: value <- 0 ; group <- "Fractionation" :};
   OBJ yesno "0 for no CSO effluent, 1 for 100 percent CSO effluent" : Fraction := {: value <- 1 :};
   
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   
  OBJ Q_in "Q in" : FlowRate;
  OBJ Q_in_int "Integral of Q_in" : Volume;
   
  };
  
  initial <-
  {
   
  };

  equations <-
  {
  state.Q_in = interface.Inflow[H2O_sew] / 1000000;
  DERIV(state.Q_in_int,[independent.t])= state.Q_in;
   
   

    
   interface.Outflow[rH2O]   = - parameters.yesno * interface.Inflow[H2O_sew] ;
   interface.Outflow[rO2]   = - parameters.yesno * parameters.O2_CSO * state.Q_in ;
   interface.Outflow[rNH4]   = - parameters.yesno * parameters.NH4_CSO * state.Q_in ;
   interface.Outflow[rBOD1]   = - parameters.yesno * parameters.fBOD1_BOD * (1-parameters.fBOD1p_BODf) * parameters.BOD_CSO * state.Q_in ;
   interface.Outflow[rBOD1p]   = - parameters.yesno * parameters.fBOD1_BOD * parameters.fBOD1p_BODf * parameters.BOD_CSO * state.Q_in * (1 - parameters.settling);
   interface.Outflow[rBOD2]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * (1-parameters.fBOD2p_BODs) * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in ;  
   interface.Outflow[rBOD2p]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * parameters.fBOD2p_BODs * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in * (1 - parameters.settling) ; 
 };

:};

CLASS SewCSO_Q_to_DuflowSimple
 (* icon = "CSO" *)
 "a flow rate to Duflow Simple influent transformer for CSOs with fixed concentration"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      FlowRate  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
    
    
   OBJ O2_CSO "O2 concentration in CSO" : Concentration := {: value <- 2 ; group <- "CSO concentrations" :};
   OBJ BOD_CSO "BOD concentration in CSO" : Concentration := {: value <- 47.1 ; group <- "CSO concentrations" :};
   OBJ COD_CSO "COD concentration in CSO" : Concentration := {: value <- 161.7 ; group <- "CSO concentrations" :};
   OBJ NH4_CSO "NH4 concentration in CSO" : Concentration := {: value <- 3.2 ; group <- "CSO concentrations" :};
    
   OBJ fBOD1_BOD "Fraction of BODfast in BOD" : Fraction := {: value <- 0.85 ; group <- "Fractionation" :};
   OBJ fBOD2_CODmBOD "Fraction of BODslow in COD minus BOD" : Fraction := {: value <- 0.4 ; group <- "Fractionation" :};
   OBJ fBOD1p_BODf "Fraction of BOD1p in BODfast" : Fraction := {: value <- 0.3 ; group <- "Fractionation" :};
   OBJ fBOD2p_BODs "Fraction of BOD2p in BODslow" : Fraction := {: value <- 0.5 ; group <- "Fractionation" :};
   OBJ settling "Settling efficiency for BOD2" : Fraction := {: value <- 0 ; group <- "Fractionation" :};
   OBJ yesno "0 for no CSO effluent, 1 for 100 percent CSO effluent" : Fraction := {: value <- 1 :};
   
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   
  OBJ Q_in "Q in" : FlowRate;
  OBJ Q_in_int "Integral of Q_in" : Volume;
   
  };
  
  initial <-
  {
   
  };

  equations <-
  {
  state.Q_in = interface.Inflow;
  DERIV(state.Q_in_int,[independent.t])= state.Q_in;
   
   

    
   interface.Outflow[rH2O]   = - parameters.yesno * interface.Inflow * 1000000 ;
   interface.Outflow[rO2]   = - parameters.yesno * parameters.O2_CSO * state.Q_in ;
   interface.Outflow[rNH4]   = - parameters.yesno * parameters.NH4_CSO * state.Q_in ;
   interface.Outflow[rBOD1]   = - parameters.yesno * parameters.fBOD1_BOD * (1-parameters.fBOD1p_BODf) * parameters.BOD_CSO * state.Q_in ;
   interface.Outflow[rBOD1p]   = - parameters.yesno * parameters.fBOD1_BOD * parameters.fBOD1p_BODf * parameters.BOD_CSO * state.Q_in * (1 - parameters.settling);
   interface.Outflow[rBOD2]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * (1-parameters.fBOD2p_BODs) * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in ;  
   interface.Outflow[rBOD2p]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * parameters.fBOD2p_BODs * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in * (1 - parameters.settling) ; 
 };

:};

CLASS Eindhoven_fract
 (* icon = "Connector" *)
 "influent transformer"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "Transforms a NH4-COD influent to an influent type for ASM2(d)(Temp)";

  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InSewTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
 
 
 
   OBJ S_O_In "Constant concentration of dissolved oxygen in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ S_ALK_In "Constant concentration of alkalinity in the influent": Concentration := {: value <- 30 ; group <- "Influent characterization" :};
   OBJ S_NO_In "Constant concentration of nitrate in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ S_N2_In "Constant concentration of dinitrogen in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ S_Al_In "Constant concentration of soluble aluminium salts in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_PP_In "Constant concentration of poly-phosphate in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_AUT_In "Constant concentration of autotrophic biomass in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_H_In "Constant concentration of heterotrophic biomass in the influent": Concentration := {: value <- 5 ; group <- "Influent characterization" :};
   OBJ X_PAO_In "Constant concentration of phosphate accumulating organisms in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_PHA_In "Constant concentration of cell internal organic storage products of the PAO in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_MEOH_In "Constant concentration of metal-hydroxides in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_MEP_In "Constant concentration of metal-phosphates in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};
   OBJ X_I_i_In "Constant concentration of Aluminium precipitates in the influent": Concentration := {: value <- 0 ; group <- "Influent characterization" :};

 
   OBJ f_S_F_d "Fraction of fermentable readily biodegradable products (S_F) in the soluble COD (dry weather)": Fraction := {: value <- 0.375 ; group <- "Conversion factors" :};
   OBJ f_S_A_d "Fraction of fermentation procucts (S_A) in the soluble COD (dry weather)": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
   OBJ f_X_S_d "Fraction slowly biodegradable substrate (X_S) in the particulate COD (dry weather)" : Fraction := {: value <- 0.69 ; group <- "Conversion factors" :};
	 OBJ f_S_F_w "Fraction of fermentable readily biodegradable products (S_F) in the soluble COD (wet weather)": Fraction := {: value <- 0.375 ; group <- "Conversion factors" :};
   OBJ f_S_A_w "Fraction of fermentation procucts (S_A) in the soluble COD (wet weather)": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
   OBJ f_X_S_w "Fraction slowly biodegradable substrate (X_S) in the particulate COD (wet weather)" : Fraction := {: value <- 0.69 ; group <- "Conversion factors" :};
	 OBJ Q_in_w "Flow rate above which wet wether fractions are assumed" : FlowRate := {: value <- 20000 ; group <- "Conversion factors" :};
};

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate; 
	 OBJ X_COD "Particulate COD" : MassFlux := {: group <- "Influent characterization" :};
   OBJ S_COD "Soluble COD" : MassFlux := {: group <- "Influent characterization" :};
   OBJ X_I_help (* hidden = "1" *) "" : MassFlux := {: group <- "Influent characterization" :};
   OBJ fX_I  "fraction of Xi" : Real := {: group <- "Influent characterization" :};
   OBJ fX_s  "fraction of Xs" : Real := {: group <- "Influent characterization" :};
   OBJ fS_s  "fraction of Ss" : Real := {: group <- "Influent characterization" :};
   OBJ fS_i  "fraction of Si" : Real := {: group <- "Influent characterization" :};
  };

  equations <-
  {
   state.Q_in = interface.Inflow[H2O_sew] / 1000000;
	 state.X_COD = interface.Inflow[COD_part];
   state.S_COD = interface.Inflow[COD_sol];
   state.fX_s = IF (state.Q_in < parameters.Q_in_w)
								THEN state.X_COD * parameters.f_X_S_d/(state.X_COD + state.S_COD)
								ELSE state.X_COD * parameters.f_X_S_w/(state.X_COD + state.S_COD);
   state.fS_s = IF (state.Q_in < parameters.Q_in_w)
								THEN (state.S_COD * parameters.f_S_F_d + state.S_COD * parameters.f_S_A_d)/(state.X_COD + state.S_COD)
								ELSE (state.S_COD * parameters.f_S_F_w + state.S_COD * parameters.f_S_A_w)/(state.X_COD + state.S_COD);
   state.fS_i = IF (state.Q_in < parameters.Q_in_w)
								THEN state.S_COD * (1 - parameters.f_S_F_d - parameters.f_S_A_d)/(state.X_COD + state.S_COD)
								ELSE state.S_COD * (1 - parameters.f_S_F_w - parameters.f_S_A_w)/(state.X_COD + state.S_COD);
   state.fX_I = (state.X_COD  
				      + interface.Outflow[X_H]
				      + interface.Outflow[X_AUT]
				      + interface.Outflow[X_PAO] 
				      + interface.Outflow[X_PHA]
				      + interface.Outflow[X_S])/(state.X_COD + state.S_COD);

 
   interface.Outflow[IndexOfSolvent] = - interface.Inflow[H2O_sew] ;
 
   interface.Outflow[S_O]   = - parameters.S_O_In * state.Q_in;
   interface.Outflow[S_ALK] = - parameters.S_ALK_In * state.Q_in;
 
   interface.Outflow[S_Al]  = - parameters.S_Al_In * state.Q_in;
 
   interface.Outflow[S_NO]  = - parameters.S_NO_In * state.Q_in;
   interface.Outflow[S_N2]  = - parameters.S_N2_In * state.Q_in;
   interface.Outflow[S_NH]  = - interface.Inflow[NH4_sew] ;
 
   interface.Outflow[S_PO]  = - interface.Inflow[PO4_sew] ;
   interface.Outflow[X_PP]  = - parameters.X_PP_In * state.Q_in;
 
   interface.Outflow[S_F]   = IF (state.Q_in < parameters.Q_in_w)
															THEN - state.S_COD * parameters.f_S_F_d
															ELSE - state.S_COD * parameters.f_S_F_w;
   interface.Outflow[S_A]   = IF (state.Q_in < parameters.Q_in_w)
															THEN - state.S_COD * parameters.f_S_A_d
															ELSE - state.S_COD * parameters.f_S_A_w;
   interface.Outflow[S_I]   = IF (state.Q_in < parameters.Q_in_w)
															THEN - state.S_COD * (1 - parameters.f_S_F_d - parameters.f_S_A_d)
															ELSE - state.S_COD * (1 - parameters.f_S_F_w - parameters.f_S_A_w);

   interface.Outflow[X_S]   = IF (state.Q_in < parameters.Q_in_w)
															THEN - state.X_COD * parameters.f_X_S_d
															ELSE - state.X_COD * parameters.f_X_S_w;
   interface.Outflow[X_H]   = - parameters.X_H_In * state.Q_in;
   interface.Outflow[X_AUT] = - parameters.X_AUT_In * state.Q_in;
   interface.Outflow[X_PAO] = - parameters.X_PAO_In * state.Q_in;
   interface.Outflow[X_PHA] = - parameters.X_PHA_In * state.Q_in;
   
   state.X_I_help = - (state.X_COD  
				      + interface.Outflow[X_H]
				      + interface.Outflow[X_AUT]
				      + interface.Outflow[X_PAO] 
				      + interface.Outflow[X_PHA]
				      + interface.Outflow[X_S]);
					  
   interface.Outflow[X_I] = IF (state.X_I_help > 0)
   						    				 THEN 0
														ELSE state.X_I_help;

   interface.Outflow[X_MEOH]= - parameters.X_MEOH_In * state.Q_in;
   interface.Outflow[X_MEP] = - parameters.X_MEP_In * state.Q_in;
   interface.Outflow[X_I_i] = - parameters.X_I_i_In * state.Q_in; 
 
   interface.Outflow[IndexOfTSSComponent] = - interface.Inflow[X_TSS_sew];
  };
:};

CLASS ASM2d_to_DuflowSimple
 (* icon = "Connector" *)
 "an ASM2d to Duflow Simple influent transformer"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InWWTPTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
   OBJ fBOD2_BOD20p "Fraction of BOD2 in BOD20p particulate" : Fraction := {: value <- 0.8 ; group <- "Fractionation" :};   
   OBJ fBOD1p_BODf "Fraction of BOD1p in BODfast" : Fraction := {: value <- 0.1 ; group <- "Fractionation" :};
   OBJ fBOD2p_BODs "Fraction of BOD2p in BODslow" : Fraction := {: value <- 0.3 ; group <- "Fractionation" :};
   OBJ yesno "0 for no WWTP effluent, 1 for 100 percent WWTP effluent" : Fraction := {: value <- 1 :};
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   OBJ Q_in "Q in" : FlowRate;
  };

  equations <-
  {
  state.Q_in = interface.Inflow[H2O] / 1000000;

 
   interface.Outflow[rH2O]   = - parameters.yesno * interface.Inflow[H2O] ;
   interface.Outflow[rO2]   = - parameters.yesno * interface.Inflow[S_O] ;
   interface.Outflow[rNH4]   = - parameters.yesno * interface.Inflow[S_NH] ;
   interface.Outflow[rBOD1]   = - parameters.yesno * (1-parameters.fBOD1p_BODf) * (interface.Inflow[S_F] + interface.Inflow[S_A]) ;
   interface.Outflow[rBOD1p]   = - parameters.yesno * parameters.fBOD1p_BODf * (interface.Inflow[S_F] + interface.Inflow[S_A]) ;
   interface.Outflow[rBOD2] = - parameters.yesno * parameters.fBOD2_BOD20p * (1-parameters.fBOD2p_BODs) * (interface.Inflow[X_S] + interface.Inflow[X_H]
   							  + interface.Inflow[X_AUT] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA]) ; 
   interface.Outflow[rBOD2p] = - parameters.yesno * parameters.fBOD2_BOD20p * parameters.fBOD2p_BODs * (interface.Inflow[X_S] + interface.Inflow[X_H]
   							  + interface.Inflow[X_AUT] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA]) ;  
    
 };

:};


CLASS SewCSO_to_DuflowSimple_InputPollutant
 (* icon = "CSO" *)
 "a Kosim to Duflow Simple influent transformer for CSOs with fixed concentration"
 SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "";
  
  interface <-
  {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
      InSewTerminal  := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
    
    
   OBJ O2_CSO "O2 concentration in CSO" : Concentration := {: value <- 2 ; group <- "CSO concentrations" :};
   OBJ BOD_CSO "BOD concentration in CSO" : Concentration := {: value <- 47.1 ; group <- "CSO concentrations" :};
   OBJ COD_CSO "COD concentration in CSO" : Concentration := {: value <- 161.7 ; group <- "CSO concentrations" :};
   OBJ NH4_CSO "NH4 concentration in CSO" : Concentration := {: value <- 3.2 ; group <- "CSO concentrations" :};
    
   OBJ fBOD1_BOD "Fraction of BODfast in BOD" : Fraction := {: value <- 0.85 ; group <- "Fractionation" :};
   OBJ fBOD2_CODmBOD "Fraction of BODslow in COD minus BOD" : Fraction := {: value <- 0.4 ; group <- "Fractionation" :};
   OBJ fBOD1p_BODf "Fraction of BOD1p in BODfast" : Fraction := {: value <- 0.3 ; group <- "Fractionation" :};
   OBJ fBOD2p_BODs "Fraction of BOD2p in BODslow" : Fraction := {: value <- 0.5 ; group <- "Fractionation" :};
   OBJ settling "Settling efficiency for BOD2" : Fraction := {: value <- 0 ; group <- "Fractionation" :};
   OBJ yesno "0 for no CSO effluent, 1 for 100 percent CSO effluent" : Fraction := {: value <- 1 :};
   
  };

  independent <- 
  {
   OBJ t "Time" : Time := {: group <- "Time" :};
  };

  state <-
  {
   
  OBJ Q_in "Q in" : FlowRate;
  OBJ Q_in_int "Integral of Q_in" : Volume;
   
  };
  
  initial <-
  {
   
  };

  equations <-
  {
  state.Q_in = interface.Inflow[H2O_sew] / 1000000;
  DERIV(state.Q_in_int,[independent.t])= state.Q_in;
   
   

    
   interface.Outflow[rH2O]   = - parameters.yesno * interface.Inflow[H2O_sew] ;
   interface.Outflow[rO2]   = - parameters.yesno * parameters.O2_CSO * state.Q_in ;
   interface.Outflow[rNH4]   = - parameters.yesno * parameters.NH4_CSO * state.Q_in ;
   interface.Outflow[rBOD1]   = - parameters.yesno * parameters.fBOD1_BOD * (1-parameters.fBOD1p_BODf) * parameters.BOD_CSO * state.Q_in ;
   interface.Outflow[rBOD1p]   = - parameters.yesno * parameters.fBOD1_BOD * parameters.fBOD1p_BODf * parameters.BOD_CSO * state.Q_in * (1 - parameters.settling);
   interface.Outflow[rBOD2]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * (1-parameters.fBOD2p_BODs) * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in ;  
   interface.Outflow[rBOD2p]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * parameters.fBOD2p_BODs * parameters.BOD_CSO + parameters.fBOD2_CODmBOD * (parameters.COD_CSO - parameters.BOD_CSO)) 
   							  	* state.Q_in * (1 - parameters.settling) ; 
 };

:};
# 15 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.controllers.msl" 1
    CLASS min_contr
   (* icon = "Controller" *)
   "Minimum of 0/1 for ES to RBT"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ contr_1 (* terminal = "in_1" *) "Control action side 1" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ contr_2 (* terminal = "in_1" *) "Control action side 2" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Minimum" : Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     equations <-
     {
 
     interface.u = IF (interface.contr_1 < interface.contr_2)
 				   			 THEN interface.contr_1
 				   			 ELSE interface.contr_2;
     };
  :};

 CLASS raintank_Eindhoven
   (* icon = "Controller" *)
   "Ratio controller"
 
  
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ y_M1 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ y_M2 (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ u (* terminal = "out_1" *) "Controlled variable" :
                Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
 
 	  OBJ Q_empty "Outflow when emptying" :
          FlowRate := {: value <- 9600 ; group <- "Operational" :};
	   OBJ max_bio "Sends to bio when Q_bio < max_bio" :
          FlowRate := {: value <- 9600 ; group <- "Operational" :};
     };
 
     equations <-
     {
       interface.u = IF (interface.y_M1 > 0)
 				  					THEN 0
 				   				 ELSE IF (interface.y_M2 >= (parameters.max_bio - parameters.Q_empty))
				   		  				 THEN 0
						     			   ELSE parameters.Q_empty;
     };
  :};

CLASS BT_in_Eindhoven
   (* icon = "Controller" *)
   "Controller"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ y_M (* terminal = "in_1" *) "Sensor measured output" :
                Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ u (* terminal = "out_1" *) "Controlled variable" :
                Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
	     OBJ FD_lim "If FD > FD_lim then bypass" :
          Real := {: value <- 0.99 ; group <- "Operational" :};
     };
 
     equations <-
     {
      interface.u = IF (interface.y_M > parameters.FD_lim)
 				   THEN 1
 				   ELSE 0;
     };
  :};

  CLASS max_contr
   (* icon = "Controller" *)
   "Maximum of 0/1 for ES to RBT"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ contr_1 (* terminal = "in_1" *) "Control action side 1" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ contr_2 (* terminal = "in_1" *) "Control action side 2" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Real" : Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     equations <-
     {
     interface.u = IF (interface.contr_1 > interface.contr_2)
 				   THEN interface.contr_1
 				   ELSE interface.contr_2;
     };
  :};

   CLASS pipe_pump_limiter
   (* icon = "Controller" *)
   "Controller to limit the pumping from pipe"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ Q_pump (* terminal = "out_1"; manip = "1" *) "Q pump high" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	    OBJ FD (* terminal = "in_1"; manip = "1" *) "Filling degree pipe" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
     };
 
     parameters <-
     {
	    OBJ active "Active = 1, not active = 0" : Real := {: group <- "Control" :};
	    OBJ FD_th_pipe "Filling degree thredshold at pipe for deactivation" : Real := {: value <- 0.8 ; group <- "Operational" :};
	    OBJ LimFlow "Limited flow at pipe" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	    OBJ DefFlow "Default flow at pipe" : FlowRate := {: value <- 0 ; group <- "Operational" :};
     };
 
     equations <-
     {
      interface.Q_pump = IF ((parameters.active == 0) || (interface.FD > parameters.FD_th_pipe))
 				   	    			 THEN parameters.DefFlow
 				   	    			 ELSE parameters.LimFlow; 
	};
  :};

   CLASS pipe_retention
   (* icon = "Controller" *)
   "Controller to increase pipe retention to delay WWTP load"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ Q_WWTP (* terminal = "in_1" *) "Flow to WWTP" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ FD (* terminal = "in_1" *) "Filling degree pipe" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ FD_RBT (* terminal = "in_1" *) "Filling degree at RBT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ Q_pipe (* terminal = "out_1" *) "Flow from pipe" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	    OBJ bp2RBT (* terminal = "out_1" *) "Bypass to RBT, =1 yes, =0 no" : Fraction := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ LimFlow (* terminal = "in_2"; manip = "1" *) "Limited flow at pipe" : FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
		  OBJ DefFlow (* terminal = "in_2"; manip = "1" *) "Limited flow at pipe" : FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
     };
 
     parameters <-
     {
	    OBJ active "Active = 1, not active = 0" : Real := {: group <- "Control" :};
	    OBJ Q_th_WWTP "Threshold Q at WWTP" : FlowRate := {: value <- 360000 ; group <- "Operational" :};
	    OBJ FD_th_pipe "Filling degree thredshold at pipe for deactivation" : Real := {: value <- 0.8 ; group <- "Operational" :};
	    OBJ FD_th_RBT "Filling degree thredshold at RBT for deactivation" : Real := {: value <- 0.8 ; group <- "Operational" :};
	     
	     
	    OBJ Q_change_rate_pipe "Rate of change of flow rate for pipe" : FlowRateRate := {: value <- 3732480000 ; group <- "Operational" :};
	    OBJ Q_change_rate_bp "Rate of change of flow rate for bypass" : Real := {: value <- 3000 ; group <- "Operational" :};
     };
	 
	 independent <- 
   {
    OBJ t "Time" : Time := {: group <- "Time" :};
   };
	 
	  state <-
    {
     OBJ help_u (* hidden = "0" *) "Previous u help variable" : FlowRate := {: group <- "Operational" :};
	   OBJ help_u_h (* hidden = "0" *) "Previous u help variable" : FlowRate := {: group <- "Operational" :};
	   OBJ help_u1 (* hidden = "0" *) "Previous u help variable" : Real := {: group <- "Operational" :};
	   OBJ help_u1_h (* hidden = "0" *) "Previous u help variable" : Real := {: group <- "Operational" :};
	   OBJ TS (* hidden = "0" *) "Time step" : Time := {: group <- "Operational" :};
    };
	 
	 initial <-
   {
	   
   };
 
   equations <-
   {
	 state.TS = independent.t - previous(independent.t);
	 state.help_u = interface.Q_pipe;
   state.help_u_h = IF ((parameters.active == 0) || (interface.Q_WWTP < parameters.Q_th_WWTP))
                    THEN previous(state.help_u) + parameters.Q_change_rate_pipe * state.TS
                    ELSE IF (interface.FD < parameters.FD_th_pipe)
					 	  					THEN previous(state.help_u) - parameters.Q_change_rate_pipe * state.TS
					 	  					ELSE previous(state.help_u) + parameters.Q_change_rate_pipe * state.TS;
	 interface.Q_pipe = IF (state.help_u_h > interface.DefFlow)
				  						THEN interface.DefFlow
				  						ELSE IF (state.help_u_h < interface.LimFlow)
				  	   						THEN interface.LimFlow
					   							ELSE state.help_u_h;
							 
	 state.help_u1 = interface.bp2RBT;
	 state.help_u1_h = IF ((parameters.active == 0) || (interface.FD < parameters.FD_th_pipe))
	 				  				THEN previous(state.help_u1) - parameters.Q_change_rate_bp * state.TS
										 ELSE IF ((previous(interface.Q_pipe) < interface.Q_pipe) && (interface.FD_RBT < parameters.FD_th_RBT))
							 					 THEN previous(state.help_u1) + parameters.Q_change_rate_bp * state.TS
							 					 ELSE IF ((previous(state.help_u1) >= state.help_u1) && (interface.FD_RBT < parameters.FD_th_RBT))
							 	  						THEN previous(state.help_u1) + parameters.Q_change_rate_bp * state.TS
								  						 ELSE previous(state.help_u1) - parameters.Q_change_rate_bp * state.TS;
	interface.bp2RBT = IF (previous(state.help_u1_h) > 1)
				  					 THEN 1
				  					 ELSE IF (previous(state.help_u1_h) < 0)
				  	   					 THEN 0
					   						 ELSE previous(state.help_u1_h);
   };
  :};

   CLASS pump_limiter_offset
   (* icon = "Controller" *)
   "Controller to limit pumping, for backwater effect"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ Q_max (* terminal = "out_1"; manip = "1" *) "Max flow" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	    OBJ FDus (* terminal = "in_1" *) "Filling degree pipe upstream" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ FDds (* terminal = "in_1" *) "Filling degree pipe downstream" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
     };
 
     parameters <-
     {
	    OBJ active "Active = 1, not active = 0" : Real := {: group <- "Control" :};
	    OBJ FD_th_up "Filling degree thredshold at upstream pipe for activation" : Real := {: value <- 0.4 ; group <- "Operational" :};
	    OBJ FD_offset "Filling degree offset DS-US" : Real := {: value <- 0.2 ; group <- "Operational" :};
	    OBJ LimFlow "Limited flow at pipe" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	    OBJ DefFlow "Default flow at pipe" : FlowRate := {: value <- 0 ; group <- "Operational" :};
     };
 
     equations <-
     {
     interface.Q_max = IF ((parameters.active == 0) || (interface.FDds < parameters.FD_th_up) || ((interface.FDds - interface.FDus) < parameters.FD_offset))
 				   	   			THEN parameters.DefFlow
 				   	   			ELSE parameters.LimFlow; 
	};
  :};

   CLASS opening
   (* icon = "Controller" *)
   "Model for valve D in Eindhoven"
  
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ FD_ES (* terminal = "in_1" *) "Filling degree at ES" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ FD_RZ (* terminal = "in_1" *) "Filling degree at RZ" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_valve_ES (* terminal = "out_1" *) "Valve flow from ES" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ Q_valve_RZ (* terminal = "out_1" *) "Valve flow from RZ" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
 	   OBJ FD_th_ES "Filling degree thredshold for valve activation in ES" : Real := {: value <- 0.9 ; group <- "Operational" :};
	    OBJ FD_th_RZ "Filling degree thredshold for valve activation in RZ" : Real := {: value <- 0.9 ; group <- "Operational" :};
	    OBJ MaxFlow_D "Maximum flow at valve D" : FlowRate := {: value <- 120000 ; group <- "Operational" :};
     };
 
     state <-
      {
	     OBJ FD_ES_help (* hidden = "1" *) : Real;
	     OBJ FD_RZ_help (* hidden = "1" *) : Real;
	    };
 
     equations <-
     {
      state.FD_ES_help = IF (interface.FD_ES > 1)
	 				  					  THEN 1
					   						ELSE interface.FD_ES;
	 	 state.FD_RZ_help = IF (interface.FD_RZ > 1)
	 				   					 THEN 1
					    					 ELSE interface.FD_RZ;
      interface.Q_valve_ES = IF (state.FD_ES_help < parameters.FD_th_ES)
 				   		   			    THEN 0
 				   								 ELSE IF (state.FD_RZ_help < parameters.FD_th_RZ)
				   											 THEN parameters.MaxFlow_D * (state.FD_ES_help - parameters.FD_th_ES) / (1 - parameters.FD_th_ES)
																	ELSE IF (state.FD_ES_help < state.FD_RZ_help)
						 		 	  								 THEN 0
									  									 ELSE parameters.MaxFlow_D * (state.FD_ES_help - state.FD_RZ_help) / (1 - parameters.FD_th_ES);
	    interface.Q_valve_RZ = IF (state.FD_RZ_help < parameters.FD_th_RZ)
 				   		    				 THEN 0
 				  									ELSE IF (state.FD_ES_help < parameters.FD_th_ES)
				   				 							THEN parameters.MaxFlow_D * (state.FD_RZ_help - parameters.FD_th_RZ) / (1 - parameters.FD_th_RZ)
								 								 ELSE IF (state.FD_RZ_help < state.FD_ES_help)
						 		 	 					   THEN 0
									  						  ELSE parameters.MaxFlow_D * (state.FD_RZ_help - state.FD_ES_help) / (1 - parameters.FD_th_RZ);
     };
  :};

CLASS valve_C_Eindhoven
   (* icon = "Controller" *)
   "Valve C"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ Q_RZ (* terminal = "in_1" *) "Outflow at RZ" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ MaxFlow_def (* terminal = "in_2" *) "Default max flow at ES" : FlowRate := {: causality <- "CIN" ; group <- "Control action" :};
       OBJ u (* terminal = "out_1" *) "Controlled variable" : Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
	    OBJ MaxFlow_C "Maximum flow at valve C" : FlowRate := {: value <- 768000 ; group <- "Operational" :};
	     
      OBJ valve "Valve active = 1, not active = 0" : Real := {: group <- "Control" :};
     };
 
     equations <-
     {
      interface.u = IF (parameters.valve == 1)
 				  			   THEN parameters.MaxFlow_C - interface.Q_RZ
 				  				 ELSE interface.MaxFlow_def;
     };
  :};

CLASS RBT_spill_min_norc
   (* icon = "Controller" *)
   "Controller to minimize RBT spilling"
  
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ FD_RBT (* terminal = "in_1" *) "Filling degree at RBT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ FD_1 (* terminal = "in_1" *) "Filling degree at pipe 1" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_1 (* terminal = "out_1" *) "Flow at pipe 1" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_2 (* terminal = "in_1" *) "Filling degree at pipe 2" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_2 (* terminal = "out_1" *) "Flow at pipe 2" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_3 (* terminal = "in_1" *) "Filling degree at pipe 3" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_3 (* terminal = "out_1" *) "Flow at pipe 3" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_4 (* terminal = "in_1" *) "Filling degree at pipe 4" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_4 (* terminal = "out_1" *) "Flow at pipe 4" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
			 OBJ DefFlow_2 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 4" : FlowRate := {: causality <- "CIN" :};
	     OBJ DefFlow_3 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 5" : FlowRate := {: causality <- "CIN" :};
	     OBJ DefFlow_4 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 5" : FlowRate := {: causality <- "CIN" :};
     };
 
     parameters <-
     {
     OBJ active "yes=1, no=0" : Real := {: value <- 0 ; group <- "Operational" :};
 	  OBJ FD_th_RBT "Filling degree thredshold at RBT for activation" : Real := {: value <- 0.9 ; group <- "Operational" :};
	   OBJ FD_th_pipes "Filling degree thredshold at pipes for deactivation" : Real := {: value <- 0.8 ; group <- "Operational" :};
	   OBJ LimFlow_1 "Limited flow at pipe 1" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ LimFlow_2 "Limited flow at pipe 2" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ LimFlow_3 "Limited flow at pipe 3" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ LimFlow_4 "Limited flow at pipe 4" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ DefFlow_1 "Default flow at pipe 1" : FlowRate := {: value <- 0 ; group <- "Operational" :};
     };
	
		 independent <- 
     {
      OBJ t "Time" : Time := {: group <- "Time" :};
     };

     state <-
      {
	    OBJ help_u1 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u1_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u2 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u2_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u3 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u3_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u4 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u4_h (* hidden = "1" *) "Previous u help variable" : Real;
	  };
 
     equations <-
     {
			interface.Q_1 = IF ((parameters.active == 0) || (interface.FD_1 > parameters.FD_th_pipes))
		 				   	   	 THEN parameters.DefFlow_1
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN parameters.LimFlow_1
						    						 ELSE parameters.DefFlow_1;

			interface.Q_2 = IF ((parameters.active == 0) || (interface.FD_2 > parameters.FD_th_pipes))
		 				   	  	  THEN interface.DefFlow_2
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN parameters.LimFlow_2
						    						 ELSE interface.DefFlow_2;

			interface.Q_3 = IF ((parameters.active == 0) || (interface.FD_3 > parameters.FD_th_pipes))
		 				   	   	 THEN interface.DefFlow_3
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN  parameters.LimFlow_3
						    						 ELSE interface.DefFlow_3;

			interface.Q_4 = IF ((parameters.active == 0) || (interface.FD_4 > parameters.FD_th_pipes))
		 				   	   	 THEN interface.DefFlow_4
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN parameters.LimFlow_4
						    						 ELSE interface.DefFlow_4;
     };
  :};

CLASS RBT_spill_min
   (* icon = "Controller" *)
   "Controller to minimize RBT spilling with rate change"
  
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ FD_RBT (* terminal = "in_1" *) "Filling degree at RBT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ FD_1 (* terminal = "in_1" *) "Filling degree at pipe 1" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_1 (* terminal = "out_1" *) "Flow at pipe 1" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_2 (* terminal = "in_1" *) "Filling degree at pipe 2" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_2 (* terminal = "out_1" *) "Flow at pipe 2" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_3 (* terminal = "in_1" *) "Filling degree at pipe 3" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_3 (* terminal = "out_1" *) "Flow at pipe 3" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
	     OBJ FD_4 (* terminal = "in_1" *) "Filling degree at pipe 4" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_4 (* terminal = "out_1" *) "Flow at pipe 4" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
			 OBJ DefFlow_2 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 2" : FlowRate := {: causality <- "CIN" :};
	     OBJ DefFlow_3 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 3" : FlowRate := {: causality <- "CIN" :};
	     OBJ LimFlow_2 (* terminal = "in_2"; manip = "1" *) "Limited flow at pipe 2" : FlowRate := {: causality <- "CIN" :};
	     OBJ LimFlow_3 (* terminal = "in_2"; manip = "1" *) "Limited flow at pipe 3" : FlowRate := {: causality <- "CIN" :};
	     OBJ DefFlow_4 (* terminal = "in_2"; manip = "1" *) "Default flow at pipe 4" : FlowRate := {: causality <- "CIN" :};
     };
 
     parameters <-
     {
     OBJ active "yes=1, no=0" : Real := {: value <- 0 ; group <- "Operational" :};
 	  OBJ FD_th_RBT "Filling degree thredshold at RBT for activation" : Real := {: value <- 0.9 ; group <- "Operational" :};
	   OBJ FD_th_pipes "Filling degree thredshold at pipes for deactivation" : Real := {: value <- 0.8 ; group <- "Operational" :};
	   OBJ LimFlow_1 "Limited flow at pipe 1" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	    
	    
	   OBJ LimFlow_4 "Limited flow at pipe 4" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ DefFlow_1 "Default flow at pipe 1" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	   OBJ Q_rate_change_pipe "Rate of change of flow rate for pipe" : FlowRateRate := {: value <- 34560000 ; group <- "Operational" :};
     };
	
		 independent <- 
     {
      OBJ t "Time" : Time := {: group <- "Time" :};
     };

     state <-
      {
		  OBJ TS (* hidden = "0" *) "Time step" : Time := {: group <- "Operational" :};
	    OBJ help_u1 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u1_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u2 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u2_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u3 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u3_h (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u4 (* hidden = "1" *) "Previous u help variable" : Real;
	    OBJ help_u4_h (* hidden = "1" *) "Previous u help variable" : Real;
	  };
 
     equations <-
     {
			state.TS = independent.t - previous(independent.t);
			state.help_u1 = interface.Q_1;
			state.help_u1_h = IF ((parameters.active == 0) || (interface.FD_1 > parameters.FD_th_pipes))
		 				   	   	 THEN previous(state.help_u1) + parameters.Q_rate_change_pipe * state.TS
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN previous(state.help_u1) - parameters.Q_rate_change_pipe * state.TS
						    						 ELSE previous(state.help_u1) + parameters.Q_rate_change_pipe * state.TS;
			interface.Q_1 = IF (state.help_u1_h > parameters.DefFlow_1)
						    		  THEN parameters.DefFlow_1
						    			ELSE IF (state.help_u1_h < parameters.LimFlow_1)
						  	     		  THEN parameters.LimFlow_1
							     			  ELSE state.help_u1_h; 
			
			state.help_u2 = interface.Q_2;
			state.help_u2_h = IF ((parameters.active == 0) || (interface.FD_2 > parameters.FD_th_pipes))
		 				   	  	  THEN previous(state.help_u2) + parameters.Q_rate_change_pipe * state.TS
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN previous(state.help_u2) - parameters.Q_rate_change_pipe * state.TS
						    						 ELSE previous(state.help_u2) + parameters.Q_rate_change_pipe * state.TS;
			interface.Q_2 = IF (state.help_u2_h > interface.DefFlow_2)
						   		   THEN interface.DefFlow_2
						    		  ELSE IF (state.help_u2_h < interface.LimFlow_2)
						  	     			THEN interface.LimFlow_2
							     				ELSE state.help_u2_h;		
						 
			state.help_u3 = interface.Q_3;
			state.help_u3_h = IF ((parameters.active == 0) || (interface.FD_3 > parameters.FD_th_pipes))
		 				   	   	 THEN previous(state.help_u3) + parameters.Q_rate_change_pipe * state.TS
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN previous(state.help_u3) - parameters.Q_rate_change_pipe * state.TS
						    						 ELSE previous(state.help_u3) + parameters.Q_rate_change_pipe * state.TS;
			interface.Q_3 = IF (state.help_u3_h > interface.DefFlow_3)
						    		  THEN interface.DefFlow_3
						    		  ELSE IF (state.help_u3_h < interface.LimFlow_3)
						  	     		  THEN interface.LimFlow_3
							     			  ELSE state.help_u3_h;
			
			state.help_u4 = interface.Q_4;
			state.help_u4_h = IF ((parameters.active == 0) || (interface.FD_4 > parameters.FD_th_pipes))
		 				   	   	 THEN previous(state.help_u4) + parameters.Q_rate_change_pipe * state.TS
 				   	   			 ELSE IF (interface.FD_RBT > parameters.FD_th_RBT)
				   		    				  THEN previous(state.help_u4) - parameters.Q_rate_change_pipe * state.TS
						    						 ELSE previous(state.help_u4) + parameters.Q_rate_change_pipe * state.TS;
			interface.Q_4 = IF (state.help_u4_h > interface.DefFlow_4)
						   		   THEN interface.DefFlow_4
						    		  ELSE IF (state.help_u4_h < parameters.LimFlow_4)
						  	     			THEN parameters.LimFlow_4
							     			  ELSE state.help_u4_h;	 
     };
  :};
	
	CLASS RBT_control_new
   (* icon = "Controller" *)
   "Controller to minimize RBT spilling"
  
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
       OBJ FD_RBT (* terminal = "in_1" *) "Filling degree at RBT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	     OBJ FD_ES (* terminal = "in_1" *) "Filling degree at ES" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		   OBJ FD_RZ (* terminal = "in_1" *) "Filling degree at RZ" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
			 OBJ Q_NS (* terminal = "in_1" *) "Flow at pipe 3" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
			 OBJ Q_ES (* terminal = "in_1" *) "Flow at pipe 3" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
			 OBJ Q_RZ (* terminal = "in_1" *) "Flow at pipe 3" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
       OBJ Q_inf (* terminal = "in_1" *) "Flow at pipe 4" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		   OBJ Q_RBT (* terminal = "in_1" *) "Flow to RBT" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		
       OBJ maxQ_ES (* terminal = "out_1" *) "Max flow at ES" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
       OBJ maxQ_RZ (* terminal = "out_1" *) "Max flow at RZ" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		   OBJ Q_RBTempty (* terminal = "out_1" *) "RBT emptying flow" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		
			 OBJ MaxFlow_ES (* terminal = "in_2"; manip = "1" *) "Max flow fron ES" : FlowRate := {: causality <- "CIN" :};
	     OBJ MaxFlow_RZ (* terminal = "in_2"; manip = "1" *) "Max flow fron RZ" : FlowRate := {: causality <- "CIN" :};
		   OBJ active (* terminal = "in_2"; manip = "1" *) "yes=1, no=0" : Real := {: causality <- "CIN" :};
			 OBJ Q_max_bio (* terminal = "in_2"; manip = "1" *) "Sends to bio when Q_inf < Q_max_bio" : FlowRate := {: causality <- "CIN" :};
     };
 
     parameters <-
     {
		 OBJ Q_RBT_empty "RBT outflow when emptying" : FlowRate := {: value <- 24000 ; group <- "Operational" :};
 	  OBJ FD_th_RBT "Filling degree thredshold at RBT for activation" : Real := {: value <- 0.9 ; group <- "Operational" :};
	   OBJ FD_th_ES "Filling degree thredshold at ES" : Real := {: value <- 0.62 ; group <- "Operational" :};
		 OBJ FD_th_RZ "Filling degree thredshold at RZ" : Real := {: value <- 0.42 ; group <- "Operational" :};
     };
	
		 independent <- 
     {
      OBJ t "Time" : Time := {: group <- "Time" :};
     };

     state <-
      {
			OBJ mQ_ES "Max flow from ES, variable" : FlowRate := {: group <- "Operational" :};
			OBJ mQ_RZ "Max flow from RZ, variable" : FlowRate := {: group <- "Operational" :};
	  };
 
     equations <-
     {
		  interface.Q_RBTempty = IF (interface.Q_RBT > 0)
 				  									THEN 0
 				   				 				ELSE IF (interface.Q_inf >= (interface.Q_max_bio - parameters.Q_RBT_empty))
				   		  				 				THEN 0
						     			   				ELSE parameters.Q_RBT_empty;
		 
		  state.mQ_ES = interface.Q_max_bio - interface.Q_RBTempty - interface.Q_NS - interface.Q_RZ;
			interface.maxQ_ES = IF ((interface.active == 0) || (interface.FD_RBT < parameters.FD_th_RBT) || (interface.FD_ES > parameters.FD_th_ES) 
																|| ((interface.FD_ES < parameters.FD_th_ES) && (interface.FD_RZ < parameters.FD_th_RZ)))
		 				   	    		THEN interface.MaxFlow_ES
 				   	   		 		ELSE previous(state.mQ_ES);
		
			state.mQ_RZ = interface.Q_max_bio - interface.Q_RBTempty - interface.Q_NS - interface.Q_ES;
			interface.maxQ_RZ = IF ((interface.active == 0) || (interface.FD_RBT < parameters.FD_th_RBT) || (interface.FD_RZ > parameters.FD_th_RZ))
		 				   	    		THEN interface.MaxFlow_RZ
 				   	   		 		ELSE previous(state.mQ_RZ);
			
			};
  :};

   CLASS PST_control
   (* icon = "Controller" *)
   "Controller for PSTs"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ Q_WWTP (* terminal = "in_1" *) "Flow to WWTP" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ FD_RZ (* terminal = "in_1" *) "Filling degree at RZ" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ FD_RWT (* terminal = "in_1" *) "Filling degree at RWT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ FD_ES (* terminal = "in_1" *) "Filling degree at ES" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ maxQ_NS (* terminal = "out_1" *) "Max flow for NS" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  
		  OBJ maxQ_RZ (* terminal = "out_1" *) "Max flow for RZ" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_ES (* terminal = "out_1" *) "Max flow for ES" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ limQ_ES (* terminal = "out_1" *) "Limited flow for ES" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ limQ_RZ (* terminal = "out_1" *) "Limited flow for RZ" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_bio (* terminal = "out_1" *) "Max flow for bio" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_PST1 (* terminal = "out_1" *) "Max flow for PST1" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  

		  OBJ PST1_bp (* terminal = "out_1" *) "By-pass of PST1" : Fraction := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
	    OBJ active "Active = 1, not active = 0" : Real := {: group <- "Control" :};
		  OBJ bp "all = 1, nothing = 0" : Real := {: value <- 0.95 ; group <- "Operational" :};
	    OBJ Q_th_WWTP "Threshold Q at WWTP for WW" : FlowRate := {: value <- 210000 ; group <- "Operational" :};
	    OBJ FD_th_a "Filling degree thredshold at RZ and NS for activation WW3" : Real := {: value <- 0.9 ; group <- "Operational" :};
	    OBJ FD_th_d "Filling degree thredshold at RZ and NS for deactivation WW3" : Real := {: value <- 0.2 ; group <- "Operational" :};
	    OBJ maxQ_NS_DW "Limited flow at NS for DW" : FlowRate := {: value <- 72000 ; group <- "Operational NS" :};
		  OBJ maxQ_NS_WW1 "Limited flow at NS for WW1" : FlowRate := {: value <- 72000 ; group <- "Operational NS" :};
		  OBJ maxQ_NS_WW2 "Limited flow at NS for WW2" : FlowRate := {: value <- 60000 ; group <- "Operational NS" :};
		  OBJ maxQ_NS_WW3 "Limited flow at NS for WW3" : FlowRate := {: value <- 72000 ; group <- "Operational NS" :};
		  OBJ maxQ_NS_NA "Limited flow at NS if not active" : FlowRate := {: value <- 72000 ; group <- "Operational NS" :};
		  OBJ maxQ_ES_DW "Limited flow at ES for DW" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ limQ_ES_DW "Limited flow at ES for DW" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ maxQ_ES_WW1 "Limited flow at ES for WW1" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ limQ_ES_WW1 "Limited flow at ES for WW1" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ maxQ_ES_WW2 "Limited flow at ES for WW2" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ limQ_ES_WW2 "Limited flow at ES for WW2" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ maxQ_ES_WW3 "Limited flow at ES for WW3" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ limQ_ES_WW3 "Limited flow at ES for WW3" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ maxQ_ES_NA "Limited flow at ES if not active" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ limQ_ES_NA "Limited flow at ES if not active" : FlowRate := {: value <- 170000 ; group <- "Operational ES" :};
		  OBJ maxQ_RZ_DW "Limited flow at RZ for DW" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ maxQ_RZ_WW1 "Limited flow at RZ for WW1" : FlowRate := {: value <- 192000 ; group <- "Operational RZ" :};
		  OBJ maxQ_RZ_WW2 "Limited flow at RZ for WW2" : FlowRate := {: value <- 0 ; group <- "Operational RZ" :};
		  OBJ maxQ_RZ_WW3 "Limited flow at RZ for WW3" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ maxQ_RZ_NA "Limited flow at RZ if not active" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ limQ_RZ_DW "Limited flow at RZ for DW" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ limQ_RZ_WW1 "Limited flow at RZ for WW1" : FlowRate := {: value <- 192000 ; group <- "Operational RZ" :};
		  OBJ limQ_RZ_WW2 "Limited flow at RZ for WW2" : FlowRate := {: value <- 0 ; group <- "Operational RZ" :};
		  OBJ limQ_RZ_WW3 "Limited flow at RZ for WW3" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ limQ_RZ_NA "Limited flow at RZ if not active" : FlowRate := {: value <- 408000 ; group <- "Operational RZ" :};
		  OBJ maxQ_bio_DW "Limited flow at bio for DW" : FlowRate := {: value <- 210000 ; group <- "Operational bio" :};
		  OBJ maxQ_bio_WW1 "Limited flow at bio for WW1" : FlowRate := {: value <- 420000 ; group <- "Operational bio" :};
		  OBJ maxQ_bio_WW2 "Limited flow at bio for WW2" : FlowRate := {: value <- 420000 ; group <- "Operational bio" :};
		  OBJ maxQ_bio_WW3 "Limited flow at bio for WW3" : FlowRate := {: value <- 630000 ; group <- "Operational bio" :};
		  OBJ maxQ_bio_NA "Limited flow at bio if not active" : FlowRate := {: value <- 630000 ; group <- "Operational bio" :};
		  OBJ maxQ_PST1_DW "Limited flow at PST1 for DW" : FlowRate := {: value <- 210000 ; group <- "Operational PST1" :};
		  OBJ maxQ_PST1_WW1 "Limited flow at PST1 for WW1" : FlowRate := {: value <- 0 ; group <- "Operational PST1" :};
		  OBJ maxQ_PST1_WW2 "Limited flow at PST1 for WW2" : FlowRate := {: value <- 0 ; group <- "Operational PST1" :};
		  OBJ maxQ_PST1_WW3 "Limited flow at PST1 for WW3" : FlowRate := {: value <- 210000 ; group <- "Operational PST1" :};
		  OBJ maxQ_PST1_NA "Limited flow at PST1 if not active" : FlowRate := {: value <- 210000 ; group <- "Operational PST1" :};
		 









     };
	 
	 independent <- 
   {
    OBJ t "Time" : Time := {: group <- "Time" :};
   };
	 
	  state <-
    {
     OBJ phase (* hidden = "0" *) "0 = DW, 1 = WW1, 2 = WW2, 3 = WW3, 4 = not active" : Real := {: group <- "Operational" :};
    };
	 
	 initial <-
   {
   };
 
   equations <-
   {
   state.phase = IF (parameters.active == 0)
                 THEN 4
		 						ELSE IF ((interface.Q_WWTP <= parameters.Q_th_WWTP) && (interface.FD_RZ < parameters.FD_th_d) && (interface.FD_ES < parameters.FD_th_d))
		 								 THEN 0
		 								 ELSE IF (((previous(state.phase) == 0) || (previous(state.phase) == 1)) && (interface.Q_WWTP > parameters.Q_th_WWTP) && (interface.FD_RWT < 1))
		 								 		 THEN 1
		 											ELSE IF (((previous(state.phase) == 1) || (previous(state.phase) == 2)) && (interface.Q_WWTP > parameters.Q_th_WWTP) && (interface.FD_RZ < parameters.FD_th_a))
		 													 THEN 2
		 													 ELSE 3;
	 interface.maxQ_NS = IF (state.phase == 0)
		 									THEN parameters.maxQ_NS_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.maxQ_NS_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.maxQ_NS_WW2
		 														ELSE IF(state.phase == 3)
		 								  	 			 		 THEN parameters.maxQ_NS_WW3
		 																 ELSE parameters.maxQ_NS_NA;
	 interface.maxQ_ES = IF (state.phase == 0)
		 									THEN parameters.maxQ_ES_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.maxQ_ES_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.maxQ_ES_WW2
		 														ELSE IF((state.phase == 3) && (interface.FD_ES < parameters.FD_th_a))
		 								  	 			 		 THEN parameters.maxQ_ES_WW3
		 																 ELSE parameters.maxQ_ES_NA;
	 interface.limQ_ES = IF (state.phase == 0)
		 									THEN parameters.limQ_ES_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.limQ_ES_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.limQ_ES_WW2
		 														ELSE IF((state.phase == 3) && (interface.FD_ES < parameters.FD_th_a))
		 								  	 			 		 THEN parameters.limQ_ES_WW3
		 																 ELSE parameters.limQ_ES_NA;
	 interface.maxQ_RZ = IF (state.phase == 0)
		 									THEN parameters.maxQ_RZ_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.maxQ_RZ_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.maxQ_RZ_WW2
		 														ELSE IF(state.phase == 3)
		 								  	 			 		 THEN parameters.maxQ_RZ_WW3
		 																 ELSE parameters.maxQ_RZ_NA;
	 interface.limQ_RZ = IF (state.phase == 0)
		 									THEN parameters.limQ_RZ_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.limQ_RZ_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.limQ_RZ_WW2
		 														ELSE IF(state.phase == 3)
		 								  	 			 		 THEN parameters.limQ_RZ_WW3
		 																 ELSE parameters.limQ_RZ_NA;
	 interface.maxQ_bio = IF (state.phase == 0)
		 									THEN parameters.maxQ_bio_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.maxQ_bio_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.maxQ_bio_WW2
		 														ELSE IF(state.phase == 3)
		 								  	 			 		 THEN parameters.maxQ_bio_WW3
		 																 ELSE parameters.maxQ_bio_NA;
	 interface.maxQ_PST1 = IF (state.phase == 0)
		 									THEN parameters.maxQ_PST1_DW
		 									ELSE IF(state.phase == 1)
		 								  	 	THEN parameters.maxQ_PST1_WW1
		 											 ELSE IF(state.phase == 2)
		 								  	 			 THEN parameters.maxQ_PST1_WW2
		 														ELSE IF(state.phase == 3)
		 								  	 			 		 THEN parameters.maxQ_PST1_WW3
		 																 ELSE parameters.maxQ_PST1_NA;
	 interface.PST1_bp = IF (state.phase == 3)
		 									THEN parameters.bp
		 									ELSE 0;
   };
  :};
		 
	 CLASS PST_control_new
   (* icon = "Controller" *)
   "Controller for PSTs"
 
   SPECIALISES
   PhysicalDAEModelType :=
   {:
     comments <- "A model for a controller";
     interface <-
     {
      OBJ Q_inf (* terminal = "in_1" *) "Flow to WWTP" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ Q_NS (* terminal = "in_1" *) "Flow from NS" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ Q_RZ (* terminal = "in_1" *) "Flow from RZ" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ Q_ES (* terminal = "in_1" *) "Flow from ES" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ FD_RZ (* terminal = "in_1" *) "Filling degree at RZ" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ FD_RBT (* terminal = "in_1" *) "Filling degree at RWT" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ FD_ES (* terminal = "in_1" *) "Filling degree at ES" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		  OBJ maxQ_NS (* terminal = "out_1" *) "Max flow from NS" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_RZ (* terminal = "out_1" *) "Max flow from RZ" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_ES (* terminal = "out_1" *) "Max flow from ES" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_PC12 (* terminal = "out_1" *) "Max flow to PST3" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ maxQ_bio (* terminal = "out_1" *) "Max flow to biology" : FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
		  OBJ RBT_control_active (* terminal = "out_1" *) "RBT control active" : Real := {: causality <- "COUT" ; group <- "Control action" :};
     };
 
     parameters <-
     {
	    OBJ active "Active = 1, not active = 0" : Real := {: group <- "" :};
		  OBJ RBT_active "Active = 1, not active = 0 (fixed to 0 when PST active = 1)" : Real := {: group <- "" :};
		  OBJ f_3 "Fraction of capacity for ES in 3 if ES and RZ partially filled" : Real := {: value <- 0.6 ; group <- "FD" :};
		  OBJ FD_th_RBT_f "Filling degree to define RBT as full" : Real := {: value <- 0.83 ; group <- "FD" :};
		  OBJ FD_th_ES_f "Filling degree to define ES as full" : Real := {: value <- 0.62 ; group <- "FD" :};
		  OBJ FD_th_RZ_f "Filling degree to define RZ as full" : Real := {: value <- 0.42 ; group <- "FD" :};
		  OBJ FD_th_RBT_e "Filling degree to define RBT as empty" : Real := {: value <- 0.05 ; group <- "FD" :};
		  OBJ FD_th_ES_e "Filling degree to define ES as empty" : Real := {: value <- 0.05 ; group <- "FD" :};
		  OBJ FD_th_RZ_e "Filling degree to define RZ as empty" : Real := {: value <- 0.05 ; group <- "FD" :};
		  OBJ FD_th_ES_r "Filling degree of ES for check in phase 31/32" : Real := {: value <- 0.28 ; group <- "FD" :};
		   
		  OBJ maxQ_bio_boundary_NA "Max flow to bio when not active" : FlowRate := {: value <- 540000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_1 "Max flow to bio in DW" : FlowRate := {: value <- 210000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_11 "Max flow to bio in 1a" : FlowRate := {: value <- 420000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_12 "Max flow to bio in 1b" : FlowRate := {: value <- 420000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_21 "Max flow to bio in 2a" : FlowRate := {: value <- 420000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_22 "Max flow to bio in 2b" : FlowRate := {: value <- 420000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_23 "Max flow to bio in 2c" : FlowRate := {: value <- 630000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_24 "Max flow to bio in 2d" : FlowRate := {: value <- 630000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_31 "Max flow to bio in 3a" : FlowRate := {: value <- 420000 ; group <- "bio" :};
		  OBJ maxQ_bio_boundary_32 "Max flow to bio in 3b" : FlowRate := {: value <- 630000 ; group <- "bio" :};
		  OBJ maxQ_NS_NA "Max flow from NS when not active" : FlowRate := {: value <- 76800 ; group <- "NS" :};
	    OBJ maxQ_NS_all "Max flow from NS in all phases" : FlowRate := {: value <- 76800 ; group <- "NS" :};
		  OBJ maxQ_ES_NA "Max flow from ES when not active" : FlowRate := {: value <- 336000 ; group <- "ES" :};
		  OBJ maxQ_ES_1 "Max flow from ES in DW" : FlowRate := {: value <- 210000 ; group <- "ES" :};
		  OBJ maxQ_ES_11 "Max flow from ES in 1a" : FlowRate := {: value <- 336000 ; group <- "ES" :};
		  OBJ maxQ_ES_12 "Max flow from ES in 1b" : FlowRate := {: value <- 336000 ; group <- "ES" :};
		  OBJ maxQ_ES_32m "Max flow from ES in 3b, max" : FlowRate := {: value <- 451200 ; group <- "ES" :};
		  OBJ maxQ_RZ_NA "Max flow from RZ when not active" : FlowRate := {: value <- 312000 ; group <- "RZ" :};
		  OBJ maxQ_RZ_1 "Max flow from RZ in DW" : FlowRate := {: value <- 210000 ; group <- "RZ" :};
		  OBJ maxQ_RZ_11 "Max flow from RZ in 1a" : FlowRate := {: value <- 64800 ; group <- "RZ" :};
		  OBJ maxQ_RZ_12 "Max flow from RZ in 1b" : FlowRate := {: value <- 64800 ; group <- "RZ" :};
		  OBJ maxQ_RZ_21 "Max flow from RZ in 2a" : FlowRate := {: value <- 64800 ; group <- "RZ" :};
		  OBJ maxQ_RZ_22 "Max flow from RZ in 2b" : FlowRate := {: value <- 64800 ; group <- "RZ" :};
		  OBJ maxQ_RZ_23 "Max flow from RZ in 2c" : FlowRate := {: value <- 312000 ; group <- "RZ" :};
		  OBJ maxQ_RZ_24 "Max flow from RZ in 2d" : FlowRate := {: value <- 312000 ; group <- "RZ" :};
		  OBJ maxQ_RZ_32m "Max flow from RZ in 3b, max" : FlowRate := {: value <- 312000 ; group <- "RZ" :};
		  OBJ maxQ_PC12_NA "Max flow to PC12 when not active" : FlowRate := {: value <- 0 ; group <- "PC3" :};
		  OBJ maxQ_PC12_1 "Max flow to PC12 in DW" : FlowRate := {: value <- 0 ; group <- "PC3" :};
		  OBJ maxQ_PC12_11 "Max flow to PC12 in 1a" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_12 "Max flow to PC12 in 1b" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_21 "Max flow to PC12 in 2a" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_22 "Max flow to PC12 in 2b" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_23 "Max flow to PC12 in 2c" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_24 "Max flow to PC12 in 2d" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_31 "Max flow to PC12 in 3a" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_PC12_32 "Max flow to PC12 in 3b" : FlowRate := {: value <- 420000 ; group <- "PC3" :};
		  OBJ maxQ_RBT "Max flow to RBT" : FlowRate := {: value <- 210000 ; group <- "RBT" :};
		  OBJ tlag "Minimum time for phase change from 1a and 1b" : Time := {: group <- "" :};
		  OBJ tlag1 "Minimum time for phase change from 2c" : Time := {: group <- "" :};
     };
	 
	 independent <- 
   {
    OBJ t "Time" : Time := {: group <- "Time" :};
   };
	 
	  state <-
    {
     OBJ phase "1=DW,11=1a,12=1b,21=2a,22=2b,23=2c,24=2d,31=3a,32=3b,4=not active" : Real := {: group <- "Operational" :};
		 OBJ maxQ_ES_21 "Max flow from ES in 2a" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_ES_22 "Max flow from ES in 2b" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_ES_23 "Max flow from ES in 2c" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_ES_24 "Max flow from ES in 2d" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_avail_31 "Max flow available for RZ+ES in 3a" : FlowRate := {: group <- "Operational" :};
		 OBJ maxQ_avail_32 "Max flow available for RZ+ES in 3b" : FlowRate := {: group <- "Operational" :};
		 OBJ maxQ_ES_31 "Max flow from ES in 3a" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_RZ_31 "Max flow from RZ in 3a" : FlowRate := {: group <- "RZ" :};
		 OBJ maxQ_ES_32 "Max flow from ES in 3b" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_RZ_32 "Max flow from RZ in 3b" : FlowRate := {: group <- "RZ" :};
		 OBJ maxQ_ES_32h "Max flow from ES in 3b, help" : FlowRate := {: group <- "ES" :};
		 OBJ maxQ_RZ_32h "Max flow from RZ in 3b, help" : FlowRate := {: group <- "RZ" :};
		 OBJ RBT "RBT not full, 1 = true, 0 = false" : Real := {: group <- "Operational" :};
		 OBJ ES "ES not full, 1 = true, 0 = false" : Real := {: group <- "Operational" :};
		 OBJ RZ "RZ not full, 1 = true, 0 = false" : Real := {: group <- "Operational" :};
		 OBJ tcount "Time of last counter start" : Time := {: group <- "Operational" :};
		 OBJ tswitch "Time of last phase switch" : Time := {: group <- "Operational" :};
		 OBJ pswitch "Phase before last counter start" : Time := {: group <- "Operational" :};
		 OBJ FD_ES_b "To check if FD_ES has been below a threshold after last counter start, >0 if true" : Real := {: group <- "Operational" :};
		 
    };
	 
	 initial <-
   {
		 state.phase = 1;
   };
 
   equations <-
   {
	 interface.RBT_control_active = IF (parameters.active == 1)
		 														 THEN 0
		 														 ELSE parameters.RBT_active;
	 state.maxQ_ES_21 = parameters.maxQ_bio_boundary_21 - interface.Q_NS - interface.Q_RZ;
	 state.maxQ_ES_22 = parameters.maxQ_bio_boundary_22 + parameters.maxQ_RBT - interface.Q_NS - interface.Q_RZ;
	 state.maxQ_ES_23 = parameters.maxQ_bio_boundary_23 - interface.Q_NS - interface.Q_RZ;
	 state.maxQ_ES_24 = parameters.maxQ_bio_boundary_24 + parameters.maxQ_RBT - parameters.maxQ_RZ_24 - interface.Q_NS;
	 state.maxQ_avail_31 = parameters.maxQ_bio_boundary_31 - interface.Q_NS;
	 state.maxQ_avail_32 = parameters.maxQ_bio_boundary_32 - interface.Q_NS;
	
	 state.maxQ_ES_31 = IF (interface.FD_RZ > parameters.FD_th_RZ_e)
		 								 THEN parameters.f_3 * state.maxQ_avail_31
		 								 ELSE IF (interface.FD_ES > parameters.FD_th_ES_e)
		 											THEN state.maxQ_avail_31 - previous(state.maxQ_RZ_31)
		 								 		 ELSE parameters.f_3 * state.maxQ_avail_31;
		 
	 state.maxQ_RZ_31 = IF (interface.FD_ES > parameters.FD_th_ES_e)
		 								 THEN (1 - parameters.f_3) * state.maxQ_avail_31
		 								 ELSE IF (interface.FD_RZ > parameters.FD_th_RZ_e)
		 											THEN state.maxQ_avail_31 - state.maxQ_ES_31
		 								 		 ELSE (1 - parameters.f_3) * state.maxQ_avail_31;
		 
	 state.maxQ_ES_32h = IF (interface.FD_RZ > parameters.FD_th_RZ_e)
		 								  THEN parameters.f_3 * state.maxQ_avail_32
		 								  ELSE IF (interface.FD_ES > parameters.FD_th_ES_e)
		 											 THEN state.maxQ_avail_32 - previous(state.maxQ_RZ_32)
		 								 		  ELSE parameters.f_3 * state.maxQ_avail_32;
		 
	 state.maxQ_RZ_32h = IF (interface.FD_ES > parameters.FD_th_ES_e)
		 								  THEN (1 - parameters.f_3) * state.maxQ_avail_32
		 								  ELSE IF (interface.FD_RZ > parameters.FD_th_RZ_e)
		 										   THEN state.maxQ_avail_32 - state.maxQ_ES_32
		 								 		  ELSE (1 - parameters.f_3) * state.maxQ_avail_32;
		 
	 state.maxQ_ES_32 = IF (state.maxQ_ES_32h > parameters.maxQ_ES_32m)
		 								 THEN parameters.maxQ_ES_32m
		 								 ELSE state.maxQ_ES_32h;
	 state.maxQ_RZ_32 = IF (state.maxQ_RZ_32h > parameters.maxQ_RZ_32m)
		 								 THEN parameters.maxQ_RZ_32m
		 								 ELSE state.maxQ_RZ_32h;
	 
	  





		 
	 state.RBT = IF (interface.FD_RBT < parameters.FD_th_RBT_f)
		 				  THEN 1
		 					ELSE 0;
	 state.ES = IF (interface.FD_ES < parameters.FD_th_ES_f)  
		 				  THEN 1
		 					ELSE 0;
	 state.RZ = IF (interface.FD_RZ < parameters.FD_th_RZ_f)  
		 				  THEN 1
		 					ELSE 0;
		 
	 state.tswitch = IF (previous(state.phase) == state.phase)
		 							THEN previous(state.tswitch)
		 							ELSE independent.t;
	 
	 state.tcount = IF (((previous(state.phase) == 11) || (previous(state.phase) == 12)) && (interface.FD_ES < parameters.FD_th_ES_e) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 						 THEN previous(state.tcount)
		 						 ELSE independent.t;
		 
	 state.pswitch = IF (previous(state.phase) == state.phase)
		 							THEN previous(state.pswitch)
		 							ELSE previous(state.phase);
		 
	 state.FD_ES_b = IF (previous(state.tcount) < state.tcount)
		 							THEN 0
		 							ELSE IF (interface.FD_ES < parameters.FD_th_ES_r)
		 									 THEN previous(state.FD_ES_b) + 1
		 									 ELSE previous(state.FD_ES_b);
		 
   state.phase = IF (parameters.active == 0)
                 THEN 4
		 						ELSE IF (previous(state.phase) == 1)
		 								 THEN IF (interface.Q_inf <= parameters.maxQ_bio_boundary_1)
		 											THEN 1
		 											ELSE IF (state.RZ == 1)
		 													 THEN IF (state.RBT == 1)
		 																THEN IF (interface.Q_inf <= parameters.maxQ_bio_boundary_11)
		 																		 THEN 11
		 																		 ELSE IF (interface.Q_inf > parameters.maxQ_bio_boundary_12)
		 																					THEN 12
		 																					ELSE previous(state.phase)
		 																ELSE IF (state.ES == 1)
		 																		 THEN 21
		 																		 ELSE previous(state.phase)
		 													 ELSE previous(state.phase)
		 								 ELSE IF (previous(state.phase) == 11)
		 											THEN IF ((interface.FD_ES < parameters.FD_th_ES_e) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 													 THEN IF ((independent.t - state.tcount) > parameters.tlag)
		 																THEN 31
		 																ELSE 11
		 													 ELSE IF (state.RBT == 1)
		 																THEN IF (state.RZ == 1)
		 																		 THEN IF (interface.Q_inf <= parameters.maxQ_bio_boundary_11)
		 																		 		 THEN 11
		 																		 		 ELSE IF (interface.Q_inf > parameters.maxQ_bio_boundary_12)
		 																							 THEN 12
		 																							 ELSE previous(state.phase)
		 																		 ELSE IF (state.ES == 1)
		 																		 		 THEN 23
		 																					ELSE 24
		 																ELSE IF (state.ES == 1)
		 																		 THEN IF (state.RZ == 1)
		 																		 		 THEN 21
		 																					ELSE 23
		 																		 ELSE IF (state.RZ == 1)
		 																		 		 THEN 22
		 																					ELSE 24
		 											 ELSE IF (previous(state.phase) == 12)
		 														THEN IF ((interface.FD_ES < parameters.FD_th_ES_e) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 													 			THEN IF ((independent.t - state.tcount) > parameters.tlag)
		 																			THEN 31
		 																			ELSE 11
		 													 			ELSE IF (state.RBT == 1)
		 																			THEN IF (state.RZ == 1)
		 																		 			THEN IF (interface.Q_inf <= parameters.maxQ_bio_boundary_11)
		 																		 		 			THEN 11
		 																		 		 			ELSE IF (interface.Q_inf > parameters.maxQ_bio_boundary_12)
		 																							 			THEN 12
		 																							 			ELSE previous(state.phase)
		 																		 			ELSE IF (state.ES == 1)
		 																		 		 			THEN 23
		 																								ELSE 24
		 																			ELSE IF (state.ES == 1)
		 																		 			THEN IF (state.RZ == 1)
		 																		 		 			THEN 21
		 																								ELSE 23
		 																		 			ELSE IF (state.RZ == 1)
		 																		 		 			THEN 22
		 																								ELSE 24
		 														ELSE IF (previous(state.phase) == 21)
		 																 THEN IF ((interface.FD_ES < parameters.FD_th_ES_e) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 																			THEN 31
		 																			ELSE IF (state.ES == 1)
		 																		 			THEN IF (state.RZ == 1)
		 																		 		 			THEN 21
		 																								ELSE 23
		 																		 			ELSE IF (state.RZ == 1)
		 																		 		 			THEN 22
		 																								ELSE 24
		 																 ELSE IF (previous(state.phase) == 22)
		 																			THEN IF ((interface.FD_ES < parameters.FD_th_ES_f) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 																					 THEN 31
		 																					 ELSE IF (state.ES == 1)
		 																		 					 THEN IF (state.RZ == 1)
		 																		 		 					 THEN 21
		 																										 ELSE 23
		 																		 					 ELSE IF (state.RZ == 1)
		 																		 		 					 THEN 22
		 																										 ELSE 24
		 																			ELSE IF (previous(state.phase) == 23)
		 																					 THEN IF ((interface.FD_ES < parameters.FD_th_ES_f) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 																					 		 THEN IF ((independent.t - previous(state.tswitch)) > parameters.tlag1)
		 																										 THEN 32
		 																										 ELSE 23
		 																								ELSE IF (state.ES == 1)
		 																										 THEN 23
		 																										 ELSE 24
		 																					 ELSE IF (previous(state.phase) == 24)
		 																					 		 THEN IF ((interface.FD_ES < parameters.FD_th_ES_f) && (interface.FD_RZ < parameters.FD_th_RZ_f))
		 																					 		 		 THEN 32
		 																										 ELSE IF (state.ES == 1)
		 																										 		 THEN 23
		 																										 		 ELSE 24
		 																								ELSE IF (previous(state.phase) == 31)
		 																										 THEN IF ((interface.FD_RZ < parameters.FD_th_RZ_e) && (interface.FD_ES < parameters.FD_th_ES_e) 
		 																															&& (interface.Q_inf <= parameters.maxQ_bio_boundary_1))
		 																													THEN 1
		 																													ELSE IF (state.RZ == 0)
		 																															 THEN IF (state.ES == 1)
		 																										 							 THEN 23
		 																										 							 ELSE 24
		 																															 ELSE IF ((previous(state.pswitch) == 11) || (previous(state.pswitch) == 12) || (previous(state.pswitch) == 21))
		 																																		THEN IF (interface.FD_ES > parameters.FD_th_ES_r)
		 																																				 THEN IF (state.RBT == 1)
		 																																							THEN IF (interface.Q_inf <= parameters.maxQ_bio_boundary_11)
		 																		 																							THEN 11
		 																		 																							ELSE IF (interface.Q_inf > parameters.maxQ_bio_boundary_12)
		 																																												THEN 12
		 																																												ELSE previous(state.phase)
		 																																							ELSE 21
		 																																				 ELSE 31
		 																																		ELSE IF (previous(state.pswitch) == 22)
		 																																				 THEN IF (interface.FD_ES > parameters.FD_th_ES_f)
		 																																							THEN 22
		 																																				 		 ELSE IF ((interface.FD_ES > parameters.FD_th_ES_r) && (state.FD_ES_b > 0))
		 																																									 THEN 21
		 																																									 ELSE 31
		 																																				 ELSE previous(state.phase)
		 																										 ELSE IF (previous(state.phase) == 32)
		 																													THEN IF ((interface.FD_RZ < parameters.FD_th_RZ_e) && (interface.FD_ES < parameters.FD_th_ES_e) 
		 																															&& (interface.Q_inf <= parameters.maxQ_bio_boundary_1))
		 																															 THEN 1
		 																															 ELSE IF (state.RZ == 0)
		 																															 		 THEN IF (state.ES == 1)
		 																										 							 		 THEN 23
		 																										 							 		 ELSE 24
		 																																		ELSE IF (state.ES == 0)
		 																																				 THEN 24
		 																																				 ELSE 32
		 																													ELSE previous(state.phase);
		 		 
	 interface.maxQ_NS = IF (state.phase == 4)
		 									THEN parameters.maxQ_NS_NA
		 									ELSE parameters.maxQ_NS_all;
	 interface.maxQ_ES = IF (state.phase == 1)
		 									THEN parameters.maxQ_ES_1
		 									ELSE IF(state.phase == 11)
		 								  	 	THEN parameters.maxQ_ES_11
		 											 ELSE IF(state.phase == 12)
		 								  	 			 THEN parameters.maxQ_ES_12
		 														ELSE IF(state.phase == 21)
		 								  	 			 		 THEN state.maxQ_ES_21
		 																 ELSE IF(state.phase == 22)
		 								  	 			 		 		 THEN state.maxQ_ES_22
		 																 		 ELSE IF(state.phase == 23)
		 								  	 			 		 				  THEN state.maxQ_ES_23
		 																 					ELSE IF(state.phase == 24)
		 								  	 			 		 							 THEN state.maxQ_ES_24
		 																 							 ELSE IF(state.phase == 31)
		 								  	 			 		 										THEN state.maxQ_ES_31
		 																 										ELSE IF(state.phase == 32)
		 								  	 			 		 												 THEN state.maxQ_ES_32
		 																 												 ELSE parameters.maxQ_ES_NA;
	 interface.maxQ_RZ = IF (state.phase == 1)
		 									THEN parameters.maxQ_RZ_1
		 									ELSE IF(state.phase == 11)
		 								  	 	THEN parameters.maxQ_RZ_11
		 											 ELSE IF(state.phase == 12)
		 								  	 			 THEN parameters.maxQ_RZ_12
		 														ELSE IF(state.phase == 21)
		 								  	 			 		 THEN parameters.maxQ_RZ_21
		 																 ELSE IF(state.phase == 22)
		 								  	 			 		 		 THEN parameters.maxQ_RZ_22
		 																 		 ELSE IF(state.phase == 23)
		 								  	 			 		 				  THEN parameters.maxQ_RZ_23
		 																 					ELSE IF(state.phase == 24)
		 								  	 			 		 							 THEN parameters.maxQ_RZ_24
		 																 							 ELSE IF(state.phase == 31)
		 								  	 			 		 										THEN state.maxQ_RZ_31
		 																 										ELSE IF(state.phase == 32)
		 								  	 			 		 												 THEN state.maxQ_RZ_32
		 																 												 ELSE parameters.maxQ_RZ_NA;
	 interface.maxQ_bio = IF (state.phase == 1)
		 									 THEN parameters.maxQ_bio_boundary_1
		 									 ELSE IF(state.phase == 11)
		 								  	 	 THEN parameters.maxQ_bio_boundary_11
		 											  ELSE IF(state.phase == 12)
		 								  	 			  THEN parameters.maxQ_bio_boundary_12
		 														 ELSE IF(state.phase == 21)
		 								  	 			 		  THEN parameters.maxQ_bio_boundary_21
		 																  ELSE IF(state.phase == 22)
		 								  	 			 		 		  THEN parameters.maxQ_bio_boundary_22
		 																 		  ELSE IF(state.phase == 23)
		 								  	 			 		 				   THEN parameters.maxQ_bio_boundary_23
		 																 					 ELSE IF(state.phase == 24)
		 								  	 			 		 							  THEN parameters.maxQ_bio_boundary_24
		 																 							  ELSE IF(state.phase == 31)
		 								  	 			 		 										 THEN parameters.maxQ_bio_boundary_31
		 																 										 ELSE IF(state.phase == 32)
		 								  	 			 		 												  THEN parameters.maxQ_bio_boundary_32
		 																 												  ELSE parameters.maxQ_bio_boundary_NA;
	 interface.maxQ_PC12 = IF (state.phase == 1)
		 									  THEN parameters.maxQ_PC12_1
		 									  ELSE IF(state.phase == 11)
		 								  	  	 THEN parameters.maxQ_PC12_11
		 											   ELSE IF(state.phase == 12)
		 								  	 			   THEN parameters.maxQ_PC12_12
		 														  ELSE IF(state.phase == 21)
		 								  	 			 		   THEN parameters.maxQ_PC12_21
		 																   ELSE IF(state.phase == 22)
		 								  	 			 		 		   THEN parameters.maxQ_PC12_22
		 																 		   ELSE IF(state.phase == 23)
		 								  	 			 		 				    THEN parameters.maxQ_PC12_23
		 																 					  ELSE IF(state.phase == 24)
		 								  	 			 		 							   THEN parameters.maxQ_PC12_24
		 																 							   ELSE IF(state.phase == 31)
		 								  	 			 		 									 	 THEN parameters.maxQ_PC12_31
		 																 										  ELSE IF(state.phase == 32)
		 								  	 			 		 												   THEN parameters.maxQ_PC12_32
		 																 												   ELSE parameters.maxQ_PC12_NA;

   };
  :};

CLASS OnOffIdeal2
  (* icon = "Controller" *)
  "Ideal On-off controller"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller, if y_M > y_S then u_Off else u_On";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
    OBJ y_S "Setpoint value for controlled variable" : 
         Real := {: value <- 2  ; group <- "Operational":};
    OBJ u_Off	"Output when off"	: Real := {: value <- 10 ; group <- "Operational" :};
    OBJ u_On	"Output when on"	: Real := {: value <- 20 ; group <- "Operational" :};
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
    };

    equations <-
    {
    interface.u = IF (interface.y_M > parameters.y_S)
                  THEN parameters.u_Off
                  ELSE parameters.u_On;
   };

 :};
	
	CLASS MLSS_T
  (* icon = "Controller" *)
  "MLSS setpoint in function of T"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "MLSS setpoint in function of T";
    interface <-
    {
      OBJ T (* terminal = "in_1" *) "Sensor measured output" : 
               CelsiusTemperature := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
    OBJ T1 "Temperature 1" : CelsiusTemperature := {: value <- 11 ; group <- "Operational":};
		OBJ T2 "Temperature 2" : CelsiusTemperature := {: value <- 14 ; group <- "Operational":};
		OBJ T3 "Temperature 3" : CelsiusTemperature := {: value <- 20 ; group <- "Operational":};
    OBJ u_1	"Output when T<T1"	: Concentration := {: value <- 5000 ; group <- "Operational" :};
    OBJ u_2	"Output when T<T2"	: Concentration := {: value <- 4550 ; group <- "Operational" :};
		OBJ u_3	"Output when T<T3"	: Concentration := {: value <- 3700 ; group <- "Operational" :};
		OBJ u_4	"Output when T>T3"	: Concentration := {: value <- 2600 ; group <- "Operational" :};
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
    };

    equations <-
    {
    interface.u = IF (interface.T < parameters.T1)
                  THEN parameters.u_1
                  ELSE IF (interface.T < parameters.T2)
												THEN parameters.u_2
                  			ELSE IF (interface.T < parameters.T3)
														 THEN parameters.u_3
                  					 ELSE parameters.u_4;
   };

 :};

CLASS OnOffIdeal3
  (* icon = "Controller" *)
  "Ideal On-off controller + filling degree control"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller, if y_M > y_S and y_FD < 1 then u_Off else u_On";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	    OBJ y_FD (* terminal = "in_1" *) "Filling Degree" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
    OBJ y_S "Setpoint value for controlled variable" : 
         Real := {: value <- 7000000  ; group <- "Operational":};
    OBJ u_Off	"Output when off"	: Real := {: value <- 0 ; group <- "Operational" :};
    OBJ u_On	"Output when on"	: Real := {: value <- 10000000 ; group <- "Operational" :};
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
    };

    equations <-
    {
    interface.u = IF ((interface.y_M > parameters.y_S) && (interface.y_FD < 1))
                  THEN parameters.u_Off
                  ELSE parameters.u_On;
   };

 :};

 CLASS linear_Saturation
    (* icon = "Controller" *)
    "Linear controller with saturation"
    SPECIALISES
    PhysicalDAEModelType :=
    {:
      comments <- "A model for a linear controller with saturation";
      interface <-
      {
        OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
        OBJ u (* terminal = "out_1" *) "Controlled variable" : 
                 Real := {: causality <- "COUT" ; group <- "Control action" :};
      };
  
      parameters <-
      {
       OBJ a "u=a+b*y_M" : Real := {: value <- 0 ; group <- "Operational" :};
       OBJ b "u=a+b*y_M" : Real := {: value <- 1 ; group <- "Operational" :};
       OBJ u_Min "Minimum control action" : Real := {: value <- 0 ; group <- "Operational" :};
       OBJ u_Max "Maximum control action" : Real := {: value <- 1000 ; group <- "Operational" :};
      };
  
      independent <- 
      { 
       OBJ t "Time" : Time := {: group <- "Time" :}; 
      };
  
      state <-
      {
       OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
      };
  
      equations <-
      {
       state.uhelp = parameters.a + parameters.b * interface.y_M; 
  
       interface.u = IF(state.uhelp < parameters.u_Min)
                     THEN (parameters.u_Min)
                     ELSE
                       IF (state.uhelp > parameters.u_Max)
                       THEN parameters.u_Max
                       ELSE state.uhelp;
      };
  :};

CLASS P_sat
  (* icon = "Controller" *)
  "P controller with saturation"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.e = interface.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

 CLASS OnOff_FF_aer
  (* icon = "Controller" *)
  "On-off controller for feed-forward aeration control"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
	    OBJ ON (* terminal = "in_2"; manip = "1" *) "Additional criterion for on/off" :
	 					  Real := {: causality <- "CIN"  ; group <- "Operational":};
    };

    parameters <-
    {
    OBJ y_S "Threshold for on/off" : Real := {: value <- 7000000  ; group <- "Operational":};
    OBJ u_max	"Max out"	: Real := {: value <- 10000 ; group <- "Operational" :};
    OBJ u_min	"Min out"	: Real := {: value <- 0 ; group <- "Operational" :};
	  OBJ change_rate "Rate of change" : Real := {: value <- 1000000 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ TS (* hidden = "1" *) "Time step" : Time := {: group <- "Operational" :};  
	   OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
	   OBJ help_u_h (* hidden = "1" *) "Previous u help variable" : Real;
    };

    equations <-
    {
    state.TS = independent.t - previous(independent.t); 
	  state.help_u = interface.u;
    state.help_u_h = IF ((interface.y_M > parameters.y_S) || (interface.ON == 1))
                     THEN previous(state.help_u) + parameters.change_rate * state.TS
                     ELSE previous(state.help_u) - parameters.change_rate * state.TS;
	  interface.u = IF (state.help_u_h > parameters.u_max)
				  			  THEN parameters.u_max
				  			  ELSE IF (state.help_u_h < parameters.u_min)
				  	   				THEN parameters.u_min
					   				  ELSE state.help_u_h;
    };
 :};

	CLASS Irvine_Aeration_model_Carbon_foot_print
    (* icon = "Controller" *)
    "Irvine Carbon foot print"
  
   
   
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
    comments <- "A model that calculates Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
   	OBJ TSS_Anaerobic (* terminal = "in_1"; manip = "1" *) "TSS concentration in the aeration tank (g/m3)" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Aerobic (* terminal = "in_1"; manip = "1" *) "TSS concentration in the aeration tank (g/m3)" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ TSS_Anoxic (* terminal = "in_1"; manip = "1" *) "TSS concentration in the aeration tank (g/m3)" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Q_was (* terminal = "in_1"; manip = "1" *) "Sludge waste" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
		 OBJ C_was (* terminal = "in_1"; manip = "1" *) "Sludge waste" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
     OBJ Kla (* terminal = "out_1" *) "Calculated Kla (1/d)" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
	   OBJ O2_tank (* terminal = "in_1"; manip = "1" *) "Actual oxygen concentration in the aeration tank (g/m)" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Volume (* terminal = "in_1"; manip = "1" *) "Aeration tank volume (m)" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ Q_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Air flow rate of the fine bubble aerators under standard conditions (Nm/d)": FlowRate := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
	   OBJ Temp (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Measurement data" :};
	   OBJ P_atm (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Standard atmospheric pressure (Pa)": Real := {: causality <- "CIN" ; value <- 101325; group <- "Measurement data" :};
	   OBJ Temp_air (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Temperature (C)": CelsiusTemperature := {: causality <- "CIN" ; value <- 15.0 ; group <- "Measurement data" :};

	 
    };
  
 parameters <-
    {
	OBJ Depth "Depth of fine bubble aerator below the watersurface (m)": Real := {: value <- 6 ; group <- "Geometry of the tank and aerators" :};
	OBJ H "altitudine": Real := {: value <- 10 ; group <- "Local conditions of the situ" :};
	OBJ p_site "Vapour pressure (Pa)": Real := {: value <- 2334; group <- "Local conditions of the situ" :};
	OBJ P_st_atm "Standard atmospheric pressure (Pa)": Real := {: value <- 101325; group <- "Local conditions of the situ" :};
	OBJ Rho_sludge "Density of sludge (kg/m)": Real := {: value <- 988 ; group <- "Characteristic of the sludge and air" :};
	OBJ Rho_air "Air Density (kg/m)": Real := {: value <- 1.23 ; group <- "Characteristic of the sludge and air" :};
	OBJ Beta "Beta factor (-)": Real := {: value <- 0.98 ; group <- "Characteristic of the sludge and air" :};
	OBJ Phi "Phi factor (-)": Real := {: value <- 1.024 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_air "Oxygen concentration in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Characteristic of the sludge and air" :};
	OBJ CO2_in "CO2 concentration in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Characteristic of the sludge and air" :};
	OBJ O2_sat20 "Oxygen saturation of water under standard conditions (g/m): 1 atm, 20 C, no salts": Real := {: value <- 10.50 ; group <- "Characteristic of the sludge and air" :};
	OBJ g "Strength of the gravitational field (m/s)": Real := {: value <- 9.82 ; group <- "Characteristic of the sludge and air" :};
	OBJ a "diffuser specific aerea (m2)": Real := {: value <- 2 ; group <- "Geometry of the tank and aerators" :};
	OBJ A "dimensionaless Aeration model": Real := {: value <- 5.717 ; group <- "Aeration model" :};
	OBJ B "dimensionaless Aeration model": Real := {: value <- 6.815 ; group <- "Aeration model" :};
	OBJ f "fraction of the tank": Real := {: value <- 0.44 ; group <- "Aeration model" :};
	OBJ Nd "Total diffuser number (-)": Real := {: value <- 504 ; group <- "Geometry of the tank and aerators" :};
	OBJ SOTE "standard oxygen transfer efficiency (%)": Real := {: value <- 42 ; group <- "Operational" :};
	OBJ Anaerobic_Volume_biological "anaerobic volume biological reactor  (mc)": Real := {: value <- 11200 ; group <- "Operational" :};
	OBJ Anoxic_Volume_biological "anoxic volume biological reactor  (mc)": Real := {: value <- 28750 ; group <- "Operational" :};
	OBJ Aerobic_Volume_biological "aerobic volume biological reactor  (mc)": Real := {: value <- 50100 ; group <- "Operational" :};
	OBJ T_Average "averaging time used for the calculation of the average retention time" : Time := {: value <- 15; group <- "System" :};
	 
	OBJ P_out "Outut Pressure from the Blower (Pa)": Real := {: value <- 80000; group <- "Power consumption" :};
	OBJ landa "costant for air (-)": Real := {: value <- 1.395 ; group <- "Power consumption" :};
	OBJ epsilon "efficiency of the motor (-)": Real := {: value <- 0.58 ; group <- "Power consumption" :};
	OBJ fCO2 "factor of CO2 production (-)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
	OBJ Tin "absolute inlet temperature  (K)": Real := {: value <- 293.15 ; group <- "Power consumption" :};
	};	 
		
	independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
     };
		
	state <-
    {
	OBJ O2_rsat_average "Average oxygen saturation depending on water temperature and tank depth for fine bubble aeration (g/m)" : Concentration := {: group <- "Characteristic of liquid and air" :};
	OBJ p_site_variable "Vapour pressure (Pa)": Real := {: group <- "Local conditions" :};
	OBJ MCRT "Instantaneous sludge age": Time := {: group <- "Operational" :};
	OBJ MCRT_av "Sludge age over T": Time := {: group <- "Operational" :};
	OBJ Alpha "alphafactor ": Real := {: group <- "Operational" :};
	OBJ AlphaSOTE "Oxygen transfer efficiency for new fine bubble aeration in wastewater ": Real := {: group <- "Aeration" :};
	OBJ Chi "Characteristic number (-)": Real := {: group <- "Aeration" :};
	OBJ lgChi "Characteristic number (-)": Real := {: group <- "Aeration":};
	OBJ Qn "Normalized air flow (-)": Real := {: group <- "Aeration" :};
  OBJ SOTR "Standard oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ AOTR "Actual oxygen transfer rate for fine bubble aeration (g/d)": Real := {: group <- "Aeration" :};
	OBJ AOTRspecific "Oxygen transfer for diffuser (kg/d/m2)": Real := {: group <- "Aeration" :};
	OBJ O2_rsat "Oxygen saturation depending on water temperature (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ O2sat_std "Oxygen saturation depending on water depth (g/m3)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ MRi "mole ratio of oxygen to inters in ambient air and off gas (%)": Real := {: group <- "Aeration" :};
	OBJ MRe "mole ratio of oxygen to leave from aeration tank (%)": Real := {: group <- "Aeration" :};
	OBJ P_depth "Pressure at the bottom of the tank (Pa)": Real := {: group <- "Characteristic of liquid and air" :};
	OBJ OTEf "Oxygen transfer efficiency under field conditions (%)": Real := {: group <- "Aeration" :};
	 
	OBJ CO2 "CO2 production (kg/d)": Real := {: group <- "Power consumption" :};
	OBJ k "costant power factor (kW/(m3/s))": Real := {: group <- "Power consumption" :};
	OBJ Energy_consume "energy consume (kWh)": Real := {: group <- "Power consumption" :};
	OBJ Integ_energy_consume "Integral energy consume(kWh)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Integ_emissione_CO2 "Integral CO2(kg)" : Real:= {: group <- "Power consumption" :} ;
	OBJ Power_blowers "Power(kW)" : Real:= {: group <- "Power consumption" :};
	};
    
		 
    equations <-
    { 
	 
	state.MCRT = (parameters.Anoxic_Volume_biological * interface.TSS_Anoxic + parameters.Anaerobic_Volume_biological * interface.TSS_Anaerobic + parameters.Aerobic_Volume_biological * interface.TSS_Aerobic)/(interface.Q_was*interface.C_was + 1);
	DERIV(state.MCRT_av,[independent.t]) = (state.MCRT - state.MCRT_av) / parameters.T_Average;
		state.Qn = interface.Q_air / (24*3600*(parameters.a * parameters.Nd * parameters.Depth));
 
       state.Chi = IF (state.Qn == 0.0)
                   THEN 0.0
                   ELSE state.MCRT_av/state.Qn;
	
 
       state.lgChi = IF (state.Chi == 0.0)
                     THEN 0.0
                     ELSE log10(state.Chi);
 
       state.AlphaSOTE = IF (state.Chi == 0.0)
                         THEN 0.0
                         ELSE (parameters.A * log10(state.Chi) - parameters.B)/100;

	state.Alpha = state.AlphaSOTE / parameters.SOTE * 100;	
	 
	state.MRi = parameters.O2_air/100/(1 - parameters.O2_air/100 - parameters.CO2_in/100);
	state.MRe =  state.MRi*(1-state.OTEf);
	state.OTEf = state.AlphaSOTE * (parameters.Beta * state.O2_rsat_average - interface.O2_tank) / ( state.O2sat_std) * pow(parameters.Phi,(interface.Temp-20));
	 
	state.P_depth = parameters.Rho_sludge * parameters.g * parameters.Depth;
	state.p_site_variable = pow(10, 0.6979 + 0.02618* interface.Temp_air)* 133.33;
	state.O2_rsat = 14.65 - 0.41 * (interface.Temp) + 0.00799 * (interface.Temp) * (interface.Temp) - 0.0000778 * (interface.Temp) * (interface.Temp) * (interface.Temp);
	state.O2_rsat_average = state.O2_rsat * (state.P_depth * parameters.f + interface.P_atm - state.p_site_variable)/ (parameters.P_st_atm - parameters.p_site);
	state.O2sat_std =  parameters.O2_sat20;
	 
	state.SOTR =  interface.Q_air * parameters.Rho_air  * parameters.SOTE * parameters.O2_air / 10000;
	state.AOTR = state.Alpha * state.SOTR * (parameters.Beta * state.O2_rsat_average - interface.O2_tank) /state.O2sat_std * pow(parameters.Phi,(interface.Temp-20));
	interface.Kla = 1000 * state.AOTR/((parameters.Beta * state.O2_rsat_average - interface.O2_tank) * interface.Volume);
	state.AOTRspecific = state.AOTR /(interface.Volume);
	 
	state.k = (parameters.P_st_atm * parameters.landa * parameters.Tin) / (2.73 * 100000 * parameters.epsilon * (parameters.landa - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.landa)-1);
	state.Power_blowers = state.k * interface.Q_air/(24*3600);
	state.CO2 = state.Power_blowers * parameters.fCO2;
	DERIV(state.Integ_energy_consume, [independent.t]) = 24 * state.Power_blowers ;
	DERIV(state.Integ_emissione_CO2, [independent.t]) = state.CO2 ;
	};
    :};

CLASS Aeration_model
    (* icon = "Controller" *)
    "Aeration model"
  
   
   
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
    comments <- "A model that calculates Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
    OBJ TSS   	 (* terminal = "in_2" *) "TSS concentration in the aeration tank (g/m3)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Kla   	 (* terminal = "out_1" *) "Calculated Kla (1/d)" :
                 Real := {: causality <- "COUT" ; group <- "Control action" :};
	  OBJ O2_tank  (* terminal = "in_2" *) "Actual oxygen concentration in the aeration tank (g/m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	  OBJ Volume   (* terminal = "in_2"; manip = "1" *) "Aeration tank volume (m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	  OBJ O2_rsat_average_fine   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for fine bubble aeration (g/m)" :
    			 Real := {: causality <- "COUT" ; group <- "Control action" :};
	  OBJ DOsat   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for coarse bubble aeration (g/m)" :
    			 Real := {: causality <- "COUT" ; group <- "Control action" :};		
	  OBJ Q_air_fine (* terminal = "in_1"; manip = "1" *) "Air flow rate of the fine bubble aerators under standard conditions (Nm/h)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :}; 
	  OBJ Temp (* terminal = "in_1"; manip = "1" *) "Temperature (C)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :};
	  OBJ P_atm (* terminal = "in_1"; manip = "1" *) "Standard atmospheric pressure (Pa)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :};
    };
  
    parameters <-
    {
	  OBJ Depth_fine "Depth of fine bubble aerator below the watersurface (m)": Real := {: value <- 5.0 ; group <- "Operational" :};
	  OBJ Depth_coarse "Depth of coarse bubble aerator below the watersurface (m)": Real := {: value <- 5.0 ; group <- "Operational" :};
	  OBJ Depth_tank "Depth of aeration tank": Real := {: value <- 5.0 ; group <- "Operational" :};
  	 
	  OBJ Rho_sludge "Density of sludge (kg/m)": Real := {: value <- 1020 ; group <- "Operational" :};
	  OBJ Beta "Beta factor (-)": Real := {: value <- 0.95 ; group <- "Operational" :};
	  OBJ Phi "Phi factor (-)": Real := {: value <- 1.024 ; group <- "Operational" :};
	  OBJ O2_ssat "Oxygen saturation of water under standard conditions (g/m): 1 atm, 20 C, no salts": Real := {: value <- 9.08 ; group <- "Operational" :};
	  OBJ F_fine "Fouling factor for fine bubble aeration (-)": Real := {: value <- 1.0 ; group <- "Operational" :};
	   
	  OBJ SOTE_fine "Oxygen transfer efficiency for fine bubble aeration in a standard test expressed per meter depth (-)": Real := {: value <- 0.045 ; group <- "Operational" :};
	   
	  OBJ Rho_air "Density of air at standard conditions (kg/m)": Real := {: value <- 1.23 ; group <- "Operational" :};
	   
	  OBJ O2_air "Oxygen concentration in the atmosphere (%)": Real := {: value <- 21 ; group <- "Operational" :};
	  OBJ g "Strength of the gravitational field (m/s)": Real := {: value <- 9.82 ; group <- "Operational" :};
	  OBJ Omega "Exponentional cofficient for determining the alpha factor": Real := {: value <- 0.083 ; group <- "Operational" :};
    OBJ O2_sat "Saturation oxygen concentration in the aeration tank as stated in BSM1 (g/m)": Real := {: value <- 8 ; group <- "Operational" :};
	  };	 
		
	  state <-
    {
    OBJ Alpha "Alpha factor (-)": Real := {: group <- "Operational" :};
    OBJ SOTR_fine "Standard oxygen transfer rate for fine bubble aeration (g/d)": MassFlux := {: group <- "Operational" :};
	   
    OBJ AOTR_fine "Actual oxygen transfer rate for fine bubble aeration (g/d)": MassFlux := {: group <- "Operational" :};
	   
  	OBJ O2_out_fine "Concentration of oxygen in air leaving the tank with fine bubble aeration (g/m)": Real := {: group <- "Operational" :};
	   
	  OBJ O2_rsat "Oxygen saturation depending on water temperature (g/m3)": Real := {: group <- "Operational" :};
	  OBJ P_depth "Pressure at the bottom of the tank (Pa)": Real := {: group <- "Operational" :};
    };
		 
    equations <-
    {
    state.Alpha = exp((interface.TSS / 1000) * parameters.Omega * (-1));
	  state.O2_rsat = 14.65 - 0.41 * interface.Temp + 0.00799 * interface.Temp * interface.Temp - 0.0000778 * interface.Temp * interface.Temp * interface.Temp;
	  state.P_depth = parameters.Rho_sludge * parameters.g * parameters.Depth_tank + interface.P_atm;
	  state.O2_out_fine = parameters.O2_air - (parameters.SOTE_fine * parameters.Depth_fine) * parameters.O2_air * state.Alpha;  
  	 
	  interface.O2_rsat_average_fine = state.O2_rsat * (state.P_depth / interface.P_atm + state.O2_out_fine / parameters.O2_air) / 2;
	  interface.DOsat = state.O2_rsat;
	  state.SOTR_fine = 24 * interface.Q_air_fine * parameters.Rho_air * 1000 * parameters.SOTE_fine * parameters.Depth_fine * parameters.O2_air / 100;
  	 
  	state.AOTR_fine = state.SOTR_fine * (parameters.Beta * interface.O2_rsat_average_fine - interface.O2_tank) / parameters.O2_ssat * pow(parameters.Phi,(interface.Temp-20)) * state.Alpha * parameters.F_fine;
	   
  	 
	  interface.Kla = (state.AOTR_fine) / ((interface.O2_rsat_average_fine - interface.O2_tank) * interface.Volume);
	   
	  };
   :};
	
	CLASS Aeration_model_2
    (* icon = "Controller" *)
    "Aeration model with fixed alpha"
  
   
   
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
    comments <- "A model that calculates Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
    
    
    OBJ Kla   	 (* terminal = "out_1" *) "Calculated Kla (1/d)" :
                 Real := {: causality <- "COUT" ; group <- "Control action" :};
	  OBJ O2_tank  (* terminal = "in_2" *) "Actual oxygen concentration in the aeration tank (g/m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	  OBJ Volume   (* terminal = "in_2"; manip = "1" *) "Aeration tank volume (m)" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
	  OBJ O2_rsat_average_fine   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for fine bubble aeration (g/m)" :
    			 Real := {: causality <- "COUT" ; group <- "Control action" :};
	  OBJ DOsat   (* terminal = "out_1" *) "Average oxygen saturation depending on water temperature and tank depth for coarse bubble aeration (g/m)" :
    			 Real := {: causality <- "COUT" ; group <- "Control action" :};		
	  OBJ Q_air_fine (* terminal = "in_1"; manip = "1" *) "Air flow rate of the fine bubble aerators under standard conditions (Nm/h)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :}; 
	  OBJ Temp (* terminal = "in_1"; manip = "1" *) "Temperature (C)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :};
	  OBJ P_atm (* terminal = "in_1"; manip = "1" *) "Standard atmospheric pressure (Pa)":
					 Real := {: causality <- "CIN" ; group <- "Operational" :};
    };
  
    parameters <-
    {
	  OBJ Depth_fine "Depth of fine bubble aerator below the watersurface (m)": Real := {: value <- 5.0 ; group <- "Operational" :};
	   
	  OBJ Depth_tank "Depth of aeration tank": Real := {: value <- 5.0 ; group <- "Operational" :};
  	 
	  OBJ Rho_sludge "Density of sludge (kg/m)": Real := {: value <- 1020 ; group <- "Operational" :};
	  OBJ Beta "Beta factor (-)": Real := {: value <- 0.95 ; group <- "Operational" :};
	  OBJ Phi "Phi factor (-)": Real := {: value <- 1.024 ; group <- "Operational" :};
	  OBJ O2_ssat "Oxygen saturation of water under standard conditions (g/m): 1 atm, 20 C, no salts": Real := {: value <- 9.08 ; group <- "Operational" :};
	  OBJ F_fine "Fouling factor for fine bubble aeration (-)": Real := {: value <- 1.0 ; group <- "Operational" :};
	   
	  OBJ SOTE_fine "Oxygen transfer efficiency for fine bubble aeration in a standard test expressed per meter depth (-)": Real := {: value <- 0.045 ; group <- "Operational" :};
	   
	  OBJ Rho_air "Density of air at standard conditions (kg/m)": Real := {: value <- 1.23 ; group <- "Operational" :};
	   
	  OBJ O2_air "Oxygen concentration in the atmosphere (%)": Real := {: value <- 21 ; group <- "Operational" :};
	  OBJ g "Strength of the gravitational field (m/s)": Real := {: value <- 9.82 ; group <- "Operational" :};
	  OBJ alpha_fix "Fixed alpha factor": Real := {: value <- 0.85 ; group <- "Operational" :};
    
	  };	 
		
	  state <-
    {
    OBJ Alpha "Alpha factor (-)": Real := {: group <- "Operational" :};
    OBJ SOTR_fine "Standard oxygen transfer rate for fine bubble aeration (g/d)": MassFlux := {: group <- "Operational" :};
	   
    OBJ AOTR_fine "Actual oxygen transfer rate for fine bubble aeration (g/d)": MassFlux := {: group <- "Operational" :};
	   
  	OBJ O2_out_fine "Concentration of oxygen in air leaving the tank with fine bubble aeration (g/m)": Real := {: group <- "Operational" :};
	   
	  OBJ O2_rsat "Oxygen saturation depending on water temperature (g/m3)": Real := {: group <- "Operational" :};
	  OBJ P_depth "Pressure at the bottom of the tank (Pa)": Real := {: group <- "Operational" :};
    };
		 
    equations <-
    {
    state.Alpha = parameters.alpha_fix;
	  state.O2_rsat = 14.65 - 0.41 * interface.Temp + 0.00799 * interface.Temp * interface.Temp - 0.0000778 * interface.Temp * interface.Temp * interface.Temp;
	  state.P_depth = parameters.Rho_sludge * parameters.g * parameters.Depth_tank + interface.P_atm;
	  state.O2_out_fine = parameters.O2_air - (parameters.SOTE_fine * parameters.Depth_fine) * parameters.O2_air * state.Alpha;  
  	 
	  interface.O2_rsat_average_fine = state.O2_rsat * (state.P_depth / interface.P_atm + state.O2_out_fine / parameters.O2_air) / 2;
	  interface.DOsat = state.O2_rsat;
	  state.SOTR_fine = 24 * interface.Q_air_fine * parameters.Rho_air * 1000 * parameters.SOTE_fine * parameters.Depth_fine * parameters.O2_air / 100;
  	 
  	state.AOTR_fine = state.SOTR_fine * (parameters.Beta * interface.O2_rsat_average_fine - interface.O2_tank) / parameters.O2_ssat * pow(parameters.Phi,(interface.Temp-20)) * state.Alpha * parameters.F_fine;
	   
  	 
	  interface.Kla = (state.AOTR_fine) / ((interface.O2_rsat_average_fine - interface.O2_tank) * interface.Volume);
	   
	  };
   :};

  CLASS PI_Saturation_recB
  (* icon = "Controller" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
     OBJ y_MA (* terminal = "in_1" *) "Sensor measured output" : 
               Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
	   OBJ y_MB (* terminal = "in_1" *) "Sensor measured output" : 
               Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		 OBJ temp (* terminal = "in_2" *) "Temperature" : 
               CelsiusTemperature := {: causality <- "CIN" ; group <- "Measurement data" :};
     OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
    };

    parameters <-
    {
     OBJ y_SA "Setpoint value for controlled variable" : Concentration := {: value <- 3 ; group <- "Operational" :};
     OBJ K_PA "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
	   OBJ K_PB "Factor of proportionality" : Real := {: value <- 25 ; group <- "Operational" :};
     OBJ T_I "Integral time" : Time := {: value <- 0.1 ; group <- "Operational" :};
     OBJ u0A "No error action" : FlowRate := {: value <- 50 ; group <- "Operational" :};
	   OBJ u0B "No error action" : FlowRate := {: value <- 50 ; group <- "Operational" :};
     OBJ u_Min "Minimum control action" : FlowRate := {: value <- 0 ; group <- "Operational" :};
     OBJ u_Max "Maximum control action" : FlowRate := {: value <- 1000 ; group <- "Operational" :};
	   OBJ switch "1=A, 2=B, 0=min(A,B)" : Real := {: value <- 0 ; group <- "Operational" :};
		 OBJ temp1 "temp1" : CelsiusTemperature := {: value <- 11 ; group <- "Operational" :};
		 OBJ temp2 "temp2" : CelsiusTemperature := {: value <- 12 ; group <- "Operational" :};
		 OBJ temp3 "temp3" : CelsiusTemperature := {: value <- 13 ; group <- "Operational" :};
		 OBJ temp4 "temp4" : CelsiusTemperature := {: value <- 14 ; group <- "Operational" :};
		 OBJ temp5 "temp5" : CelsiusTemperature := {: value <- 15 ; group <- "Operational" :};
		 OBJ temp6 "temp6" : CelsiusTemperature := {: value <- 16 ; group <- "Operational" :};
		 OBJ temp7 "temp7" : CelsiusTemperature := {: value <- 17 ; group <- "Operational" :};
		 OBJ temp8 "temp8" : CelsiusTemperature := {: value <- 18 ; group <- "Operational" :};
		 OBJ NO3_1 "NO3 1" : Concentration := {: value <- 11.8 ; group <- "Operational" :};
		 OBJ NO3_2 "NO3 2" : Concentration := {: value <- 11 ; group <- "Operational" :};
		 OBJ NO3_3 "NO3 3" : Concentration := {: value <- 10.8 ; group <- "Operational" :};
		 OBJ NO3_4 "NO3 4" : Concentration := {: value <- 10.5 ; group <- "Operational" :};
		 OBJ NO3_5 "NO3 5" : Concentration := {: value <- 10.2 ; group <- "Operational" :};
		 OBJ NO3_6 "NO3 6" : Concentration := {: value <- 3.3 ; group <- "Operational" :};
		 OBJ NO3_7 "NO3 7" : Concentration := {: value <- 2.4 ; group <- "Operational" :};
		 OBJ NO3_8 "NO3 8" : Concentration := {: value <- 2.2 ; group <- "Operational" :};
		 OBJ NO3_9 "NO3 9" : Concentration := {: value <- 2.1 ; group <- "Operational" :};
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ eA "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eA "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpA (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ uA (* hidden = "0" *) "" : FlowRate;
	   OBJ eB "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_eB "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelpB (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
	   OBJ y_SB (* hidden = "0" *) "Setpoint value for controlled variable" : Concentration;
	   OBJ uB (* hidden = "0" *) "" : FlowRate;
	     };

    equations <-
    {
     state.eA = parameters.y_SA - interface.y_MA;

     DERIV(state.Integ_eA, [independent.t]) = state.eA ;

     state.uhelpA = parameters.u0A + parameters.K_PA * (state.eA + (1 / parameters.T_I) * state.Integ_eA); 

     state.uA = IF(state.uhelpA < parameters.u_Min)
                THEN (parameters.u_Min)
                ELSE IF (state.uhelpA > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelpA;
	
	   state.y_SB = IF(interface.temp < parameters.temp1)
	 			 			  THEN parameters.NO3_1
				  			  ELSE IF(interface.temp < parameters.temp2) 
					  					 THEN parameters.NO3_2
				      				 ELSE IF(interface.temp < parameters.temp3) 
					      			 		 THEN parameters.NO3_3
				          					ELSE IF(interface.temp < parameters.temp4) 
					          						 THEN parameters.NO3_4
				             					  ELSE IF(interface.temp < parameters.temp5) 
					              							THEN parameters.NO3_5
				                  						ELSE IF(interface.temp < parameters.temp6) 
					                  							 THEN parameters.NO3_6
				                     						  ELSE IF(interface.temp < parameters.temp7) 
					                      							  THEN parameters.NO3_7
				                          							ELSE IF(interface.temp < parameters.temp8) 
					                          								 THEN parameters.NO3_8
				                              							 ELSE parameters.NO3_9;
					 
	   state.eB = state.y_SB - interface.y_MB;

     DERIV(state.Integ_eB, [independent.t]) = state.eB ;

     state.uhelpB = parameters.u0B + parameters.K_PB * (state.eB + (1 / parameters.T_I) * state.Integ_eB); 

     state.uB = IF(state.uhelpB < parameters.u_Min)
                THEN (parameters.u_Min)
                ELSE IF (state.uhelpB > parameters.u_Max)
                     THEN parameters.u_Max
                     ELSE state.uhelpB;				
	 
	   interface.u = IF (parameters.switch == 1)
	 			   			 THEN state.uA
				   				ELSE IF (parameters.switch == 2)
					   					 THEN state.uB
					   					 ELSE IF (state.uB < state.uA)
	 			   				 				THEN state.uB
				   				 				 ELSE state.uA;
				   
    };
  :};

 CLASS effluent_aeration
 (* icon = "River_aeration" *)
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   OBJ Outflow (* terminal = "out_1" *) "Outflow" :
  	  OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	 OBJ Q_Dose (* terminal = "in_1" *) "Flowrate of the solution" :
  	  FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components"
        : SpecificVolumeVector;
  OBJ C_Dose "Concentration of the solution" : 
   	   Concentration := {: value <- 1000000 ; group <- "Concentration" :};
  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
   	    : Real := {: group <- "System" :};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };
  
    state <-
    {
	OBJ DO_flux : MassFlux := {: group <- "Operational" :};
	OBJ DO_mass : Mass := {: group <- "Operational" :};
   	  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - interface.Q_Dose
   		/ parameters.WWTPSpecificVolume[IndexOfSolvent];
  interface.Outflow[S_O] = - interface.Q_Dose * parameters.C_Dose;
  state.DO_flux = interface.Q_Dose * parameters.C_Dose;
  DERIV(state.DO_mass, [independent.t]) = state.DO_flux ;
  };

 :};

 CLASS in_stream_aeration
 (* icon = "River_aeration" *)
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   OBJ Outflow (* terminal = "out_1" *) "Outflow" :
  	  OutRivTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	 OBJ Q_Dose (* terminal = "in_1" *) "Flowrate of the solution" :
  	  FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  };

  parameters <-
  {
  OBJ WWTPSpecificVolume (* hidden = "1" *) "The specific volumes (= 1/density) of the components"
        : SpecificVolumeVector;
  OBJ C_Dose "Concentration of the solution" : 
   	   Concentration := {: value <- 1000000 ; group <- "Concentration" :};
  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
   	    : Real := {: group <- "System" :};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  initial <-
  {
  parameters.WWTPSpecificVolume[IndexOfSolvent] := 0.000001;
  };
  
    state <-
    {
	OBJ DO_flux : MassFlux := {: group <- "Operational" :};
	OBJ DO_mass : Mass := {: group <- "Operational" :};
   	  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - interface.Q_Dose
   		/ parameters.WWTPSpecificVolume[IndexOfSolvent];
  interface.Outflow[rO2] = - interface.Q_Dose * parameters.C_Dose;
  state.DO_flux = interface.Q_Dose * parameters.C_Dose;
  DERIV(state.DO_mass, [independent.t]) = state.DO_flux ;
  };

 :};

  CLASS Operator
    (* icon = "Controller" *)
    "P controller with saturation"
  
   
   
   
   
   
   
   
  
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
      comments <- "A model for a proportional controller with saturation";
      interface <-
      {
        OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
                 Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		    OBJ y_S_Lower (* terminal = "in_2" *) "Lower limit setpoint value for controlled variable" : 
                 Concentration := {: causality <- "CIN" ; group <- "Operational" :};
		    OBJ y_S_Upper (* terminal = "in_2" *) "Upper limit setpoint value for controlled variable" : 
                 Concentration := {: causality <- "CIN" ; group <- "Operational" :};
        OBJ u (* terminal = "out_1" *) "Controlled variable" : 
                 FlowRate := {: causality <- "COUT" ; group <- "Control action" :};
      };
  
      parameters <-
      {
       OBJ K_P " Factor of proportionality" : Real := {: value <- 1 ; group <- "Operational" :};
       OBJ u0 "No error action" : FlowRate := {: value <- 1 ; group <- "Operational" :};
       OBJ u_Min "Minimum control action" : FlowRate := {: value <- 0 ; group <- "Operational" :};
       OBJ u_Max "Maximum control action" : FlowRate := {: value <- 1000 ; group <- "Operational" :};
        
       OBJ t_win "Control window" : Time := {: value <- 0.04166666667 ; group <- "Operational" :};
	     OBJ t_ini "Initial time" : Time := {: value <- 0 ; group <- "Control" :};
	     OBJ gain "Multiplyer of set-points, for GSA" : Real := {: value <- 1 ; group <- "Operational" :};
      };
  
      independent <- 
      { 
      OBJ t "Time" : Time := {: group <- "Time" :}; 
      };
  
      state <-
      {
       OBJ uhelp (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
	     OBJ uhelp_h (* hidden = "0" *) "Help variable to calculate the proportional control action" : Real;
       OBJ Prev_t (* hidden = "0" *) "Help variable to calculate the begin of each period" : Time ;
      };
  
      initial <-
      {
      state.Prev_t = parameters.t_ini;
      };
   
      equations <-
      {
  
       state.Prev_t = IF	(independent.t - previous(state.Prev_t) < (parameters.t_win))
  			 	 				 THEN previous(state.Prev_t)
  			 						ELSE previous(state.Prev_t) + parameters.t_win;
  
       state.uhelp_h = IF (previous(state.uhelp) < 0)
  	 			   				 THEN 0
  				   					ELSE IF (independent.t - previous(state.Prev_t) < parameters.t_win)
  	 			   	 					 THEN previous(state.uhelp)
  				   	 						ELSE IF(interface.y_M < interface.y_S_Lower * parameters.gain)
                     	   			 THEN previous(state.uhelp) - parameters.K_P * (interface.y_S_Lower * parameters.gain - interface.y_M)
                     	   			 ELSE IF (interface.y_M > interface.y_S_Upper * parameters.gain)
                         	 				  THEN previous(state.uhelp) + parameters.K_P * (interface.y_M - interface.y_S_Upper * parameters.gain)
                         	 					ELSE previous(state.uhelp);
  
      state.uhelp = IF(state.uhelp_h < parameters.u_Min)
                    THEN (parameters.u_Min)
                    ELSE IF (state.uhelp_h > parameters.u_Max)
                      	 THEN parameters.u_Max
                        ELSE state.uhelp_h;
					   
	    interface.u = state.uhelp;
     };
  
   :};
# 16 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 1
 














 





# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.general.msl" 1
 


















 
 
 

 
 
 

  
  


# 42 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.general.msl"




 TYPE BODCODComponents 
 "The number of biological components considered in the input of a BODCOD transformer"
  = ENUM {H2O, COD, BOD5, TSS, TKN, TP};

 TYPE BODComponents 
 "The number of biological components considered in the input of a BOD transformer"
  = ENUM {H2O, BOD_5, SS, KjN, ToP};


 OBJ NrOfBODCODComponents
  "The number of biological components considered in the input of a BODCOD transformer"
  : Integer := Cardinality(BODCODComponents);

 OBJ NrOfBODComponents
  "The number of biological components considered in the input of a BODCOD transformer"
  : Integer := Cardinality(BODComponents); 

  
 
 CLASS BODCODTerminal
 "The parameters passed to a BOD COD transformer from the influent file"
 = Concentration[NrOfBODCODComponents;];

 CLASS InBODCODTerminal SPECIALISES BODCODTerminal;  
 CLASS OutBODCODTerminal SPECIALISES BODCODTerminal;  

  
 
 CLASS BODTerminal
  "The parameters passed to a BOD transformer from the influent file"
  = Concentration[NrOfBODComponents;];

 CLASS InBODTerminal SPECIALISES BODTerminal;  
 CLASS OutBODTerminal SPECIALISES BODTerminal;  

 OBJ In_BOD_COD_Terminal "Temporary iteration variable" : BODCODTerminal;
  


 
 
 

 

 OBJ NrOfComponents
  "The number of biological components considered in the WWTP models"
  : Integer := Cardinality(Components);

 OBJ NrOfReactions
  "The number of reactions between biological components considered in the WWTP models"
  : Integer := Cardinality(Reactions);

  

 OBJ NrOfLayers "The number of layers in the secondary clarifier"
  : Integer := 10 ;

 OBJ NrOfLayersButOne "The number of layers in the secondary clarifier minus one" 
  : Integer := 9 ;

 OBJ NrOfLayersPlusOne "The number of layers in the secondary clarifier plus one" 
  : Integer := 11 ;

  
 
 
  OBJ NrOfLayersBurger "Burger model: The number of layers in the secondary clarifier (N)" : Integer := 90 ;  
  OBJ NrOfLayersPlusOneBurger "Burger model: The number of layers in the clarifier plus one (N+1)" : Integer := 91 ;  
  OBJ NrOfLayersPlusTwoBurger "Burger model: The number of layers in the clarifier plus two extra layers in the underflow (N+2)" : Integer := 92 ; 
  OBJ NrOfLayersPlusThreeBurger "Burger model: The number of layers in the secondary clarifier plus 3 (N+3)" : Integer := 93 ;
  OBJ NrOfLayersPlusFourBurger "Burger model: The number of layers in the clarifier plus the extra layers in effluent and underflow (N+4)" : Integer := 94 ;
  OBJ NrOfConcentration "Burger model: The number of discretisations between min and max concentration" : Integer := 1000;
 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 

 CLASS WWTPTerminal
 "The variables which are passed between WWTP model building blocks"
 = MassFlux[NrOfComponents;]; 

 CLASS InWWTPTerminal SPECIALISES WWTPTerminal;  
 CLASS OutWWTPTerminal SPECIALISES WWTPTerminal;  

 

 CLASS WWTPConcTerminal 
  "The variables which are passed between WWTP model building blocks in concentrations"
  = Concentration[NrOfComponents;]; 

 CLASS InWWTPConcTerminal SPECIALISES WWTPConcTerminal;  
 CLASS OutWWTPConcTerminal SPECIALISES WWTPConcTerminal;  

  
  
  
  



 
 
 

  
  
  
  

 OBJ Comp_Index "Temporary iteration variable, index of the component" : Integer;
 OBJ Reaction_Index "Temporary iteration variable, index of the reaction" : Integer;
 OBJ In_Comp_Index "Temporary iteration variable, index of the incoming component" : Integer;
 OBJ Out_Comp_Index "Temporary iteration variable, index of the outgoing component" : Integer;
 OBJ Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ In_Terminal "Temporary iteration variable" : WWTPTerminal;
 OBJ Out_Terminal "Temporary iteration variable" : WWTPTerminal;

  

 OBJ Layer_Index "Temporary iteration variable, index of the layer" : Integer;
 OBJ IndexOfFeedLayer "The index of the layer where the influent is feeded to the clarifier" 
  : Integer := 5 ;

 
  

 
  OBJ IndexOfFeedLayerBurger "The index of the layer where the influent is feeded to the clarifier" : Integer := 25 ;
  OBJ Conc_Index "Temporary iteration variable, index of the concentration vector" : Integer;
 

 
 
 

 
 
 
 

CLASS MassVector = Mass[NrOfComponents;];
CLASS MassFluxVector = MassFlux[NrOfComponents;];
CLASS ConcentrationVector = Concentration[NrOfComponents;];
CLASS SpecificVolumeVector = SpecificVolume[NrOfComponents;];
CLASS VelocityVector = Velocity[NrOfComponents;];
CLASS ArealFluxVector = ArealFlux[NrOfComponents;];
CLASS LengthVector = Length[NrOfLayers;];
CLASS VolumeVector = Volume[NrOfLayers;];
CLASS L_and_B_ConcentrationVector = Concentration[5;];

 
CLASS TakacsMassVector = Mass[NrOfLayers;];
CLASS TakacsConcentrationVector = Concentration[NrOfLayers;];
CLASS TakacsVelocityVector = Velocity[NrOfLayers;];
CLASS TakacsArealFluxVector = ArealFlux[NrOfLayers;];
CLASS LayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayers;];

 
CLASS LayerMassMatrix = Mass[NrOfComponents;][NrOfLayers;];
 
 
CLASS BurgerMassVector = Mass[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthVector = Length[NrOfLayersPlusFourBurger;];
CLASS BurgerConcentrationVector = Concentration[NrOfLayersPlusFourBurger;];
CLASS BurgerConcentrationVector2 = Concentration[NrOfConcentration;];
CLASS BurgerVelocityVector = Velocity[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector = ArealFlux[NrOfLayersPlusFourBurger;];
CLASS BurgerArealFluxVector2 = ArealFlux[NrOfConcentration;];
CLASS BurgerLayerConcentrationMatrix = Concentration[NrOfComponents;][NrOfLayersPlusFourBurger;];
CLASS BurgerDiffusivityVector = Diffusivity[NrOfLayersPlusFourBurger;];
CLASS BurgerLengthFluxVector = LengthFlux[NrOfLayersPlusFourBurger;];
 
 
CLASS PloszConcentrationVector = Concentration[60;];
CLASS PloszVelocityVector = Velocity[60;];
CLASS PloszArealFluxVector = ArealFlux[60;];
CLASS PloszDiffusivityVector = Diffusivity[60;]; 
 
 


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

  
 
 

  
  
  
  
  
  

  
  

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1Temp.msl" 1
 


















# 38 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1Temp.msl"


# 52 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1Temp.msl"


# 88 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1Temp.msl"



# 55 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM2dModTemp.msl" 1
 
 
 
 
 







TYPE Components
"
The biological components considered in the WWTP models
"
	= ENUM {H2O, 
		S_I, 
		S_O, 
		S_N2, 
		S_F, 
		S_A, 
		S_Al, 
		S_NO, 
		S_PO, 
		S_NH, 
		S_ALK, 
		X_I, 
		X_S, 
		X_H, 
		X_PAO, 
		X_PP, 
		X_PHA, 
		X_AUT, 
		X_TSS, 
		X_MEOH, 
		X_MEP, 
		X_I_i, 
		};




TYPE Reactions
"
The reactions between biological components considered in the WWTP models
"
	= ENUM {AerHydrol, 
		AnHydrol, 
		AnaerHydrol, 
		AerGrowthOnSf, 
		AerGrowthOnSa, 
		AnGrowthOnSfDenitrif, 
		AnGrowthOnSaDenitrif, 
		Fermentation, 
		LysisOfHetero, 
		StorageOfXPHA, 
		AerStorageOfXPP, 
		AnStorageOfXPP, 
		AerGrowthOnXPHA, 
		AnGrowthOnXPHADenitrif, 
		LysisOfXPAO, 
		LysisOfXPP, 
		LysisOfXPHA, 
		GrowthOfAuto, 
		LysisOfAuto, 
		Precipitation, 
		Redissolution, 
		Aeration, };






	OBJ IndexOfSolvent
	"The index of the solvent in the components vector considered in the WWTP models"
	: Integer := 1;



	OBJ IndexOfFirstSolubleComponent
	"The index of the first soluble component in the components vector considered in the WWTP models"
	: Integer := 2;


	OBJ IndexOfLastSolubleComponent
	"The index of the last soluble component in the components vector considered in the WWTP models"
	: Integer := 11;



	OBJ IndexOfFirstParticulateComponent
	"The index of the first particulate component in the components vector considered in the WWTP models"
	: Integer := 12;


	OBJ IndexOfLastParticulateComponent
	"The index of the last particulate component in the components vector considered in the WWTP models"
	: Integer := 22;



	OBJ IndexOfTSSComponent
	"The index of the TSS component in the components vector considered in the WWTP models"
	: Integer := 19;









# 56 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3Temp.msl" 1
 


















# 38 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3Temp.msl"


# 56 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3Temp.msl"


# 88 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3Temp.msl"



# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3P_EAWAG.msl" 1
 


















# 43 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3P_EAWAG.msl"


# 107 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM3P_EAWAG.msl"



# 58 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1_AN.msl" 1
 



















# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1_AN.msl"



# 59 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1_AN.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASM1_AN.msl"



# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASMG1.msl" 1
 



















# 44 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASMG1.msl"



# 69 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASMG1.msl"


# 90 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsASMG1.msl"



# 62 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions1.msl" 2



# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitions2.msl" 1
 


















  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  

 
 
 

TYPE AnaerobicComponents
  "The biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {H2O_An, S_H2, S_CH4, S_CO2, S_HCO3, S_H, S_NH4, S_AC, S_PRO,
          S_AS, S_FA, S_IN, X_S_An, X_AS, X_FA, X_PRO, X_AC, X_H2, X_IN};

  
  
  
  
  
  
 
 TYPE AnaerobicReactions
  "The anaerobic reactions between biological components considered in the Siegrist anaerobic digestion model"
  = ENUM {
          H2Stripping,
          CH4Stripping,
          CO2Stripping,
          BiopolymHydrol,
          ASFermentation,
          AnOxOfS_FA,
          AnOxOfS_PRO,
          AcToCH4Conv,
          H2ToCH4Conv,
          DecayOfX_AS,
          DecayOfX_FA,
          DecayOfX_PRO,
          DecayOfX_AC,
          DecayOfX_H2,
          ProtolysisOfHCO3,
          DeprotolysisOfCO2,
         };

 
 
 

 OBJ NrOfAnaerobicComponents "The number of anaerobic components considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicComponents);

 OBJ NrOfAnaerobicReactions "The number of anaerobic reactions considered in the anaerobic digestion model"
  : Integer := Cardinality(AnaerobicReactions);

 
 
 
 

 
 CLASS AnaerobicConcentrationVector = Concentration[NrOfAnaerobicComponents;];
 CLASS AnaerobicSpecificVolumeVector = SpecificVolume[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassVector = Mass[NrOfAnaerobicComponents;];
 CLASS AnaerobicMassFluxVector = MassFlux[NrOfAnaerobicComponents;];

 
 
 


# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 1
 


















 CLASS WWTPAtomicModel
 " A generic atomic WWTP model. Only specifies mass balances"
 
 
 
 
 
 
 
 
 SPECIALISES PhysicalDAEModelType :=
 {:
  
  
  parameters <-
   {

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

     
     
     
     
   



     
     
     
     
     
     
     
     
     
     

   };

  initial <-
   {
   
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

  state <-
   {
    OBJ M "Vector containing masses for all the components" : MassVector 
# 105 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl"


   := [{: value <- 1000000000 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 100 :},{: value <- 10 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 10 :},{: value <- 113.33 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :};]





















# 140 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

     
     
     
     
     

    (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
    };

    {state.Q_In = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);
    };

 
 
 

   }; 
 :};

 
 
 

 
 
 

 CLASS WWTPAtomicModelWithoutVolume 
 SPECIALISES PhysicalDAEModelType :=
 {:
  parameters <-
   {
    


   };

  initial <-
   {
    
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

   equations <-
   {
     { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         (In_Terminal[Comp_Index]);
     };

     {state.Q_In = (0.000001
                  * state.InFluxPerComponent[IndexOfSolvent]);
     };

   };
 :};

 
 
 

 CLASS WWTPAtomicModelWithVolume EXTENDS WWTPAtomicModel WITH
 {:

   state <-
    {
      OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
    };

   equations <-
    {
      
      
    };

 :};

 
 
 

 CLASS WWTPAtomicModelWithVariableVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-
   {
     OBJ N "Number of weirs on a tank" : PhysicalQuantityType := 
         {: value <- 100 ; 
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :};
      group <- "Hydraulic" 
         :} ;
     OBJ A (* is_favorite = "1" *) "Surface area of the tank" : Area := {: value <- 200; group <- "Dimension"  :} ;
     OBJ alfa "Parameter, function of the weir type or width" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic"  :};
     OBJ beta "Parameter, depends on the weir design" 
         : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
     OBJ V_Const (* is_favorite = "1" *) "Constant tank volume beneath the lowest point of the weir" 
         : Volume := {: value <- 1900; group <- "Dimension" :};
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
     
     
     
     

    state.Q_Out = IF (state.V > parameters.V_Const)
                THEN
    parameters.N * parameters.alfa 
      * pow((state.V - parameters.V_Const)/parameters.A, parameters.beta)
        ELSE 0;

     
     
     
     

    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (0.000001*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

  
  
  
  
  

 CLASS VarVolumeConversionModel EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 348 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2

 :};
 
  

 CLASS VarVolumeASMConversionModel EXTENDS VarVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 1
 
















  interface <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.interface.msl" 1
 
 
 
 
 


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  state <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.state.msl" 1
 
 
 
 
 


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;

# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  initial <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.stoichiometry.msl" 1
 
 
 
 
 


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  equations <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.kinetics.msl" 1
 
 
 
 
 


	state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);

	state.Kinetics[AerHydrol] = state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] = state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] = state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] = state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] = state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] = state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] = state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] = state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] = state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] = state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] = state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] = state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] = state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] = parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] = parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration]  = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.sensors.msl" 1
 
 
 
 
 


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR =           IF(state.V==0)           THEN 0           ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;

# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2


















# 355 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2

 :};

 
 
 

CLASS WWTPAtomicModelWithPumpedVolume
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Q_Pump (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Desired effluent flow rate" : FlowRate := {: causality <- "CIN" ; value <- 100; group <- "Operational" :} ;
   };

  parameters <-
   {
     OBJ V_Max (* is_favorite = "1" *) "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min (* is_favorite = "1" *) "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
   };

  state <-
   {
     OBJ Q_Out (* is_favorite = "1" *) "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (0.000001*state.M[Comp_Index]);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min && 
                    interface.Q_Pump > state.Q_In) 
                THEN state.Q_In
                ELSE  
                  IF (state.V < parameters.V_Max)
                  THEN interface.Q_Pump
                  ELSE
                    IF (state.Q_In < interface.Q_Pump)
                    THEN interface.Q_Pump
                    ELSE state.Q_In ;    

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
   };
 :};

CLASS PumpedVolumeConversionModel EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 418 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2

 :};

 CLASS PumpedVolumeASMConversionModel EXTENDS PumpedVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 1
 
















  interface <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.interface.msl" 1
 
 
 
 
 


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  state <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.state.msl" 1
 
 
 
 
 


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;

# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  initial <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.stoichiometry.msl" 1
 
 
 
 
 


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  equations <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.kinetics.msl" 1
 
 
 
 
 


	state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);

	state.Kinetics[AerHydrol] = state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] = state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] = state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] = state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] = state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] = state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] = state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] = state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] = state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] = state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] = state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] = state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] = state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] = parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] = parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration]  = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.sensors.msl" 1
 
 
 
 
 


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR =           IF(state.V==0)           THEN 0           ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;

# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2


















# 423 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2


 :};

 
 
 

 CLASS WWTPAtomicModelWithFixedVolume EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };

  parameters <-  
   {
     OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };   
   
  state <-
   {
 
   };

  initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / 0.000001;
  };   
  equations <-
   {
     
     
     
 
      
     
     
     

     
     
	 state.V = state.M[IndexOfSolvent] * 0.000001;

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;
     };

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
   };
 :};

 CLASS FixVolumeConversionModel EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2

 :};
 
 CLASS FixVolumeASMConversionModel EXTENDS FixVolumeConversionModel WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 1
 
















  interface <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.interface.msl" 1
 
 
 
 
 


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  state <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.state.msl" 1
 
 
 
 
 


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;

# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  initial <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.stoichiometry.msl" 1
 
 
 
 
 


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  equations <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.kinetics.msl" 1
 
 
 
 
 


	state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);

	state.Kinetics[AerHydrol] = state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] = state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] = state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] = state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] = state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] = state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] = state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] = state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] = state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] = state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] = state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] = state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] = state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] = parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] = parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration]  = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.sensors.msl" 1
 
 
 
 
 


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR =           IF(state.V==0)           THEN 0           ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;

# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2


















# 492 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.msl" 2

 :};

 

 
 
 

 
 
 

 
 
 
 
 



# 26 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2


 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 1
 


















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.twocombiner.msl" 1
 


















 CLASS TwoCombiner
 (* icon = "two_combiner" ; is_default = "true" *)  
 "two combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of two flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1" :};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * 0.000001;
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * 0.000001;

     {state.Q_Out = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.threecombiner.msl" 1
 


















 CLASS ThreeCombiner
 (* icon = "three_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of three flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * 0.000001;
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * 0.000001;
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * 0.000001;

     {state.Q_Out = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fourcombiner.msl" 1
 


















 CLASS FourCombiner
 (* icon = "four_combiner" ; is_default = "true" *)  
 "Four combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of four flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * 0.000001;
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * 0.000001;
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * 0.000001;
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * 0.000001;

     {state.Q_Out = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.fivecombiner.msl" 1
 














 



 CLASS FiveCombiner
 (* icon = "five_combiner" ; is_default = "true" *)  
 "three combiner"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a combiner of five flows";
  interface <-
   { 
    OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 1":};
    OBJ Inflow2 (* terminal = "in_2" *) "Inflow2" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 2":};
    OBJ Inflow3 (* terminal = "in_3" *) "Inflow3" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 3":};
    OBJ Inflow4 (* terminal = "in_4" *) "Inflow4" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 4":};
    OBJ Inflow5 (* terminal = "in_5" *) "Inflow5" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent 5":};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
   };
  state <-  
  {
    OBJ Q_In1 (* is_favorite = "1" *) "Influent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In2 (* is_favorite = "1" *) "Influent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In3 (* is_favorite = "1" *) "Influent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In4 (* is_favorite = "1" *) "Influent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_In5 (* is_favorite = "1" *) "Influent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index];};   

    state.Q_In1 = interface.Inflow1[IndexOfSolvent] * 0.000001;
    state.Q_In2 = interface.Inflow2[IndexOfSolvent] * 0.000001;
    state.Q_In3 = interface.Inflow3[IndexOfSolvent] * 0.000001;
    state.Q_In4 = interface.Inflow4[IndexOfSolvent] * 0.000001;
    state.Q_In5 = interface.Inflow5[IndexOfSolvent] * 0.000001;

     {state.Q_Out = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);};
   }; 
 :};


# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2


 
 

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.reltwosplitter.msl" 1
 














 



CLASS RelTwoSplitter
 (* icon = "two_fraction_splitter" ; is_default = "true" *)
 "relative splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.9; group <- "Operational" :};
   };
  parameters <-
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * 0.000001;
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * 0.000001;
   }; 
 
 :};


# 29 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relthreesplitter.msl" 1
 














 



 CLASS RelThreeSplitter
 (* icon = "three_fraction_splitter" ; is_default = "true" *)
 "relative three splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.8 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * 0.000001;
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * 0.000001;
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * 0.000001;
   }; 

 :};


# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfoursplitter.msl" 1
 


















 CLASS RelFourSplitter
 (* icon = "four_fraction_splitter" ; is_default = "true" *)
 "relative four splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * 0.000001;
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * 0.000001;
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * 0.000001;
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * 0.000001;
   }; 

 :};
 


# 31 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.relfivesplitter.msl" 1
 


















 CLASS RelFiveSplitter
 (* icon = "five_fraction_splitter" ; is_default = "true" *)
 "relative five splitter"

 
            
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for a relative splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5"  : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ f_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow2" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow3" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow4" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
    OBJ f_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Fraction of the fluxes going to outflow5" : 
     Fraction := {: causality <- "CIN" ; value <- 0.2 ; group <- "Operational" :};
   };
  parameters <- 
   { 
   };
  state <-  
  {
    OBJ Q_Out1 (* is_favorite = "1" *) "Effluent flow rate from flow 1" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out2 (* is_favorite = "1" *) "Effluent flow rate from flow 2" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out3 (* is_favorite = "1" *) "Effluent flow rate from flow 3" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out4 (* is_favorite = "1" *) "Effluent flow rate from flow 4" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out5 (* is_favorite = "1" *) "Effluent flow rate from flow 5" : FlowRate := {: group <- "Operational" :};
  };   
  equations <-
   {
 
 
 

 
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      IF (interface.f_Out2 < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out2)  
    ELSE - state.InFluxPerComponent[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out3)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index];
    };   

     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out4)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index];
   };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      IF ((interface.f_Out2 + interface.f_Out3 + interface.f_Out4 + interface.f_Out5) < 1.0)
    THEN - state.InFluxPerComponent[Comp_Index] * (interface.f_Out5)
    ELSE - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index];
      };   
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
        - state.InFluxPerComponent[Comp_Index] - interface.Outflow2[Comp_Index] - interface.Outflow3[Comp_Index] - interface.Outflow4[Comp_Index] - interface.Outflow5[Comp_Index];
   };  

    state.Q_Out1 = - interface.Outflow1[IndexOfSolvent] * 0.000001;
    state.Q_Out2 = - interface.Outflow2[IndexOfSolvent] * 0.000001;
    state.Q_Out3 = - interface.Outflow3[IndexOfSolvent] * 0.000001;
    state.Q_Out4 = - interface.Outflow4[IndexOfSolvent] * 0.000001;
    state.Q_Out5 = - interface.Outflow5[IndexOfSolvent] * 0.000001;
   }; 

 :};


# 32 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2


 

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.abstwosplitter.msl" 1
 


















 CLASS AbsTwoSplitter
 (* icon = "two_flow_splitter" ; is_default = "true" *)
 "absolute two way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };
  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   
  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
    state.Q_Out1 = IF(interface.Q_Out2 > state.Q_In)
                   THEN 0
                   ELSE state.Q_In - state.Q_Out2_Actual ;

    state.Q_Out2_Actual = IF(interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};

CLASS AbsTwoSplitter_min
 (* icon = "two_flow_splitter" ; is_default = "" *)
 "absolute two way splitter with minimum on out_1"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into two flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
	  OBJ Q_Out1_min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow1 min rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };
  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   
  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
    state.Q_Out1 = IF(interface.Q_Out2 > (state.Q_In - interface.Q_Out1_min))
                   THEN interface.Q_Out1_min
                   ELSE state.Q_In - state.Q_Out2_Actual ;

    state.Q_Out2_Actual = IF(interface.Q_Out2 > (state.Q_In - interface.Q_Out1_min))
                        THEN (state.Q_In - interface.Q_Out1_min)
                        ELSE interface.Q_Out2;

    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out2) ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};



# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absthreesplitter.msl" 1
 


















 CLASS AbsThreeSplitter
 (* icon = "three_flow_splitter" ; is_default = "true" *)
 "absolute three way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into three flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_4" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual);

    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 37 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfoursplitter.msl" 1
 


















 CLASS AbsFourSplitter
 (* icon = "four_flow_splitter" ; is_default = "true" *)
 "absolute four way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into four flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_5" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    
   }; 
 :};


# 38 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\splitter_combiner/wwtp.base.splitters_combiners.absfivesplitter.msl" 1
 


















 CLASS AbsFiveSplitter
 (* icon = "five_flow_splitter" ; is_default = "true" *)
 "absolute five way splitter"

 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  comments <- "A model for an absolute splitter into five flows";
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 1" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 2" :};
    OBJ Outflow3 (* terminal = "out_3" *) "Outflow3" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 3" :};
    OBJ Outflow4 (* terminal = "out_4" *) "Outflow4" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 4" :};
    OBJ Outflow5 (* terminal = "out_5" *) "Outflow5" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent 5" :};
    OBJ Q_Out2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow2 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow3 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow4 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
    OBJ Q_Out5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow5 rate" : 
     FlowRate := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_6" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out1 (* is_favorite = "1" *) "Outflow1 rate" : FlowRate := {: group <- "Operational" :};
    OBJ f_Out1 (* hidden = "1" *) "Fraction of the influent flux going to outflow1" : Fraction ;
    OBJ f_Out2 (* hidden = "1" *) "Fraction of the influent flux going to outflow2" : Fraction ;
    OBJ f_Out3 (* hidden = "1" *) "Fraction of the influent flux going to outflow3" : Fraction ;
    OBJ f_Out4 (* hidden = "1" *) "Fraction of the influent flux going to outflow4" : Fraction ;
    OBJ f_Out5 (* hidden = "1" *) "Fraction of the influent flux going to outflow5" : Fraction ;
    OBJ Q_Out2_Actual (* is_favorite = "1" *) "Help variable for outflow2 rate" : FlowRate ;
    OBJ Q_Out3_Actual (* is_favorite = "1" *) "Help variable for outflow3 rate" : FlowRate ;
    OBJ Q_Out4_Actual (* is_favorite = "1" *) "Help variable for outflow4 rate" : FlowRate ;
    OBJ Q_Out5_Actual (* is_favorite = "1" *) "Help variable for outflow5 rate" : FlowRate ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Out1 = state.Q_In - (state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual);
 
    state.Q_Out2_Actual = IF( interface.Q_Out2 > state.Q_In)
                        THEN state.Q_In
                        ELSE interface.Q_Out2;

    state.Q_Out3_Actual = IF( (interface.Q_Out2+interface.Q_Out3) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual
                        ELSE interface.Q_Out3;

    state.Q_Out4_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual
                        ELSE interface.Q_Out4;

    state.Q_Out5_Actual = IF( (interface.Q_Out2+interface.Q_Out3+interface.Q_Out4+interface.Q_Out5) > state.Q_In)
                        THEN state.Q_In - state.Q_Out2_Actual - state.Q_Out3_Actual - state.Q_Out4_Actual
                        ELSE interface.Q_Out5;
            
    state.f_Out1 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out1 /state.Q_In ;
    state.f_Out2 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out2_Actual /state.Q_In ; 
    state.f_Out3 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out3_Actual / state.Q_In ;
    state.f_Out4 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out4_Actual /state.Q_In ; 
    state.f_Out5 = IF (state.Q_In == 0)
           THEN 0
           ELSE state.Q_Out5_Actual / state.Q_In ;
           
           
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow1[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out1 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow2[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out2 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow3[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out3 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow4[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out4 ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow5[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out5 ;};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out2_Actual + state.Q_Out3_Actual + state.Q_Out4_Actual + state.Q_Out5_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   }; 
 :};


# 39 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.splitters_combiners.msl" 2



# 29 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.buffertanks.msl" 1
 


















CLASS PumpedVolumeBuffer
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithPumpedVolume WITH
 {:
  comments <- "A model for a tank with a variable volume caused by a pump";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
     interface.V_Buffer = state.V;
   };
  initial <-
   {
   };
 :};

CLASS FixVolumeBuffer
 "A class for buffertanks with a fixed volume"
 EXTENDS WWTPAtomicModelWithFixedVolume WITH
 {:
   comments <- "A model for a tank with a fixed volume";

   interface <-
   {
     OBJ V_Buffer  (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

   equations <-
   {
     interface.V_Buffer = state.V;
   };

   initial <-
   {
   };
 :};

CLASS VarVolumeBuffer
 "A class for buffertanks with variable volume"
 EXTENDS WWTPAtomicModelWithVariableVolume WITH
 {:
  comments <- "A model for a  tank with a variable volume caused by a weir";

  interface <-
   {
     OBJ V_Buffer (* terminal = "out_2" *) "Buffertank volume measurement data" : 
       Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   };

  equations <-
   {
    interface.V_Buffer = state.V;
   };

  initial <-
   {
   }; :};
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumestormtank.msl" 1
 














 



CLASS PumpedVolumeStormTank
  (* icon = "storm_tank" ; is_default = "true" *)
  "Model for a storm tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a storm tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *) "Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *) "Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :}; 

CLASS PumpedVolumeBuffer_Eindhoven
 (* icon = "storm_tank" ; category = "default" *)
 "A class for buffertanks with a pumped variable volume"
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	   OBJ Overflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	   OBJ FD (* terminal = "out_2" *) "Filling degree" : 
       Real := {: causality <- "COUT" ; group <- "Measurement data" :};
	   OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Desired effluent flow rate" : 
			 FlowRate := {: causality <- "CIN" :} ;
   };

  parameters <-
   {
     OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
		 OBJ Cd "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Real := {: group <- "Tank characteristics"; value <- 1 :};
	 	OBJ B "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Length := {: group <- "Tank characteristics"; value <- 20 :};
   };

  state <-
   {
     OBJ Q_Out "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
	   OBJ Q_Over "Actual overflow rate" : FlowRate := {: group <- "Operational" :};
	   OBJ Du "Height above weir crest" : Length;
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (0.000001*state.M[Comp_Index]);
	  
	  interface.FD = state.V / parameters.V_Max ;
	  state.Du = (state.V - parameters.V_Max) / (parameters.V_Max);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
				   THEN 0
				   ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min)
                  THEN 0
                  ELSE interface.Q_Pump;   
	  state.Q_Over = IF (state.V <= parameters.V_Max)
                   THEN 0
                   ELSE parameters.Cd * pow(9.81,0.5) * parameters.B * pow(state.Du,1.5) * 3600 * 24;;

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Overflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Over ;};
   };
 :};
 
 CLASS PumpedVolumeBuffer_Eindhoven2
 (* icon = "storm_tank" ; category = "default" *)
 "A class for buffertanks with a pumped variable volume (out = pump or overflow)"
 EXTENDS WWTPAtomicModelWithVolume WITH
 {:
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
	  
    
	   OBJ FD (* terminal = "out_2" *) "Filling degree" : 
       Real := {: causality <- "COUT" ; group <- "Measurement data" :};
	   OBJ Q_Pump (* terminal = "in_2"; manip = "1" *) "Desired effluent flow rate" : 
			 FlowRate := {: causality <- "CIN" :} ;
   };

  parameters <-
   {
     OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Operational" :};
     OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Operational" :}; 
		 OBJ Cd "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Real := {: group <- "Tank characteristics"; value <- 1 :};
	 	OBJ B "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Length := {: group <- "Tank characteristics"; value <- 20 :};
   };

  state <-
   {
     OBJ Q_Out "Actual effluent flow rate" : FlowRate := {: group <- "Operational" :};
	    
	   OBJ Du "Height above weir crest" : Length;
   };

  equations <-
   {
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
    (0.000001*state.M[Comp_Index]);
	  
	  interface.FD = state.V / parameters.V_Max ;
	  state.Du = (state.V - parameters.V_Max) / (parameters.V_Max);

     
     

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
				   THEN 0
				   ELSE state.M[Comp_Index]/state.V;
     };

    state.Q_Out = IF (state.V < parameters.V_Min)
                  THEN 0
                  ELSE IF (state.V <= parameters.V_Max)
                       THEN interface.Q_Pump
                       ELSE parameters.Cd * pow(9.81,0.5) * parameters.B * pow(state.Du,1.5) * 3600 * 24;   

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_Out ;};
		 
     
     
   };
 :};



 
# 84 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\buffertank/wwtp.base.buffertanks.pumpedvolumebuffertank.msl" 1
 


















CLASS PumpedVolumeBufferTank
  (* icon = "buffer_tank" ; is_default = "true" *)
  "Model for a buffer tank"
  SPECIALISES PumpedVolumeBuffer :=
  {:
  comments <- "A model for a buffer tank with a variable volume caused by a pump";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  
  };
  :};  
 



 
# 85 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\buffertank/wwtp.base.buffertanks.fixvolumeequalisationtank.msl" 1
 


















  CLASS FixVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES FixVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 86 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.buffertanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\buffertank/wwtp.base.buffertanks.varvolumeequalisationtank.msl" 1
 


















  CLASS VarVolumeEqualisationTank
  (* icon = "equalisation_tank" ; is_default = "true" *)
  "Model for an equalisation tank"
  SPECIALISES VarVolumeBuffer :=
  {:
  comments <- "A model for an equalisation tank with a fixed volume";
  interface <-
  {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };
  parameters <- 
   {
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in the tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
  
  equations <-
  {
 
  state.ME_Instant = parameters.ME_unit * state.V;    
  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
  };

  :};  



 
# 87 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.buffertanks.msl" 2

 



 
# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.activated_sludge_units.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl" 1
 


















 CLASS FixVolumeASU 
 (* icon = "activated_sludge_unit" ; is_default = "true" *)
 SPECIALISES FixVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a fixed volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   
  
   };   
   parameters <- 
   {
 
  
 
 
  
  
   };
   state <-
   { 





   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;

 













   };   
 :};
	 
	 CLASS reaeration_tank 
 (* icon = "activated_sludge_unit" ; is_default = "" *)
 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "Model for an effluent reaeration unit with a fixed volume";
		 
		   independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };

   interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
       OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		 OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

		 OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
		 OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
		 OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
   };
		 
   parameters <- 
   {
		 OBJ Vol (* is_favorite = "1" *) "Volume of the tank" : Volume := {: value <- 1000; group <- "Dimension" :};
   };
   state <-
   {
		 OBJ M "Vector containing masses for all the components" : MassVector 
# 125 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl"


   := [{: value <- 1000000000 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 100 :},{: value <- 10 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 10 :},{: value <- 113.33 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :};]





















# 160 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.fixvolumeasu.msl"

;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": MassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": MassFluxVector;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		 
		 OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :};
		 OBJ S_O_Saturation "Oxygen saturation concentration"
  : Concentration := {: group <- "Kinetic" :}; 
		 		 
		  OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Dimension" :};
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
		 
		   };

initial <-  
  {
  state.M[IndexOfSolvent] = parameters.Vol / 0.000001;
  };   
		 
   equations <- 
   {
		  {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
		 
		 (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
    In_Terminal[Comp_Index])+
    (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
    Out_Terminal[Comp_Index]);};
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
    };

    {state.Q_In = (0.000001 
                  * state.InFluxPerComponent[IndexOfSolvent]);
    };
		 
		 state.V = state.M[IndexOfSolvent] * 0.000001;
		 
		 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
           THEN 0
           ELSE state.M[Comp_Index]/state.V;};

   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.C[Comp_Index] * state.Q_In ;};
		 
		 state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;

		 state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
    state.ConversionTermPerComponent[S_O] = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]) * state.V;
		 
		 interface.DO = state.C[S_O];
		 interface.TSS = state.C[X_TSS];
		 interface.V_ASU = state.V;
   };   
 :};
	


# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.pumpedvolumeasu.msl" 1
 


















 CLASS PumpedVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES PumpedVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable pumped volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };   
 :};



# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.activated_sludge_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.base.activated_sludge_units.varvolumeasu.msl" 1
 


















 CLASS VarVolumeASU 
 (* icon = "activated_sludge_unit" *)
 SPECIALISES VarVolumeASMConversionModel :=
 {:
   comments <- "Model for an activated sludge unit with a variable volume";
   interface <-  
   {
     OBJ Kla (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };   
   parameters <- 
   {
 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
   };
   state <-
   {
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
   };
   initial <-
   {
   };
   equations <- 
   {
    state.Kla_Actual = interface.Kla;

    state.Temp_Actual = interface.Temp;


 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.OTR_Energy) * state.Integ_AE ;

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
   };   
 :};



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.activated_sludge_units.msl" 2




# 31 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 1
 


















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 1
 


















CLASS  FixVolumeTwoTank
SPECIALISES CoupledModelType :=
{:
 interface <-
 {
  OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :},
  OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent" :},

  OBJ Temp (* terminal = "in_2"; manip = "1" *) "Temperature of the activated sludge" : CelsiusTemperature := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  OBJ Kla1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU1" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ Kla2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU2" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy1 (* terminal = "out_2" *)"Aeration energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy1 (* terminal = "out_2" *)"Mixing energy for ASU1" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ AerationEnergy2 (* terminal = "out_2" *)"Aeration energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy2 (* terminal = "out_2" *)"Mixing energy for ASU2" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  


   
    OBJ DO_ASU1 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU1" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU1 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU1 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU1 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU1 (* terminal = "out_2" *)"Total suspended solids concentration in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU1 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU1 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU1 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU1 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU1 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 1" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU1 (* terminal = "out_2" *)"Volume measurement data in ASU1" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU1 (* terminal = "out_2" *)"OUR measurement data in ASU1" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU1 (* terminal = "out_2" *)"NUR measurement data in ASU1" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU1 (* terminal = "out_2" *)"NPR measurement data in ASU1" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU1 (* terminal = "out_2" *)"AUR measurement data in ASU1" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU1 (* terminal = "out_2" *)"PUR measurement data in ASU1" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU1 (* terminal = "out_2" *)"Kla measurement data in ASU1" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};
 
    OBJ DO_ASU2 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU2" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU2 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU2 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU2 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU2 (* terminal = "out_2" *)"Total suspended solids concentration in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU2 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU2 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU2 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU2 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU2 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 2" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU2 (* terminal = "out_2" *)"Volume measurement data in ASU2" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU2 (* terminal = "out_2" *)"OUR measurement data in ASU2" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU2 (* terminal = "out_2" *)"NUR measurement data in ASU2" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU2 (* terminal = "out_2" *)"NPR measurement data in ASU2" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU2 (* terminal = "out_2" *)"AUR measurement data in ASU2" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU2 (* terminal = "out_2" *)"PUR measurement data in ASU2" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU2 (* terminal = "out_2" *)"Kla measurement data in ASU2" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 37 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2


 };

 parameters <-
 {
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.parameters.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.parameters.msl" 2










# 43 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

  OBJ Vol1 (* is_favorite = "1" *) "Volume of ASU1" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  OBJ Vol2 (* is_favorite = "1" *) "Volume of ASU2" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
 };

 sub_models <-
 {
  OBJ ASU1 : FixVolumeASU,
  OBJ ASU2 : FixVolumeASU,
 };

 coupling <-
 {
   
  sub_models.ASU1.parameters.Vol.value := parameters.Vol1.value,
  sub_models.ASU2.parameters.Vol.value := parameters.Vol2.value,


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 


  connect(sub_models.ASU1.interface.DO, interface.DO_ASU1),
  connect(sub_models.ASU2.interface.DO, interface.DO_ASU2),
  connect(sub_models.ASU1.interface.NH4, interface.NH4_ASU1),
  connect(sub_models.ASU2.interface.NH4, interface.NH4_ASU2),
  connect(sub_models.ASU1.interface.NO3, interface.NO3_ASU1),
  connect(sub_models.ASU2.interface.NO3, interface.NO3_ASU2),
  connect(sub_models.ASU1.interface.TSS, interface.TSS_ASU1),
  connect(sub_models.ASU2.interface.TSS, interface.TSS_ASU2),
  connect(sub_models.ASU1.interface.OnlineCOD, interface.OnlineCOD_ASU1),
  connect(sub_models.ASU2.interface.OnlineCOD, interface.OnlineCOD_ASU2),
  connect(sub_models.ASU1.interface.OfflineBOD, interface.OfflineBOD_ASU1),
  connect(sub_models.ASU2.interface.OfflineBOD, interface.OfflineBOD_ASU2),
  connect(sub_models.ASU1.interface.OnlineTN, interface.OnlineTN_ASU1),
  connect(sub_models.ASU2.interface.OnlineTN, interface.OnlineTN_ASU2),
  connect(sub_models.ASU1.interface.OfflineTKN, interface.OfflineTKN_ASU1),
  connect(sub_models.ASU2.interface.OfflineTKN, interface.OfflineTKN_ASU2),
  connect(sub_models.ASU1.interface.OnlineTP, interface.OnlineTP_ASU1),
  connect(sub_models.ASU2.interface.OnlineTP, interface.OnlineTP_ASU2),
  connect(sub_models.ASU1.interface.PO4, interface.PO4_ASU1),
  connect(sub_models.ASU2.interface.PO4, interface.PO4_ASU2),
  connect(sub_models.ASU1.interface.V_ASU, interface.V_ASU1),
  connect(sub_models.ASU2.interface.V_ASU, interface.V_ASU2),
  connect(sub_models.ASU1.interface.OUR_ASU, interface.OUR_ASU1),
  connect(sub_models.ASU2.interface.OUR_ASU, interface.OUR_ASU2),
  connect(sub_models.ASU1.interface.NUR, interface.NUR_ASU1),
  connect(sub_models.ASU2.interface.NUR, interface.NUR_ASU2),
  connect(sub_models.ASU1.interface.NPR, interface.NPR_ASU1),
  connect(sub_models.ASU2.interface.NPR, interface.NPR_ASU2),
  connect(sub_models.ASU1.interface.AUR, interface.AUR_ASU1),
  connect(sub_models.ASU2.interface.AUR, interface.AUR_ASU2),
  connect(sub_models.ASU1.interface.PUR, interface.PUR_ASU1),
  connect(sub_models.ASU2.interface.PUR, interface.PUR_ASU2),
  connect(sub_models.ASU1.interface.Kla_ASU, interface.Kla_ASU1),
  connect(sub_models.ASU2.interface.Kla_ASU, interface.Kla_ASU2),



# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 62 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetwotank.msl" 2




  sub_models.ASU1.parameters.Temp_Ref.value := parameters.Temp_Ref.value,
  sub_models.ASU2.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   
  connect(interface.Inflow, sub_models.ASU1.interface.Inflow),
  connect(sub_models.ASU1.interface.Outflow, sub_models.ASU2.interface.Inflow),
  connect(interface.Kla1, sub_models.ASU1.interface.Kla),
  connect(interface.Kla2, sub_models.ASU2.interface.Kla),
  connect(sub_models.ASU1.interface.AerationEnergy, interface.AerationEnergy1),
  connect(sub_models.ASU2.interface.AerationEnergy, interface.AerationEnergy2),
  connect(sub_models.ASU1.interface.MixingEnergy, interface.MixingEnergy1),
  connect(sub_models.ASU2.interface.MixingEnergy, interface.MixingEnergy2),

  connect(interface.Temp, sub_models.ASU1.interface.Temp),
  connect(interface.Temp, sub_models.ASU2.interface.Temp),

 };
:};



# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutwotank.msl" 1
 


















CLASS  FixVolumeASUTwoTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTwoTank:=
{:
 comments <- "A coupled model for two activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU2.interface.Outflow, interface.Outflow),
 };
:};



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 1
 


















CLASS  FixVolumeThreeTank
EXTENDS FixVolumeTwoTank WITH
{:

 sub_models <-
 {

  OBJ ASU3 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU3" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy3 (* terminal = "out_2" *)"Aeration energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy3 (* terminal = "out_2" *)"Mixing energy for ASU3" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU3 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU3" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU3 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU3 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU3 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU3 (* terminal = "out_2" *)"Total suspended solids concentration in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU3 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU3 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU3 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU3 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU3 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 3" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU3 (* terminal = "out_2" *)"Volume measurement data in ASU3" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU3 (* terminal = "out_2" *)"OUR measurement data in ASU3" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU3 (* terminal = "out_2" *)"NUR measurement data in ASU3" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU3 (* terminal = "out_2" *)"NPR measurement data in ASU3" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU3 (* terminal = "out_2" *)"AUR measurement data in ASU3" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU3 (* terminal = "out_2" *)"PUR measurement data in ASU3" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU3 (* terminal = "out_2" *)"Kla measurement data in ASU3" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol3 (* is_favorite = "1" *) "Volume of ASU3" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU3.parameters.Vol.value := parameters.Vol3.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU3.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU3.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU3.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU3.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU3.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU3.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU3.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU3.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU3.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU3.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU3.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU3.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU3.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU3.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU3.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU3.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU3.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU3.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU3.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU3.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU3.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU3.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU3.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU3.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU3.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU3.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU3.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU3.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU3.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU3.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU3.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU3.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU3.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU3.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU3.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU3.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU3.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU3.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU3.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU3.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU3.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU3.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU3.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU3.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU3.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU3.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU3.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU3.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU3.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU3.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU3.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU3.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU3.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU3.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU3.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU3.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU3.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU3.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU3.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU3.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU3.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU3.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU3.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU3.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU3.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU3.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU3.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU3.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU3.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU3.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU3.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU3.interface.DO, interface.DO_ASU3),
  connect(sub_models.ASU3.interface.NH4, interface.NH4_ASU3),
  connect(sub_models.ASU3.interface.NO3, interface.NO3_ASU3),
  connect(sub_models.ASU3.interface.TSS, interface.TSS_ASU3),
  connect(sub_models.ASU3.interface.OnlineCOD, interface.OnlineCOD_ASU3),
  connect(sub_models.ASU3.interface.OfflineBOD, interface.OfflineBOD_ASU3),
  connect(sub_models.ASU3.interface.OnlineTN, interface.OnlineTN_ASU3),
  connect(sub_models.ASU3.interface.OfflineTKN, interface.OfflineTKN_ASU3),
  connect(sub_models.ASU3.interface.OnlineTP, interface.OnlineTP_ASU3),
  connect(sub_models.ASU3.interface.PO4, interface.PO4_ASU3),
  connect(sub_models.ASU3.interface.V_ASU, interface.V_ASU3),
  connect(sub_models.ASU3.interface.OUR_ASU, interface.OUR_ASU3),
  connect(sub_models.ASU3.interface.NUR, interface.NUR_ASU3),
  connect(sub_models.ASU3.interface.NPR, interface.NPR_ASU3),
  connect(sub_models.ASU3.interface.AUR, interface.AUR_ASU3),
  connect(sub_models.ASU3.interface.PUR, interface.PUR_ASU3),
  connect(sub_models.ASU3.interface.Kla_ASU, interface.Kla_ASU3),


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumethreetank.msl" 2

 


  sub_models.ASU3.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU2.interface.Outflow, sub_models.ASU3.interface.Inflow),
  connect(interface.Kla3, sub_models.ASU3.interface.Kla),
  connect(sub_models.ASU3.interface.AerationEnergy, interface.AerationEnergy3),
  connect(sub_models.ASU3.interface.MixingEnergy, interface.MixingEnergy3),

  connect(interface.Temp, sub_models.ASU3.interface.Temp),


 };
:};



# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuthreetank.msl" 1
 


















CLASS  FixVolumeASUThreeTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeThreeTank:=
{:
 comments <- "A coupled model for three activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU3.interface.Outflow, interface.Outflow),
 };
:};



# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 1
 


















CLASS  FixVolumeFourTank
EXTENDS FixVolumeThreeTank WITH
{:

 sub_models <-
 {

  OBJ ASU4 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU4" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy4 (* terminal = "out_2" *)"Aeration energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy4 (* terminal = "out_2" *)"Mixing energy for ASU4" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU4 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU4" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU4 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU4 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU4 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU4 (* terminal = "out_2" *)"Total suspended solids concentration in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU4 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU4 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU4 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU4 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU4 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 4" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU4 (* terminal = "out_2" *)"Volume measurement data in ASU4" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU4 (* terminal = "out_2" *)"OUR measurement data in ASU4" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU4 (* terminal = "out_2" *)"NUR measurement data in ASU4" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU4 (* terminal = "out_2" *)"NPR measurement data in ASU4" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU4 (* terminal = "out_2" *)"AUR measurement data in ASU4" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU4 (* terminal = "out_2" *)"PUR measurement data in ASU4" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU4 (* terminal = "out_2" *)"Kla measurement data in ASU4" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol4 (* is_favorite = "1" *) "Volume of ASU4" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU4.parameters.Vol.value := parameters.Vol4.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU4.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU4.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU4.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU4.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU4.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU4.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU4.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU4.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU4.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU4.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU4.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU4.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU4.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU4.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU4.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU4.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU4.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU4.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU4.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU4.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU4.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU4.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU4.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU4.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU4.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU4.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU4.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU4.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU4.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU4.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU4.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU4.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU4.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU4.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU4.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU4.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU4.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU4.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU4.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU4.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU4.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU4.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU4.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU4.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU4.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU4.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU4.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU4.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU4.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU4.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU4.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU4.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU4.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU4.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU4.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU4.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU4.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU4.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU4.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU4.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU4.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU4.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU4.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU4.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU4.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU4.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU4.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU4.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU4.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU4.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU4.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU4.interface.DO, interface.DO_ASU4),
  connect(sub_models.ASU4.interface.NH4, interface.NH4_ASU4),
  connect(sub_models.ASU4.interface.NO3, interface.NO3_ASU4),
  connect(sub_models.ASU4.interface.TSS, interface.TSS_ASU4),
  connect(sub_models.ASU4.interface.OnlineCOD, interface.OnlineCOD_ASU4),
  connect(sub_models.ASU4.interface.OfflineBOD, interface.OfflineBOD_ASU4),
  connect(sub_models.ASU4.interface.OnlineTN, interface.OnlineTN_ASU4),
  connect(sub_models.ASU4.interface.OfflineTKN, interface.OfflineTKN_ASU4),
  connect(sub_models.ASU4.interface.OnlineTP, interface.OnlineTP_ASU4),
  connect(sub_models.ASU4.interface.PO4, interface.PO4_ASU4),
  connect(sub_models.ASU4.interface.V_ASU, interface.V_ASU4),
  connect(sub_models.ASU4.interface.OUR_ASU, interface.OUR_ASU4),
  connect(sub_models.ASU4.interface.NUR, interface.NUR_ASU4),
  connect(sub_models.ASU4.interface.NPR, interface.NPR_ASU4),
  connect(sub_models.ASU4.interface.AUR, interface.AUR_ASU4),
  connect(sub_models.ASU4.interface.PUR, interface.PUR_ASU4),
  connect(sub_models.ASU4.interface.Kla_ASU, interface.Kla_ASU4),


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefourtank.msl" 2

 


  sub_models.ASU4.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU3.interface.Outflow, sub_models.ASU4.interface.Inflow),
  connect(interface.Kla4, sub_models.ASU4.interface.Kla),
  connect(sub_models.ASU4.interface.AerationEnergy, interface.AerationEnergy4),
  connect(sub_models.ASU4.interface.MixingEnergy, interface.MixingEnergy4),

  connect(interface.Temp, sub_models.ASU4.interface.Temp),


 };
:};



# 27 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufourtank.msl" 1
 


















CLASS  FixVolumeASUFourTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFourTank:=
{:
 comments <- "A coupled model for four activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU4.interface.Outflow, interface.Outflow),
 };
:};



# 28 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 1
 


















CLASS  FixVolumeFiveTank
EXTENDS FixVolumeFourTank WITH
{:

 sub_models <-
 {

  OBJ ASU5 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU5" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy5 (* terminal = "out_2" *)"Aeration energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy5 (* terminal = "out_2" *)"Mixing energy for ASU5" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU5 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU5" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU5 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU5 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU5 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU5 (* terminal = "out_2" *)"Total suspended solids concentration in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU5 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU5 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU5 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU5 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU5 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 5" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU5 (* terminal = "out_2" *)"Volume measurement data in ASU5" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU5 (* terminal = "out_2" *)"OUR measurement data in ASU5" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU5 (* terminal = "out_2" *)"NUR measurement data in ASU5" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU5 (* terminal = "out_2" *)"NPR measurement data in ASU5" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU5 (* terminal = "out_2" *)"AUR measurement data in ASU5" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU5 (* terminal = "out_2" *)"PUR measurement data in ASU5" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU5 (* terminal = "out_2" *)"Kla measurement data in ASU5" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol5 (* is_favorite = "1" *) "Volume of ASU5" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 

 coupling <-
 {
   
  sub_models.ASU5.parameters.Vol.value := parameters.Vol5.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU5.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU5.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU5.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU5.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU5.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU5.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU5.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU5.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU5.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU5.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU5.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU5.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU5.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU5.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU5.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU5.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU5.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU5.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU5.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU5.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU5.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU5.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU5.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU5.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU5.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU5.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU5.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU5.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU5.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU5.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU5.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU5.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU5.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU5.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU5.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU5.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU5.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU5.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU5.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU5.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU5.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU5.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU5.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU5.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU5.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU5.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU5.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU5.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU5.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU5.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU5.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU5.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU5.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU5.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU5.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU5.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU5.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU5.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU5.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU5.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU5.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU5.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU5.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU5.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU5.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU5.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU5.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU5.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU5.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU5.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU5.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU5.interface.DO, interface.DO_ASU5),
  connect(sub_models.ASU5.interface.NH4, interface.NH4_ASU5),
  connect(sub_models.ASU5.interface.NO3, interface.NO3_ASU5),
  connect(sub_models.ASU5.interface.TSS, interface.TSS_ASU5),
  connect(sub_models.ASU5.interface.OnlineCOD, interface.OnlineCOD_ASU5),
  connect(sub_models.ASU5.interface.OfflineBOD, interface.OfflineBOD_ASU5),
  connect(sub_models.ASU5.interface.OnlineTN, interface.OnlineTN_ASU5),
  connect(sub_models.ASU5.interface.OfflineTKN, interface.OfflineTKN_ASU5),
  connect(sub_models.ASU5.interface.OnlineTP, interface.OnlineTP_ASU5),
  connect(sub_models.ASU5.interface.PO4, interface.PO4_ASU5),
  connect(sub_models.ASU5.interface.V_ASU, interface.V_ASU5),
  connect(sub_models.ASU5.interface.OUR_ASU, interface.OUR_ASU5),
  connect(sub_models.ASU5.interface.NUR, interface.NUR_ASU5),
  connect(sub_models.ASU5.interface.NPR, interface.NPR_ASU5),
  connect(sub_models.ASU5.interface.AUR, interface.AUR_ASU5),
  connect(sub_models.ASU5.interface.PUR, interface.PUR_ASU5),
  connect(sub_models.ASU5.interface.Kla_ASU, interface.Kla_ASU5),


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumefivetank.msl" 2

 


  sub_models.ASU5.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU4.interface.Outflow, sub_models.ASU5.interface.Inflow),
  connect(interface.Kla5, sub_models.ASU5.interface.Kla),
  connect(sub_models.ASU5.interface.AerationEnergy, interface.AerationEnergy5),
  connect(sub_models.ASU5.interface.MixingEnergy, interface.MixingEnergy5),

  connect(interface.Temp, sub_models.ASU5.interface.Temp),


 };
:};



# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasufivetank.msl" 1
 


















CLASS  FixVolumeASUFiveTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeFiveTank:=
{:
 comments <- "A coupled model for five activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU5.interface.Outflow, interface.Outflow),
 };
:};



# 31 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 1
 


















CLASS  FixVolumeSixTank
EXTENDS FixVolumeFiveTank WITH
{:

 sub_models <-
 {

  OBJ ASU6 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU6" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy6 (* terminal = "out_2" *)"Aeration energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy6 (* terminal = "out_2" *)"Mixing energy for ASU6" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU6 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU6" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU6 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU6 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU6 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU6 (* terminal = "out_2" *)"Total suspended solids concentration in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU6 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU6 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU6 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU6 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU6 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 6" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU6 (* terminal = "out_2" *)"Volume measurement data in ASU6" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU6 (* terminal = "out_2" *)"OUR measurement data in ASU6" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU6 (* terminal = "out_2" *)"NUR measurement data in ASU6" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU6 (* terminal = "out_2" *)"NPR measurement data in ASU6" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU6 (* terminal = "out_2" *)"AUR measurement data in ASU6" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU6 (* terminal = "out_2" *)"PUR measurement data in ASU6" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU6 (* terminal = "out_2" *)"Kla measurement data in ASU6" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol6 (* is_favorite = "1" *) "Volume of ASU6" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU6.parameters.Vol.value := parameters.Vol6.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU6.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU6.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU6.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU6.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU6.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU6.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU6.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU6.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU6.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU6.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU6.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU6.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU6.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU6.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU6.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU6.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU6.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU6.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU6.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU6.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU6.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU6.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU6.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU6.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU6.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU6.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU6.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU6.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU6.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU6.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU6.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU6.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU6.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU6.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU6.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU6.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU6.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU6.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU6.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU6.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU6.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU6.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU6.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU6.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU6.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU6.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU6.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU6.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU6.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU6.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU6.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU6.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU6.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU6.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU6.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU6.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU6.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU6.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU6.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU6.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU6.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU6.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU6.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU6.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU6.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU6.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU6.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU6.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU6.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU6.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU6.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU6.interface.DO, interface.DO_ASU6),
  connect(sub_models.ASU6.interface.NH4, interface.NH4_ASU6),
  connect(sub_models.ASU6.interface.NO3, interface.NO3_ASU6),
  connect(sub_models.ASU6.interface.TSS, interface.TSS_ASU6),
  connect(sub_models.ASU6.interface.OnlineCOD, interface.OnlineCOD_ASU6),
  connect(sub_models.ASU6.interface.OfflineBOD, interface.OfflineBOD_ASU6),
  connect(sub_models.ASU6.interface.OnlineTN, interface.OnlineTN_ASU6),
  connect(sub_models.ASU6.interface.OfflineTKN, interface.OfflineTKN_ASU6),
  connect(sub_models.ASU6.interface.OnlineTP, interface.OnlineTP_ASU6),
  connect(sub_models.ASU6.interface.PO4, interface.PO4_ASU6),
  connect(sub_models.ASU6.interface.V_ASU, interface.V_ASU6),
  connect(sub_models.ASU6.interface.OUR_ASU, interface.OUR_ASU6),
  connect(sub_models.ASU6.interface.NUR, interface.NUR_ASU6),
  connect(sub_models.ASU6.interface.NPR, interface.NPR_ASU6),
  connect(sub_models.ASU6.interface.AUR, interface.AUR_ASU6),
  connect(sub_models.ASU6.interface.PUR, interface.PUR_ASU6),
  connect(sub_models.ASU6.interface.Kla_ASU, interface.Kla_ASU6),


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumesixtank.msl" 2

 


  sub_models.ASU6.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU5.interface.Outflow, sub_models.ASU6.interface.Inflow),
  connect(interface.Kla6, sub_models.ASU6.interface.Kla),
  connect(sub_models.ASU6.interface.AerationEnergy, interface.AerationEnergy6),
  connect(sub_models.ASU6.interface.MixingEnergy, interface.MixingEnergy6),

  connect(interface.Temp, sub_models.ASU6.interface.Temp),


 };
:};



# 33 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasusixtank.msl" 1
 


















CLASS  FixVolumeASUSixTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSixTank:=
{:
 comments <- "A coupled model for six activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU6.interface.Outflow, interface.Outflow),
 };
:};



# 34 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 1
 


















CLASS  FixVolumeSevenTank
EXTENDS FixVolumeSixTank WITH
{:

 sub_models <-
 {

  OBJ ASU7 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU7" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy7 (* terminal = "out_2" *)"Aeration energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy7 (* terminal = "out_2" *)"Mixing energy for ASU7" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU7 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU7" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU7 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU7 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU7 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU7 (* terminal = "out_2" *)"Total suspended solids concentration in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU7 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU7 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU7 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU7 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU7 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 7" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU7 (* terminal = "out_2" *)"Volume measurement data in ASU7" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU7 (* terminal = "out_2" *)"OUR measurement data in ASU7" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU7 (* terminal = "out_2" *)"NUR measurement data in ASU7" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU7 (* terminal = "out_2" *)"NPR measurement data in ASU7" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU7 (* terminal = "out_2" *)"AUR measurement data in ASU7" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU7 (* terminal = "out_2" *)"PUR measurement data in ASU7" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU7 (* terminal = "out_2" *)"Kla measurement data in ASU7" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol7 (* is_favorite = "1" *) "Volume of ASU7" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU7.parameters.Vol.value := parameters.Vol7.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU7.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU7.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU7.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU7.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU7.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU7.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU7.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU7.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU7.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU7.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU7.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU7.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU7.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU7.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU7.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU7.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU7.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU7.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU7.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU7.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU7.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU7.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU7.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU7.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU7.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU7.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU7.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU7.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU7.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU7.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU7.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU7.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU7.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU7.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU7.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU7.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU7.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU7.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU7.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU7.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU7.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU7.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU7.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU7.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU7.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU7.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU7.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU7.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU7.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU7.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU7.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU7.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU7.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU7.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU7.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU7.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU7.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU7.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU7.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU7.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU7.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU7.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU7.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU7.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU7.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU7.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU7.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU7.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU7.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU7.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU7.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU7.interface.DO, interface.DO_ASU7),
  connect(sub_models.ASU7.interface.NH4, interface.NH4_ASU7),
  connect(sub_models.ASU7.interface.NO3, interface.NO3_ASU7),
  connect(sub_models.ASU7.interface.TSS, interface.TSS_ASU7),
  connect(sub_models.ASU7.interface.OnlineCOD, interface.OnlineCOD_ASU7),
  connect(sub_models.ASU7.interface.OfflineBOD, interface.OfflineBOD_ASU7),
  connect(sub_models.ASU7.interface.OnlineTN, interface.OnlineTN_ASU7),
  connect(sub_models.ASU7.interface.OfflineTKN, interface.OfflineTKN_ASU7),
  connect(sub_models.ASU7.interface.OnlineTP, interface.OnlineTP_ASU7),
  connect(sub_models.ASU7.interface.PO4, interface.PO4_ASU7),
  connect(sub_models.ASU7.interface.V_ASU, interface.V_ASU7),
  connect(sub_models.ASU7.interface.OUR_ASU, interface.OUR_ASU7),
  connect(sub_models.ASU7.interface.NUR, interface.NUR_ASU7),
  connect(sub_models.ASU7.interface.NPR, interface.NPR_ASU7),
  connect(sub_models.ASU7.interface.AUR, interface.AUR_ASU7),
  connect(sub_models.ASU7.interface.PUR, interface.PUR_ASU7),
  connect(sub_models.ASU7.interface.Kla_ASU, interface.Kla_ASU7),


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeseventank.msl" 2

 


  sub_models.ASU7.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU6.interface.Outflow, sub_models.ASU7.interface.Inflow),
  connect(interface.Kla7, sub_models.ASU7.interface.Kla),
  connect(sub_models.ASU7.interface.AerationEnergy, interface.AerationEnergy7),
  connect(sub_models.ASU7.interface.MixingEnergy, interface.MixingEnergy7),

  connect(interface.Temp, sub_models.ASU7.interface.Temp),


 };
:};



# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuseventank.msl" 1
 


















CLASS  FixVolumeASUSevenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeSevenTank:=
{:
 comments <- "A coupled model for seven activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU7.interface.Outflow, interface.Outflow),
 };
:};



# 37 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 1
 


















CLASS  FixVolumeEightTank
EXTENDS FixVolumeSevenTank WITH
{:

 sub_models <-
 {

  OBJ ASU8 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU8" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy8 (* terminal = "out_2" *)"Aeration energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy8 (* terminal = "out_2" *)"Mixing energy for ASU8" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU8 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU8" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU8 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU8 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU8 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU8 (* terminal = "out_2" *)"Total suspended solids concentration in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU8 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU8 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU8 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU8 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU8 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 8" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU8 (* terminal = "out_2" *)"Volume measurement data in ASU8" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU8 (* terminal = "out_2" *)"OUR measurement data in ASU8" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU8 (* terminal = "out_2" *)"NUR measurement data in ASU8" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU8 (* terminal = "out_2" *)"NPR measurement data in ASU8" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU8 (* terminal = "out_2" *)"AUR measurement data in ASU8" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU8 (* terminal = "out_2" *)"PUR measurement data in ASU8" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU8 (* terminal = "out_2" *)"Kla measurement data in ASU8" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol8 (* is_favorite = "1" *) "Volume of ASU8" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU8.parameters.Vol.value := parameters.Vol8.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU8.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU8.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU8.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU8.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU8.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU8.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU8.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU8.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU8.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU8.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU8.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU8.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU8.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU8.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU8.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU8.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU8.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU8.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU8.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU8.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU8.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU8.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU8.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU8.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU8.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU8.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU8.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU8.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU8.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU8.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU8.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU8.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU8.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU8.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU8.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU8.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU8.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU8.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU8.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU8.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU8.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU8.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU8.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU8.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU8.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU8.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU8.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU8.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU8.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU8.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU8.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU8.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU8.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU8.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU8.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU8.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU8.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU8.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU8.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU8.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU8.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU8.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU8.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU8.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU8.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU8.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU8.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU8.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU8.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU8.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU8.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU8.interface.DO, interface.DO_ASU8),
  connect(sub_models.ASU8.interface.NH4, interface.NH4_ASU8),
  connect(sub_models.ASU8.interface.NO3, interface.NO3_ASU8),
  connect(sub_models.ASU8.interface.TSS, interface.TSS_ASU8),
  connect(sub_models.ASU8.interface.OnlineCOD, interface.OnlineCOD_ASU8),
  connect(sub_models.ASU8.interface.OfflineBOD, interface.OfflineBOD_ASU8),
  connect(sub_models.ASU8.interface.OnlineTN, interface.OnlineTN_ASU8),
  connect(sub_models.ASU8.interface.OfflineTKN, interface.OfflineTKN_ASU8),
  connect(sub_models.ASU8.interface.OnlineTP, interface.OnlineTP_ASU8),
  connect(sub_models.ASU8.interface.PO4, interface.PO4_ASU8),
  connect(sub_models.ASU8.interface.V_ASU, interface.V_ASU8),
  connect(sub_models.ASU8.interface.OUR_ASU, interface.OUR_ASU8),
  connect(sub_models.ASU8.interface.NUR, interface.NUR_ASU8),
  connect(sub_models.ASU8.interface.NPR, interface.NPR_ASU8),
  connect(sub_models.ASU8.interface.AUR, interface.AUR_ASU8),
  connect(sub_models.ASU8.interface.PUR, interface.PUR_ASU8),
  connect(sub_models.ASU8.interface.Kla_ASU, interface.Kla_ASU8),


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeeighttank.msl" 2

 


  sub_models.ASU8.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU7.interface.Outflow, sub_models.ASU8.interface.Inflow),
  connect(interface.Kla8, sub_models.ASU8.interface.Kla),
  connect(sub_models.ASU8.interface.AerationEnergy, interface.AerationEnergy8),
  connect(sub_models.ASU8.interface.MixingEnergy, interface.MixingEnergy8),

  connect(interface.Temp, sub_models.ASU8.interface.Temp),


 };
:};



# 39 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasueighttank.msl" 1
 


















CLASS  FixVolumeASUEightTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeEightTank:=
{:
 comments <- "A coupled model for eight activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU8.interface.Outflow, interface.Outflow),
 };
:};



# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 1
 


















CLASS  FixVolumeNineTank
EXTENDS FixVolumeEightTank WITH
{:

 sub_models <-
 {

  OBJ ASU9 : FixVolumeASU,
 };

 interface <-
 {
  OBJ Kla9 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU9" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy9 (* terminal = "out_2" *)"Aeration energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy9 (* terminal = "out_2" *)"Mixing energy for ASU9" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU9 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU9" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU9 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU9 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU9 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU9 (* terminal = "out_2" *)"Total suspended solids concentration in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU9 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU9 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU9 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU9 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU9 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 9" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU9 (* terminal = "out_2" *)"Volume measurement data in ASU9" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU9 (* terminal = "out_2" *)"OUR measurement data in ASU9" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU9 (* terminal = "out_2" *)"NUR measurement data in ASU9" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU9 (* terminal = "out_2" *)"NPR measurement data in ASU9" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU9 (* terminal = "out_2" *)"AUR measurement data in ASU9" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU9 (* terminal = "out_2" *)"PUR measurement data in ASU9" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU9 (* terminal = "out_2" *)"Kla measurement data in ASU9" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};


# 225 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2


 };

 parameters <-  
 {
  OBJ Vol9 (* is_favorite = "1" *) "Volume of ASU9" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 coupling <-
 {
   
  sub_models.ASU9.parameters.Vol.value := parameters.Vol9.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU9.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU9.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU9.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU9.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU9.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU9.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU9.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU9.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU9.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU9.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU9.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU9.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU9.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU9.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU9.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU9.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU9.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU9.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU9.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU9.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU9.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU9.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU9.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU9.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU9.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU9.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU9.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU9.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU9.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU9.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU9.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU9.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU9.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU9.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU9.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU9.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU9.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU9.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU9.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU9.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU9.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU9.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU9.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU9.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU9.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU9.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU9.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU9.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU9.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU9.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU9.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU9.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU9.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU9.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU9.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU9.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU9.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU9.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU9.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU9.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU9.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU9.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU9.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU9.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU9.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU9.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU9.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU9.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU9.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU9.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU9.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,




# 807 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU9.interface.DO, interface.DO_ASU9),
  connect(sub_models.ASU9.interface.NH4, interface.NH4_ASU9),
  connect(sub_models.ASU9.interface.NO3, interface.NO3_ASU9),
  connect(sub_models.ASU9.interface.TSS, interface.TSS_ASU9),
  connect(sub_models.ASU9.interface.OnlineCOD, interface.OnlineCOD_ASU9),
  connect(sub_models.ASU9.interface.OfflineBOD, interface.OfflineBOD_ASU9),
  connect(sub_models.ASU9.interface.OnlineTN, interface.OnlineTN_ASU9),
  connect(sub_models.ASU9.interface.OfflineTKN, interface.OfflineTKN_ASU9),
  connect(sub_models.ASU9.interface.OnlineTP, interface.OnlineTP_ASU9),
  connect(sub_models.ASU9.interface.PO4, interface.PO4_ASU9),
  connect(sub_models.ASU9.interface.V_ASU, interface.V_ASU9),
  connect(sub_models.ASU9.interface.OUR_ASU, interface.OUR_ASU9),
  connect(sub_models.ASU9.interface.NUR, interface.NUR_ASU9),
  connect(sub_models.ASU9.interface.NPR, interface.NPR_ASU9),
  connect(sub_models.ASU9.interface.AUR, interface.AUR_ASU9),
  connect(sub_models.ASU9.interface.PUR, interface.PUR_ASU9),
  connect(sub_models.ASU9.interface.Kla_ASU, interface.Kla_ASU9),


# 214 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeninetank.msl" 2

 


  sub_models.ASU9.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU8.interface.Outflow, sub_models.ASU9.interface.Inflow),
  connect(interface.Kla9, sub_models.ASU9.interface.Kla),
  connect(sub_models.ASU9.interface.AerationEnergy, interface.AerationEnergy9),
  connect(sub_models.ASU9.interface.MixingEnergy, interface.MixingEnergy9),

  connect(interface.Temp, sub_models.ASU9.interface.Temp),


 };
:};



# 42 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasuninetank.msl" 1
 


















CLASS  FixVolumeASUNineTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeNineTank:=
{:
 comments <- "A coupled model for nine activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU9.interface.Outflow, interface.Outflow),
 };
:};



# 43 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 1
 


















CLASS  FixVolumeTenTank
EXTENDS FixVolumeNineTank WITH
{:

 sub_models <-
 {

  OBJ ASU10 : FixVolumeASU,
 };

 parameters <-  
 {
  OBJ Vol10 (* is_favorite = "1" *) "Volume of ASU10" : Volume := {: value <- 1000 ; group <- "Dimension" :};   
  }; 
 
 interface <-
 {
  OBJ Kla10 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient in ASU10" : OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
  OBJ AerationEnergy10 (* terminal = "out_2" *)"Aeration energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  OBJ MixingEnergy10 (* terminal = "out_2" *)"Mixing energy for ASU10" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl" 1
 















 
  

# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 78 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 99 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 120 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 141 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 162 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 183 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"


# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.ASM2_2d.msl"



   
    OBJ DO_ASU10 (* terminal = "out_2"; is_favorite = "1" *)"Dissolved oxygen concentration measurement in ASU10" :DissolvedOxygen:= {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NH4_ASU10 (* terminal = "out_2" *)"Ammonium concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NO3_ASU10 (* terminal = "out_2" *)"Nitrate+Nitrite concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PO4_ASU10 (* terminal = "out_2" *)" Phosphorous concentration measurement in ASU 10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS_ASU10 (* terminal = "out_2" *)"Total suspended solids concentration in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineCOD_ASU10 (* terminal = "out_2" *)"Chemical Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineBOD_ASU10 (* terminal = "out_2" *)"Biological Oxygen Demand measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTN_ASU10 (* terminal = "out_2" *)"Total nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OfflineTKN_ASU10 (* terminal = "out_2" *)"Total Kjeldal nitrogen concentration measurement in ASU10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OnlineTP_ASU10 (* terminal = "out_2" *)"Total phosphorous concentration measurement in ASU 10" :Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_ASU10 (* terminal = "out_2" *)"Volume measurement data in ASU10" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ OUR_ASU10 (* terminal = "out_2" *)"OUR measurement data in ASU10" : OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NUR_ASU10 (* terminal = "out_2" *)"NUR measurement data in ASU10" : NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ NPR_ASU10 (* terminal = "out_2" *)"NPR measurement data in ASU10" : NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ AUR_ASU10 (* terminal = "out_2" *)"AUR measurement data in ASU10" : AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PUR_ASU10 (* terminal = "out_2" *)"PUR measurement data in ASU10" : PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ Kla_ASU10 (* terminal = "out_2" *)"Kla measurement data in ASU10" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :};



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_interface.msl" 2










# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2


 };

 coupling <-
 {
   
  sub_models.ASU10.parameters.Vol.value := parameters.Vol10.value,
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 1
 














 





 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl" 1
 
















# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 247 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 407 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 487 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 567 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 647 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"


# 727 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.ASM2_2d.msl"




  sub_models.ASU10.parameters.theta_k_h.value := parameters.theta_k_h.value,
  sub_models.ASU10.parameters.theta_K_X.value := parameters.theta_K_X.value,
  sub_models.ASU10.parameters.theta_mu_H.value := parameters.theta_mu_H.value,
  sub_models.ASU10.parameters.theta_Q_fe.value := parameters.theta_Q_fe.value,
  sub_models.ASU10.parameters.theta_b_H.value := parameters.theta_b_H.value,
  sub_models.ASU10.parameters.theta_Q_PHA.value := parameters.theta_Q_PHA.value,
  sub_models.ASU10.parameters.theta_Q_PP.value := parameters.theta_Q_PP.value,
  sub_models.ASU10.parameters.theta_mu_PAO.value := parameters.theta_mu_PAO.value,
  sub_models.ASU10.parameters.theta_b_PAO.value := parameters.theta_b_PAO.value,
  sub_models.ASU10.parameters.theta_b_PP.value := parameters.theta_b_PP.value,
  sub_models.ASU10.parameters.theta_b_PHA.value := parameters.theta_b_PHA.value,
  sub_models.ASU10.parameters.theta_mu_AUT.value := parameters.theta_mu_AUT.value,
  sub_models.ASU10.parameters.theta_b_AUT.value := parameters.theta_b_AUT.value,

  sub_models.ASU10.parameters.i_N_S_I.value := parameters.i_N_S_I.value,
  sub_models.ASU10.parameters.i_N_S_F.value := parameters.i_N_S_F.value,
  sub_models.ASU10.parameters.i_N_X_S.value := parameters.i_N_X_S.value,
  sub_models.ASU10.parameters.i_N_X_I.value := parameters.i_N_X_I.value,
  sub_models.ASU10.parameters.i_N_BM.value := parameters.i_N_BM.value,
  sub_models.ASU10.parameters.i_P_S_I.value := parameters.i_P_S_I.value,
  sub_models.ASU10.parameters.i_P_S_F.value := parameters.i_P_S_F.value,
  sub_models.ASU10.parameters.i_P_X_I.value := parameters.i_P_X_I.value,
  sub_models.ASU10.parameters.i_P_X_S.value := parameters.i_P_X_S.value,
  sub_models.ASU10.parameters.i_P_BM.value := parameters.i_P_BM.value,
  sub_models.ASU10.parameters.i_TSS_X_I.value := parameters.i_TSS_X_I.value,
  sub_models.ASU10.parameters.i_TSS_X_S.value := parameters.i_TSS_X_S.value,
  sub_models.ASU10.parameters.i_TSS_BM.value := parameters.i_TSS_BM.value,
  sub_models.ASU10.parameters.f_S_I.value := parameters.f_S_I.value,
  sub_models.ASU10.parameters.f_X_I.value := parameters.f_X_I.value,
  sub_models.ASU10.parameters.Y_PO.value := parameters.Y_PO.value,
  sub_models.ASU10.parameters.Y_PHA.value := parameters.Y_PHA.value,
  sub_models.ASU10.parameters.Y_AUT.value := parameters.Y_AUT.value,
  sub_models.ASU10.parameters.k_h.value := parameters.k_h.value,
  sub_models.ASU10.parameters.n_NO_Hyd.value := parameters.n_NO_Hyd.value,
  sub_models.ASU10.parameters.Y_H.value := parameters.Y_H.value,
  sub_models.ASU10.parameters.Y_PAO.value := parameters.Y_PAO.value,
  sub_models.ASU10.parameters.K_O.value := parameters.K_O.value,
  sub_models.ASU10.parameters.K_NO.value := parameters.K_NO.value,
  sub_models.ASU10.parameters.K_X.value := parameters.K_X.value,
  sub_models.ASU10.parameters.mu_H.value := parameters.mu_H.value,
  sub_models.ASU10.parameters.Q_fe.value := parameters.Q_fe.value,
  sub_models.ASU10.parameters.n_fe.value := parameters.n_fe.value,
  sub_models.ASU10.parameters.K_fe.value := parameters.K_fe.value,
  sub_models.ASU10.parameters.n_NO_Het.value := parameters.n_NO_Het.value,
  sub_models.ASU10.parameters.b_H.value := parameters.b_H.value,
  sub_models.ASU10.parameters.K_F.value := parameters.K_F.value,
  sub_models.ASU10.parameters.K_A.value := parameters.K_A.value,
  sub_models.ASU10.parameters.K_NH.value := parameters.K_NH.value,
  sub_models.ASU10.parameters.K_P.value := parameters.K_P.value,
  sub_models.ASU10.parameters.K_ALK.value := parameters.K_ALK.value,
  sub_models.ASU10.parameters.Q_PHA.value := parameters.Q_PHA.value,
  sub_models.ASU10.parameters.Q_PP.value := parameters.Q_PP.value,
  sub_models.ASU10.parameters.mu_PAO.value := parameters.mu_PAO.value,
  sub_models.ASU10.parameters.b_PAO.value := parameters.b_PAO.value,
  sub_models.ASU10.parameters.b_PP.value := parameters.b_PP.value,
  sub_models.ASU10.parameters.b_PHA.value := parameters.b_PHA.value,
  sub_models.ASU10.parameters.K_PS.value := parameters.K_PS.value,
  sub_models.ASU10.parameters.K_PP.value := parameters.K_PP.value,
  sub_models.ASU10.parameters.K_MAX.value := parameters.K_MAX.value,
  sub_models.ASU10.parameters.K_IPP.value := parameters.K_IPP.value,
  sub_models.ASU10.parameters.K_PHA.value := parameters.K_PHA.value,
  sub_models.ASU10.parameters.mu_AUT.value := parameters.mu_AUT.value,
  sub_models.ASU10.parameters.b_AUT.value := parameters.b_AUT.value,
  sub_models.ASU10.parameters.K_O_AUT.value := parameters.K_O_AUT.value,
  sub_models.ASU10.parameters.K_NH_AUT.value := parameters.K_NH_AUT.value,
  sub_models.ASU10.parameters.K_ALK_AUT.value := parameters.K_ALK_AUT.value,
  sub_models.ASU10.parameters.k_PRE.value := parameters.k_PRE.value,
  sub_models.ASU10.parameters.k_RED.value := parameters.k_RED.value,

  sub_models.ASU10.parameters.n_NO_PAO.value := parameters.n_NO_PAO.value,

  sub_models.ASU10.parameters.n_NO_Het_d.value := parameters.n_NO_Het_d.value,
  sub_models.ASU10.parameters.n_NO_P_d.value := parameters.n_NO_P_d.value,
  sub_models.ASU10.parameters.n_NO_AUT_d.value := parameters.n_NO_AUT_d.value,





# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_parameters_coupling.msl" 2










# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 1
 




















 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl" 1
 














 

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 74 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 94 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 114 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 154 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 174 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"


# 194 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.ASM2_2d.msl"



  connect(sub_models.ASU10.interface.DO, interface.DO_ASU10),
  connect(sub_models.ASU10.interface.NH4, interface.NH4_ASU10),
  connect(sub_models.ASU10.interface.NO3, interface.NO3_ASU10),
  connect(sub_models.ASU10.interface.TSS, interface.TSS_ASU10),
  connect(sub_models.ASU10.interface.OnlineCOD, interface.OnlineCOD_ASU10),
  connect(sub_models.ASU10.interface.OfflineBOD, interface.OfflineBOD_ASU10),
  connect(sub_models.ASU10.interface.OnlineTN, interface.OnlineTN_ASU10),
  connect(sub_models.ASU10.interface.OfflineTKN, interface.OfflineTKN_ASU10),
  connect(sub_models.ASU10.interface.OnlineTP, interface.OnlineTP_ASU10),
  connect(sub_models.ASU10.interface.PO4, interface.PO4_ASU10),
  connect(sub_models.ASU10.interface.V_ASU, interface.V_ASU10),
  connect(sub_models.ASU10.interface.OUR_ASU, interface.OUR_ASU10),
  connect(sub_models.ASU10.interface.NUR, interface.NUR_ASU10),
  connect(sub_models.ASU10.interface.NPR, interface.NPR_ASU10),
  connect(sub_models.ASU10.interface.AUR, interface.AUR_ASU10),
  connect(sub_models.ASU10.interface.PUR, interface.PUR_ASU10),
  connect(sub_models.ASU10.interface.Kla_ASU, interface.Kla_ASU10),


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks_sensor_coupling.msl" 2










# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumetentank.msl" 2

 


  sub_models.ASU10.parameters.Temp_Ref.value := parameters.Temp_Ref.value,


   

  connect(sub_models.ASU9.interface.Outflow, sub_models.ASU10.interface.Inflow),
  connect(interface.Kla10, sub_models.ASU10.interface.Kla),
  connect(sub_models.ASU10.interface.AerationEnergy, interface.AerationEnergy10),
  connect(sub_models.ASU10.interface.MixingEnergy, interface.MixingEnergy10),

  connect(interface.Temp, sub_models.ASU10.interface.Temp),


 };
:};



# 45 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\activated_sludge_unit/wwtp.n_tanks.fixvolumeasutentank.msl" 1
 


















CLASS  FixVolumeASUTenTank
(* icon = "activated_sludge_unit" *)
SPECIALISES FixVolumeTenTank:=
{:
 comments <- "A coupled model for ten activated sludge units in series";

 coupling <-
 {
   
  connect(sub_models.ASU10.interface.Outflow, interface.Outflow),
 };
:};



# 46 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.n_tanks.msl" 2




# 32 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.SBR.msl" 1
 


















CLASS SBRAtomicModel
SPECIALISES PhysicalDAEModelType :=
  {:
  
  interface <-
  {
  OBJ Inflow (* terminal = "in_1" *) "influent" : InWWTPTerminal := {:causality <- "CIN" ; group <- "Influent" :};
  OBJ Outflow1 (* terminal = "out_1" *) "effluent" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 1" :};
  };
  
  parameters <- 
  {
   
    
  
   
    OBJ Q_Waste (* is_favorite = "1" *) "Desired waste flow rate during the idle phase" : FlowRate := {: value <- 240; group <- "Operational" :};
  };

  independent <- 
  { 
    OBJ t "Time": Time := {: group <- "Time" :};
  };
    
  state <-
  
  {
    OBJ ConversionTermPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ V (* is_favorite = "1" *) "Volume in the tank" : Volume := {: group <- "Dimension" :};
    OBJ C "Concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
 
    OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Incoming massflux per component" : MassFluxVector;
 
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
 
    OBJ M "Vector containing masses for all the components" : MassVector 
# 67 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.SBR.msl"


   := [{: value <- 1000000000 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 1 :},{: value <- 100 :},{: value <- 10 :},{: value <- 1 :},
          {: value <- 1 :},{: value <- 10 :},{: value <- 113.33 :},{: value <- 1 :},{: value <- 1 :},{: value <- 1 :};]













;
    };
  
  initial <-
   {
    
    };  

  equations <- 
   {
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
       (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
         In_Terminal[Comp_Index])+
       (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}:
         Out_Terminal[Comp_Index]);
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
            (In_Terminal[Comp_Index]);
     };
   
 
    state.Q_In = (0.000001 * state.InFluxPerComponent[IndexOfSolvent]);

 
    state.V = SUMOVER Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     (0.000001 * state.M[Comp_Index]);

    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.C[Comp_Index] = IF (state.V == 0)
                   THEN 0
                 ELSE state.M[Comp_Index]/state.V;
     };  
    };  
    :};

CLASS SBRConversionModel
EXTENDS SBRAtomicModel WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeConversionModel.body.msl" 1
 















 

   interface <-
   {
   };

   parameters <-
   {
     OBJ Stoichiometry (* hidden = "1" *) "A matrix structure containing stoichiometry" : PhysicalQuantityType[NrOfReactions;][NrOfComponents,];
   };

   state <-
   {
     OBJ Kinetics (* hidden = "1" *) "A vector containing kinetics for all reactions" : PhysicalQuantityType[NrOfReactions;];
   OBJ Kla_Actual (* is_favorite = "1" *) "The actual Kla in the system" : OxygenTransferCoefficient := {: group <- "Operational" :};
   OBJ Temp_Actual (* is_favorite = "1" *) "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   };

   equations <-
   {
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.ConversionTermPerComponent[Comp_Index] =
       SUMOVER Reaction_Index IN {1 .. NrOfReactions}:
        (parameters.Stoichiometry[Reaction_Index][Comp_Index]
        *state.Kinetics[Reaction_Index])
       *state.V;};
   };

# 129 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.SBR.msl" 2

 :};

CLASS SBRASMConversionModel
EXTENDS SBRConversionModel WITH
 {:
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 1
 
















  interface <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.interface.msl" 1
 
 
 
 
 


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  state <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.state.msl" 1
 
 
 
 
 


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;

# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  initial <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.stoichiometry.msl" 1
 
 
 
 
 


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  equations <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.kinetics.msl" 1
 
 
 
 
 


	state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);

	state.Kinetics[AerHydrol] = state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] = state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] = state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] = state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] = state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] = state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] = state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] = state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] = state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] = state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] = state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] = state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] = state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] = parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] = parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration]  = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.sensors.msl" 1
 
 
 
 
 


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR =           IF(state.V==0)           THEN 0           ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;

# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2


















# 135 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.SBR.msl" 2

 :};
 

    

# 33 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 1
 


















CLASS SBRModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
   OBJ Outflow2 (* terminal = "out_3" *) "bypass" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Effluent 2" :};
   OBJ Underflow (* terminal = "out_4" *) "effluent waste" : OutWWTPTerminal := {:causality <- "COUT" ; group <- "Underflow" :};
   OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one SBR in a multi-sbr system configuration " : Time 
     := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
   OBJ T1 (* terminal = "in_2"; manip = "1" *) "Period for the fill phase" : Time 
     := {: causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
   OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time 
     := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
   OBJ T4 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ T5 (* terminal = "in_2"; manip = "1" *) "Period for the idle phase" : Time 
     := {: causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
   OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate 
       := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
  
  parameters <- 
  {
  };
  
  state <-
  {
   
    OBJ T "Length of total cycle" : Time := {: group <- "Operational" :};
    OBJ T2 "Period for the reaction phase" : Time := {: value <- 0.125 ; group <- "Operational" :};
    OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
   
    OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    OBJ Q_Bypass "Bypass flow rate" : FlowRate := {: group <- "Operational" :};
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = interface.T1 + state.T2 + interface.T3 + interface.T4 + interface.T5 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};


CLASS SBRPointsettler
EXTENDS SBRModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000 ; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0 ; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 10000 ; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400 ; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005 ; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2 ; group <- "Settling":};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                        THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN 0
        ELSE
          IF (independent.t - state.t_Begin < (interface.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
          THEN 0
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3) )
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
              THEN state.Q_Out_Help_Draw
            ELSE 0;

   state.Q_Bypass =
       
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
     THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN state.Q_In
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN state.Q_In
         ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN state.Q_In
             ELSE state.Q_In;

    state.Q_Under =
       IF (independent.t < interface.T_Launch)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < interface.T1)
       THEN 0
     ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
           THEN 0
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
             THEN 0
             ELSE state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < interface.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE
       IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
       THEN state.ConversionTermPerComponent[Comp_Index]
       ELSE
         IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
           THEN state.FluxPerComponent[Comp_Index]
           ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:

       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN 0 
        ELSE
          IF (independent.t - state.t_Begin < interface.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE
            IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
            THEN 0
            ELSE
              IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
              THEN 0
              ELSE
                IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
                THEN - state.C[Comp_Index] * interface.Q_Draw * parameters.f_ns
                ELSE 0;
     };

    interface.Outflow2[IndexOfSolvent] = - state.Q_Bypass / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
      
      interface.Outflow2[Comp_Index] =
       IF (independent.t < interface.T_Launch)
       THEN 0
       ELSE
         IF (independent.t - state.t_Begin < interface.T1)
         THEN 0
         ELSE
           IF (independent.t - state.t_Begin < (interface.T1 + state.T2))
           THEN - state.InFluxPerComponent[Comp_Index]
           ELSE
             IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3))
             THEN - state.InFluxPerComponent[Comp_Index]
             ELSE
               IF (independent.t - state.t_Begin < (interface.T1 + state.T2 + interface.T3 + interface.T4))
               THEN - state.InFluxPerComponent[Comp_Index]
               ELSE - state.InFluxPerComponent[Comp_Index];
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns) ;
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
 
   };
 :};


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler1phasereact.msl" 1
 



















CLASS SBRPointsettler1PhaseReact
(* icon = "sbr"; is_default = "true" *)
EXTENDS SBRPointsettler WITH
 {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

state <-
   {
    };
 
 equations <- 
   {
      state.T2 = interface.T2R1 ;
   
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < interface.T1 )
            THEN interface.Kla_Fill 
              ELSE
              IF ((independent.t - state.t_Begin) < (state.T2 +interface.T1))
            THEN interface.Kla_React1 
              ELSE 0; 
   };
   
    :};



# 325 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler2phasereact.msl" 1
 



















 CLASS SBRPointsettler2PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1 )
         THEN interface.Kla_Fill 
           ELSE 
             IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
             THEN interface.Kla_React1 
           ELSE 
               IF ( (independent.t - state.t_Begin)<(state.T2 + interface.T1) )
               THEN interface.Kla_React2
               ELSE 0; 
    };
    
    :};



# 326 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler3phasereact.msl" 1
 



















CLASS SBRPointsettler3PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
  interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
              THEN interface.Kla_React3
                  ELSE 0; 
            
    };
    
    :};



# 327 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler4phasereact.msl" 1
 



















CLASS SBRPointsettler4PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                THEN interface.Kla_React4
                    ELSE 0; 
            
    };
    
    :};



# 328 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler5phasereact.msl" 1
 



















CLASS SBRPointsettler5PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5;
      
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                  THEN interface.Kla_React5
                      ELSE 0; 
            
    };
    
    :};



# 329 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler6phasereact.msl" 1
 














 




CLASS SBRPointsettler6PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                    THEN interface.Kla_React6
                        ELSE 0; 
            
    };
    
    :};



# 330 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler7phasereact.msl" 1
 



















CLASS SBRPointsettler7PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                      THEN interface.Kla_React7
                          ELSE 0; 
            
    };
    
    :};



# 331 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\SBR/wwtp.base.SBR.sbrpointsettler8phasereact.msl" 1
 



















CLASS SBRPointsettler8PhaseReact
 (* icon = "sbr"; is_default = "" *)
 EXTENDS SBRPointsettler WITH
  {:
 interface <-  
   {
     OBJ T2R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T2R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_Fill (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient during the filling period of the SBR" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0; group <- "Operational":}; 
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T2 = interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T2R8;
   
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
            IF ((independent.t - state.t_Begin) < interface.T1)
          THEN interface.Kla_Fill 
          ELSE 
            IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T1))
            THEN interface.Kla_React1 
            ELSE 
                IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T1))
              THEN interface.Kla_React2
              ELSE  
                  IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T1))
                THEN interface.Kla_React3
                ELSE  
                    IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T1))
                  THEN interface.Kla_React4
                  ELSE  
                      IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T1))
                    THEN interface.Kla_React5
                    ELSE  
                        IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T1))
                      THEN interface.Kla_React6
                      ELSE  
                          IF ((independent.t - state.t_Begin)<(interface.T2R1 + interface.T2R2 + interface.T2R3 + interface.T2R4 + interface.T2R5 + interface.T2R6 + interface.T2R7 + interface.T1))
                        THEN interface.Kla_React7
                        ELSE  
                            IF ((independent.t - state.t_Begin)<(state.T2 + interface.T1))
                        THEN interface.Kla_React8
                            ELSE 0; 
            
    };
    
    :};



# 332 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.SBR.msl" 2




# 34 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 1
 


















CLASS CFCDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFCD in a multi-CFCD system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };
    
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {: group <- "Operational" :};  
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
 
   state.T = state.T1 + interface.T2 ;

   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};


CLASS CFCDPointsettler
EXTENDS CFCDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {

 

 

 

 
  
 

 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  initial <-
   {
    };

  equations <-
   {
 
    

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out = state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) =
      IF (independent.t < interface.T_Launch)
    THEN state.FluxPerComponent[Comp_Index]
    ELSE
        IF (independent.t - state.t_Begin < state.T1)
        THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
        ELSE state.FluxPerComponent[Comp_Index];
     };

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out * parameters.f_ns
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns)
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler1phasereact.msl" 1
 



















CLASS CFCDPointsettler1PhaseReact
(* icon = "cfcd"; is_default = "true" *)
EXTENDS CFCDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed continuous discharge tank with 1 reaction phase";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFCD" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
 
 parameters <-
   { 
    };

  state <-

   {
     
    };
 
 equations <- 
   {
      state.T1 = interface.T1R1 ;
  
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN 0
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1 
              ELSE  0; 
   };
   
    :};
 


# 234 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler2phasereact.msl" 1
 



















 CLASS CFCDPointsettler2PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge with 2 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN 0 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 235 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler3phasereact.msl" 1
 



















CLASS CFCDPointsettler3PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 3 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 236 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler4phasereact.msl" 1
 



















CLASS CFCDPointsettler4PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 4 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
      state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
              THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 237 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler5phasereact.msl" 1
 














 




CLASS CFCDPointsettler5PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 5 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 238 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler6phasereact.msl" 1
 



















CLASS CFCDPointsettler6PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 6 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                  THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 239 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler7phasereact.msl" 1
 



















CLASS CFCDPointsettler7PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 7 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
     state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;

       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React7
                      ELSE 0; 
            
    };
    
    :};



# 240 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFCD/wwtp.base.CFCD.cfcdpointsettler8phasereact.msl" 1
 



















CLASS CFCDPointsettler8PhaseReact
 (* icon = "cfcd" *)
 EXTENDS CFCDPointsettler WITH
  {:
  comments <- "A model for a continuous feed continuous discharge  with 8 reaction phases";
  
  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
  };

  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
     
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN 0
          ELSE 
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                      THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 241 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFCD.msl" 2





# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 1
 


















CLASS CFIDModel
EXTENDS SBRASMConversionModel WITH
  {:
  
  interface <-
  {
    OBJ Underflow (* terminal = "out_3" *) "effluent waste" : OutWWTPTerminal := {:causality <- COUT; group <- "Underflow" :};
    OBJ T_Launch (* terminal = "in_2"; manip = "1" *) "Time constant to schedule the start up of one CFID in a multi-CFID system configuration " : Time := {: causality <- "CIN" ; value <- 0.0; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Period for the settling phase" : Time := {: causality <- "CIN" ; value <- 0.1; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Period for the draw phase" : Time := {: causality <- "CIN" ; value <- 0.025; group <- "Operational":};
    OBJ Q_Draw (* terminal = "in_2"; manip = "1" *) "Desired draw flow rate" : FlowRate := {: causality <- "CIN" ; value <- 24000 ; group <- "Operational" :};

   OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 

  };  
  
  parameters <- 
  {
  };
  
  state <-
  {
     
      OBJ T "Length of total cycle" : Time := {: group <- "Operational" :} ;
      OBJ T1 "Period for the reaction phase" : Time := {:value <- 0.25; group <- "Operational" :};
      OBJ t_Begin (* hidden = "1" *) " Time at the beginning of the current cycle" : Time ;
     
      OBJ Q_Out_Help (* hidden = "1" *) "Effluent flow rate help variable" : FlowRate ;
    };

  initial <- 
  {
   }; 
  
  equations <- 
  {
    state.T = state.T1 + interface.T2 + interface.T3 ;

 
   state.t_Begin = IF (independent.t < interface.T_Launch)
             THEN interface.T_Launch
             ELSE interface.T_Launch + floor((independent.t-interface.T_Launch)/state.T) * state.T ;


    state.Temp_Actual = interface.Temp;

  };  
    :};
  

CLASS CFIDPointsettler
EXTENDS CFIDModel WITH
 {:
  interface <-
   {
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };

  parameters <-
   {

 
    
 
    
 
    OBJ V_Max "Maximum volume of the tank" : Volume := {: value <- 2000; group <- "Dimension" :};
    OBJ V_Min "Minimum volume of the tank" : Volume := {: value <- 0; group <- "Dimension" :};
    OBJ N "Number of weirs on a tank" : PhysicalQuantityType :=
         {: value <- 100 ;
        group <- "Hydraulic" ;
            interval <- {:lowerBound <- 0; upperBound <- PLUS_INF; :}
         :} ;
    OBJ alfa "Parameter, function of the weir type or width" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ beta "Parameter, depends on the weir design" : PhysicalQuantityType := {: value <- 1; group <- "Hydraulic" :};
    OBJ A "Surface area of the tank" : Area := {: value <- 400; group <- "Dimension" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" :
         Fraction := {: value <- 0.005; group <- "Settling" :};
    OBJ F_Th "Thickening factor of the suspended solids" : Real := {: value <- 2; group <- "Settling" :};
 
    
 
   
 

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
    
   };

  state <-
   {

 

 

 

 
  
 
 
    OBJ Q_Out_Help_Draw (* hidden = "1" *) "Effluent flow rate help variable for the draw phase" : FlowRate ;
 
    OBJ Q_Under_Help_Waste (* hidden = "1" *) "Waste flow rate help variable for the idle phase" : FlowRate ;

 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
 

 
   
    state.Q_Out_Help = IF (state.V > parameters.V_Max)
                       THEN parameters.N * parameters.alfa
           * pow((state.V - parameters.V_Max)/parameters.A, parameters.beta)
                       ELSE 0;

    state.Q_Out_Help_Draw = IF (state.V > parameters.V_Min)
                            THEN interface.Q_Draw
                            ELSE 0;

    state.Q_Under_Help_Waste = IF (state.V > 0)
                             THEN parameters.Q_Waste
                             ELSE 0;

    state.Q_Out =
        IF (independent.t < interface.T_Launch)
      THEN state.Q_Out_Help
        ELSE
          IF (independent.t - state.t_Begin < (state.T1))
      THEN state.Q_Out_Help
      ELSE
          IF (independent.t - state.t_Begin < (state.T1 + interface.T2))
          THEN state.Q_Out_Help
          ELSE state.Q_Out_Help_Draw + state.Q_Out_Help;

    state.Q_Under = state.Q_Under_Help_Waste;

 
    {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      
   DERIV(state.M[Comp_Index],[independent.t]) =
   IF (independent.t < interface.T_Launch)
   THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
   ELSE
     IF (independent.t - state.t_Begin < state.T1)
     THEN state.FluxPerComponent[Comp_Index] + state.ConversionTermPerComponent[Comp_Index]
     ELSE state.FluxPerComponent[Comp_Index];
     };

       

 

 

    interface.Outflow1[IndexOfSolvent] = - state.Q_Out / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Outflow1[Comp_Index] =  - state.C[Comp_Index] * state.Q_Out;
     };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Outflow1[Comp_Index] =
      IF (independent.t  < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Out 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Out
          ELSE - state.C[Comp_Index] * state.Q_Out * parameters.f_ns;
     };

    interface.Underflow[IndexOfSolvent] = - state.Q_Under / 0.000001;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] =  - state.C[Comp_Index] *  state.Q_Under ;
     };

     { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       interface.Underflow[Comp_Index] = 
      IF (independent.t < interface.T_Launch)
        THEN - state.C[Comp_Index] * state.Q_Under 
        ELSE
          IF (independent.t - state.t_Begin < state.T1)
          THEN - state.C[Comp_Index] * state.Q_Under
          ELSE - state.C[Comp_Index] * state.Q_Under * parameters.F_Th * (1-parameters.f_ns);    
     };
 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under + state.Q_Out;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };
 :};


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler1phasereact.msl" 1
 














 




CLASS CFIDPointsettler1PhaseReact
(* icon = "cfid"; is_default = "true" *)
EXTENDS CFIDPointsettler WITH
 {:
 
 comments <- "A model for a continuous feed SBR with 1 reaction phase";
 
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction period of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   

 parameters <-
   { 
    };

  state <-
   {
    };
 
 equations <- 
   {

    state.T1 = interface.T1R1;
    
       
      
      state.Kla_Actual =
            IF  (independent.t < interface.T_Launch )
          THEN interface.Kla_Launch
            ELSE
              IF ( (independent.t - state.t_Begin) < state.T1 )
            THEN  interface.Kla_React1
              ELSE  0; 
   };
   
    :};



# 248 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler2phasereact.msl" 1
 



















 CLASS CFIDPointsettler2PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 2 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.075; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
  state <-
 
    {
     
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 ;
 
        
       
       state.Kla_Actual =
         IF  (independent.t < interface.T_Launch )
       THEN interface.Kla_Launch 
         ELSE
           IF ( (independent.t - state.t_Begin) < interface.T1R1 )
         THEN  interface.Kla_React1 
           ELSE 
             IF ( (independent.t - state.t_Begin)< state.T1 )
             THEN interface.Kla_React2
             ELSE 0; 
    };
    
    :};



# 249 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler3phasereact.msl" 1
 



















CLASS CFIDPointsettler3PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 3 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
 
    { 
     };
 
 state <-
 
    {
      
  
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 ;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)< state.T1)
            THEN interface.Kla_React3
                ELSE 0; 
            
    };
    
    :};



# 250 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler4phasereact.msl" 1
 



















CLASS CFIDPointsettler4PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 4 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React4
                  ELSE 0; 
            
    };
    
    :};



# 251 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler5phasereact.msl" 1
 



















CLASS CFIDPointsettler5PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 5 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)< state.T1)
                THEN interface.Kla_React5
                    ELSE 0; 
            
    };
    
    :};



# 252 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler6phasereact.msl" 1
 



















CLASS CFIDPointsettler6PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 6 reaction phases";

  interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React6
                      ELSE 0; 
            
    };
    
    :};



# 253 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler7phasereact.msl" 1
 



















CLASS CFIDPointsettler7PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 7 reaction phases";
  
 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)< state.T1)
                    THEN interface.Kla_React7
                        ELSE 0; 
            
    };
    
    :};



# 254 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\CFID/wwtp.base.CFID.cfidpointsettler8phasereact.msl" 1
 



















CLASS CFIDPointsettler8PhaseReact
 (* icon = "cfid" *)
 EXTENDS CFIDPointsettler WITH
  {:
  comments <- "A model for a continuous feed SBR with 8 reaction phases";

 interface <-  
   {
     OBJ T1R1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 1" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 2" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 3" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 4" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 5" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 6" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 7" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ T1R8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Period for the reaction phase 8" : Time 
       := {: causality <- "CIN" ; value <- 0.05; group <- "Operational":};
     OBJ Kla_Launch (* terminal = "in_2"; manip = "1" *) "Oxygen transfer coefficient during the launch time of the CFID" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React1 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 1" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React2 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 2" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React3 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 3" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React4 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 4" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};   
     OBJ Kla_React5 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 5" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React6 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 6" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React7 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 7" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
     OBJ Kla_React8 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Oxygen transfer coefficient for the reaction phase 8" : OxygenTransferCoefficient 
     := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
   };   
  
  parameters <-
    { 
     };
 
 state <-
    {
     };
  
  initial <-
    {
    };
  
  equations <- 
    {
    state.T1 = interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7 + interface.T1R8;
 
       
      
       state.Kla_Actual =
          IF  (independent.t < interface.T_Launch )
        THEN interface.Kla_Launch 
          ELSE
          IF ((independent.t - state.t_Begin) < interface.T1R1 )
          THEN interface.Kla_React1 
          ELSE 
              IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2))
              THEN interface.Kla_React2
              ELSE  
                IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3))
                THEN interface.Kla_React3
                ELSE  
                  IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4))
                  THEN interface.Kla_React4
                  ELSE  
                    IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5))
                    THEN interface.Kla_React5
                    ELSE  
                      IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6))
                      THEN interface.Kla_React6
                      ELSE  
                        IF ((independent.t - state.t_Begin)<( interface.T1R1 + interface.T1R2 + interface.T1R3 + interface.T1R4 + interface.T1R5 + interface.T1R6 + interface.T1R7))
                        THEN interface.Kla_React7
                        ELSE  
                          IF ((independent.t - state.t_Begin)< state.T1)
                        THEN interface.Kla_React8
                          ELSE 0; 
            
    };
    
    :};



# 255 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.CFID.msl" 2



# 36 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.clarifier.msl" 1
 



















 CLASS PointSettler
 "Pointsettler"

 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
 



    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
    OBJ f_ns_help (* hidden = "1" *) "Non-settleable fraction of suspended solids" : Fraction ;
   };

  equations <-
   {
      
      
  
      
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
                 THEN state.Q_In
                 ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out = IF  (state.Q_In <= interface.Q_Under)
              THEN 0
              ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;
    state.f_Under = IF (state.Q_In <= interface.Q_Under)
                THEN 1
              ELSE interface.Q_Under/state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    interface.Underflow[IndexOfSolvent] = IF  (state.Q_In <= interface.Q_Under)
                   THEN - state.Q_In / 0.000001
                   ELSE - interface.Q_Under / 0.000001 ;

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - state.InFluxPerComponent[Comp_Index]* state.f_Under ;};

      
      
      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        state.f_ns_help ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

     
# 163 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.clarifier.msl"



    state.X_In =  IF (state.Q_In == 0)
            THEN 0
          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out =  IF (state.Q_In <= interface.Q_Under)
           THEN 0
           ELSE (- interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under) );

    state.X_Under = IF (state.Q_In <= interface.Q_Under) 
              THEN
                IF (state.Q_In == 0)
                  THEN 0
                ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
            ELSE 
                IF (interface.Q_Under == 0)
                  THEN 0
                ELSE - interface.Underflow[IndexOfTSSComponent] / (interface.Q_Under);


 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};





# 37 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarypointsettler.msl" 1
 



















 CLASS PrimaryPointSettler  (* icon = "primary_clarifier" ; is_default = "true" *)
 "Point-settler model for primary clarifier"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a primary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.6 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};




# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl" 1
 



















 CLASS PrimaryOtterpohlFreund
 (* icon = "primary_clarifier" *)
 "Otterpohl & Freund model for primary clarifiers"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "true" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {: 
          value <- 2.7;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ beta "Otterpohl and Freund function constant" : PhysicalQuantityType := 
        {:
          value <- 9;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    
    
    
    OBJ V_Clar (* is_favorite = "true" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "true" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "true" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ Eff_COD "Efficiency of COD removal" : PhysicalQuantityType := {: group <- "Settling" :};
    OBJ Eff_X_COD "Efficiency of particulate COD removal" :     PhysicalQuantityType := {: group <- "Settling" :};
    OBJ COD "Total COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_COD "Particulate COD in the clarifier influent" : MassFlux := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "true" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "true" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "true" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent waterflux going to the Overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

# 134 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"



    {state.COD = 
            state.X_COD 
            + interface.Inflow[S_I] + interface.Inflow[S_F]+ interface.Inflow[S_A] ;
     };

     {state.X_COD = (interface.Inflow[X_S] + interface.Inflow[X_I]
           + interface.Inflow[X_AUT] + interface.Inflow[X_H] 
           + interface.Inflow[X_PAO] + interface.Inflow[X_PHA]);
     };













    state.Eff_COD =   IF ( state.Q_In == 0)
            THEN 1
            ELSE  parameters.alfa * 0.01 *
               ( log ( pow(24 * parameters.V_Clar/state.Q_In,2) ) + parameters.beta ) ;

    state.Eff_X_COD = IF (state.X_COD == 0)
              THEN 0
          ELSE state.Eff_COD * state.COD / state.X_COD ;

      
      

    state.f_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

     
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * 
        (1 - state.Eff_X_COD) ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

# 230 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primaryotterpohlfreund.msl"



    state.X_In =  IF (state.Q_In == 0)
      THEN 0
      ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out = IF (state.Q_In <= interface.Q_Under)
                  THEN 0
                  ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);

    state.X_Under = IF (state.Q_In <= interface.Q_Under) 
        THEN
           IF (state.Q_In == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
        ELSE 
           IF (interface.Q_Under == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (interface.Q_Under);



 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 

 :};



# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl" 1
 



















 CLASS Tay
 (* icon = "primary_clarifier" *)
 "The model of Tay for primary clarifiers"

 
 
 
 
 
 
 
 
 

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   comments <- "A model for a primary settler by Tay";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ T_A "Half removal time" : Time := {: value <- 0.125 ; group <- "Settling" :};
    OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
    OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
    
    
    OBJ V_Clar (* is_favorite = "1" *) "Volume of the clarifier" : Volume := {: value <- 500 ; group <- "Dimension" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ thelp (* hidden = "1" *) "Previous time help variable" : Time;
    OBJ Qmean (* hidden = "1" *) "Averaged influent flow rate" : FlowRate;
    OBJ Qprev1 (* hidden = "1" *) "Influent flow rate over a period Delta_t back in time" : FlowRate;
    OBJ Qprev2 (* hidden = "1" *) "Influent flow rate over a period Delta_t, two times Delta_t back in time" : FlowRate;
    OBJ Qprev3 (* hidden = "1" *) " Influent flow rate over a period Delta_t, three times Delta_t back in time " : FlowRate;
    OBJ Qprev4 (* hidden = "1" *) " Influent flow rate over a period Delta_t, four times Delta_t back in time " : FlowRate;
    OBJ Qprev5 (* hidden = "1" *) " Influent flow rate over a period Delta_t, five times Delta_t back in time " : FlowRate;
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {
      
      

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
           THEN state.Q_In
           ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.f_Out := IF (state.Q_In <= interface.Q_Under)
                   THEN 0
       ELSE (state.Q_In - interface.Q_Under) / state.Q_In ;

    state.Qprev1 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN state.Q_In
                     ELSE previous(state.Qprev1);

    state.Qprev2 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev1)
                     ELSE previous(state.Qprev2);

    state.Qprev3 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev2)
                     ELSE previous(state.Qprev3);

    state.Qprev4 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev3)
                     ELSE previous(state.Qprev4);

    state.Qprev5 = IF (independent.t < parameters.t_Start)
                   THEN state.Q_In
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN previous(state.Qprev4)
                     ELSE previous(state.Qprev5);

    state.thelp = IF (independent.t < parameters.t_Start)
                   THEN independent.t
                   ELSE
                     IF ((independent.t - previous(state.thelp)) > parameters.Delta_t)
                     THEN independent.t
                     ELSE previous(state.thelp);

    state.Qmean = (state.Qprev1 + state.Qprev2 + state.Qprev3 + state.Qprev4 + state.Qprev5) / 5;

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
     + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] = 
      IF (state.Q_In == 0 || state.Qmean == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                       (state.Q_In * (1 + parameters.V_Clar / (state.Qmean * parameters.T_A)));
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
     + interface.Outflow[Comp_Index]);};

      
      
# 205 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay.msl"




    state.X_In =  IF (state.Q_In == 0)
      THEN 0
      ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out = IF (state.Q_In <= interface.Q_Under)
      THEN 0
      ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);

    state.X_Under = IF (state.Q_In <= interface.Q_Under) 
        THEN
           IF (state.Q_In == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
        ELSE 
           IF (interface.Q_Under == 0)
               THEN 0
           ELSE - interface.Underflow[IndexOfTSSComponent] / (interface.Q_Under);

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    }; 
  :};



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl" 1
 










 CLASS Tay4
  (* class = "primary_clarifier" *)
  "Modification of the model of Tay for primary clarifiers"
 
  
  
  
  
  
  
  
  
  
  
  
 
  EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
    comments <- "A model for a primary settler by Tay";
    interface <-
    { 
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
          InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
     OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
     OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
          OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
	   OBJ Q_Under (* terminal = "in_2" *) "Inflow" : 
          FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
    };
 
   parameters <- 
    { 
     OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.8 ; group <- "Conversion factors" :};
  
     OBJ Delta_t "Time period defining the interval over which the average flow rate is calculated" : Time := {: value <- 0.1 ; group <- "Settling" :};
     OBJ t_Start "Time where the calculation of the average flow rate starts" : Time := {: value <- 0.1 ; group <- "Settling":};
     
     
     OBJ V_Clar "Volume of the clarifier" : Volume := {: value <- 28795 ; group <- "Dimension" :};
     OBJ E_R_XCOD_DW "Removal efficiency for particulate COD at dry weather flows" : Fraction := {: value <- 0.51; group <- "Settling" :};
     OBJ E_R_XII_DW "Removal efficiency for inert inorganic particulates at dry weather flows" : Fraction := {: value <- 0.85; group <- "Settling" :};
     OBJ f_ns_XCOD_DW "Non-settlable fraction for particulate COD at dry weather flows" : Fraction := {: group <- "Settling" :};
     OBJ f_ns_XII_DW "Non-settlable fraction for inert inorganic particulates at dry weather flows" : Fraction := {: group <- "Settling" :};
 	OBJ Q_In_DW "Dry weather flow rate" : FlowRate := {: value <- 91727; group <- "Dimension" :};
     OBJ f_Out_DW (* hidden = "1" *) "Fraction of the influent flux going to the overflow during dry weather" : Fraction;
  
 	OBJ i_TSS_X_I	"TSS to X_I ratio"
 	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
 	OBJ i_TSS_X_S	"TSS to X_S ratio"
 	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
 	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
 	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
  
 	OBJ T_Average "averaging time used for the calculation of the average retention time"
 	: Time := {: value <- 0.1; group <- "System" :};
 	 
 	 
    };
 
   state <-
    {
     OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
     OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
     OBJ Help_X_In (* hidden = "0" *) "" : MassFlux;
     OBJ Help_X_Out (* hidden = "0" *) "" : MassFlux;
     OBJ Help_X_Under (* hidden = "0" *) "" : MassFlux;
  
      
     OBJ Qmean (* hidden = "0" *) "Averaged influent flow rate" : FlowRate;
  
  
  
  
  
     OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ X_In_Calc "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
     OBJ f_Out (* hidden = "0" *) "Fraction of the influent flux going to the overflow" : Fraction ;
     OBJ E_Removal "Calculated Removal efficiency for each component" : Fraction[NrOfComponents;] := {: group <- "Settling" :};
     OBJ COD_In (* hidden = "0" *) "Incoming flux of COD" : MassFlux;
     OBJ COD_Out (* hidden = "0" *) "Outgoing flux of COD" : MassFlux;
     OBJ XCOD_In (* hidden = "0" *) "Incoming flux of XCOD" : MassFlux;
     OBJ XCOD_Out (* hidden = "0" *) "Outgoing flux of XCOD" : MassFlux;
     OBJ E_R_COD "Removal efficiency for COD" : Fraction := {: group <- "Settling" :};
     OBJ E_R_XCOD "Removal efficiency for XCOD" : Fraction := {: group <- "Settling" :};
     OBJ E_R_TSS "Removal efficiency for TSS" : Fraction := {: group <- "Settling" :};
     OBJ E_R_TSS2 "Removal efficiency for TSS" : Fraction := {: group <- "Settling" :};
     OBJ T_A_XCOD "Half removal time for X_COD" : Time := {: group <- "Settling" :};
     OBJ T_A_XII "Half removal time for inert inorganic particulates" : Time := {: group <- "Settling" :};
  
      
  
     OBJ TSS_Out_h "TSS out help" : MassFlux := {: group <- "Settling" :};
    };
 
     initial <-  
     {
     parameters.f_Out_DW = (parameters.Q_In_DW - interface.Q_Under)/parameters.Q_In_DW;
  	parameters.f_ns_XCOD_DW = (1.0 - parameters.E_R_XCOD_DW) / parameters.f_Out_DW;
 	parameters.f_ns_XII_DW = (1.0 - parameters.E_R_XII_DW) / parameters.f_Out_DW;
  
 	 
    };
    
   equations <-
    {
       
       
 
     state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
 				   		   THEN 0
  
 				   		   ELSE interface.Q_Under; 
 
     state.Q_Out = state.Q_In - state.Q_Under_Actual;
 
 	 
      
      
 	 






 	DERIV(state.Qmean,[independent.t]) = (state.Q_In - state.Qmean) / parameters.T_Average;
 		
  
     state.f_Out := IF (state.Q_In <= 0)
                    THEN 0
  			 	   ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;
 
  









































  
 
  
  
 
 	state.T_A_XCOD = (parameters.V_Clar/parameters.Q_In_DW) * (parameters.f_ns_XCOD_DW/(1-parameters.f_ns_XCOD_DW));
 	state.T_A_XII = (parameters.V_Clar/parameters.Q_In_DW) * (parameters.f_ns_XII_DW/(1-parameters.f_ns_XII_DW));
 	
     {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
       interface.Outflow[Comp_Index] =
       - state.InFluxPerComponent[Comp_Index] * state.f_Out ;};
 
     {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index]
      + interface.Outflow[Comp_Index]) ;};
 
       
       
       
       
       
       
 
  
  
     {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. X_AUT}:
       interface.Outflow[Comp_Index] = 
 			IF (state.Q_In == 0 || state.Qmean == 0)
 			THEN 0
 			ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                        (1 + parameters.V_Clar / (state.Qmean * state.T_A_XCOD));
      };
 
  
  
  
     {FOREACH Comp_Index IN {X_MEOH .. X_I_i}:
       interface.Outflow[Comp_Index] = 
 			IF (state.Q_In == 0 || state.Qmean == 0)
 			THEN 0
 			ELSE - state.InFluxPerComponent[Comp_Index] * state.f_Out /
                        (1 + parameters.V_Clar / (state.Qmean * state.T_A_XII));
      };
 
 	state.TSS_Out_h = interface.Outflow[X_I] * parameters.i_TSS_X_I
 							  + interface.Outflow[X_S] * parameters.i_TSS_X_S
 							  + interface.Outflow[X_H] * parameters.i_TSS_BM
 							  + interface.Outflow[X_PAO] * parameters.i_TSS_BM
 							  + interface.Outflow[X_PP] * 3.23
 							  + interface.Outflow[X_PHA] * 0.6
 							  + interface.Outflow[X_AUT] * parameters.i_TSS_BM
 							  + interface.Outflow[X_MEOH] * 1.0
 							  + interface.Outflow[X_MEP] * 1.0
 							  + interface.Outflow[X_I_i] * 1.0;
 							  
 	interface.Outflow[X_TSS] = IF (-state.TSS_Out_h > interface.Inflow[X_TSS])
 							   THEN 0
 							   ELSE state.TSS_Out_h;
 	 
     {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = - (state.InFluxPerComponent[Comp_Index] 
      + interface.Outflow[Comp_Index]);};
 
       
       
 
# 293 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.tay4.msl"

 
 
 
     state.X_In = IF (state.Q_In == 0)
 			   	 THEN 0
 				 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;
 
     state.X_In_Calc = (interface.Inflow[X_I] * parameters.i_TSS_X_I
 							  + interface.Inflow[X_S] * parameters.i_TSS_X_S
 							  + interface.Inflow[X_H] * parameters.i_TSS_BM
 							  + interface.Inflow[X_PAO] * parameters.i_TSS_BM
 							  + interface.Inflow[X_PP] * 3.23
 							  + interface.Inflow[X_PHA] * 0.6
 							  + interface.Inflow[X_AUT] * parameters.i_TSS_BM
 							  + interface.Inflow[X_MEOH] * 1.0
 							  + interface.Inflow[X_MEP] * 1.0
 							  + interface.Inflow[X_I_i] * 1.0) / state.Q_In;
 				 
     state.X_Out = IF (state.Q_In <= interface.Q_Under)
 				  THEN - interface.Outflow[IndexOfTSSComponent] / (state.Q_In)
  
 				  ELSE - interface.Outflow[IndexOfTSSComponent] / (state.Q_In - interface.Q_Under);
 
      state.X_Under = 
     		IF (state.Q_Under_Actual <= 0)
 			THEN 0
 			ELSE - interface.Underflow[IndexOfTSSComponent] / state.Q_Under_Actual;
      
  










 
 
  
 	   state.E_R_TSS = (1 - state.X_Out / state.X_In);
 	   state.E_R_TSS2 = (1 - state.X_Out / state.X_In_Calc);
 	   
        state.COD_Out = - interface.Outflow[S_I] - interface.Outflow[S_A] - interface.Outflow[S_F]
 	   				   - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
 	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
        state.COD_In = interface.Inflow[S_I] + interface.Inflow[S_A] + interface.Inflow[S_F]
 	   				   + interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
 	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
 	  
 	   state.E_R_COD = (1 - state.COD_Out / state.COD_In);
 
        state.XCOD_Out = - interface.Outflow[X_I] - interface.Outflow[X_S] - interface.Outflow[X_H]
 	   				   - interface.Outflow[X_PAO] - interface.Outflow[X_PAO] - interface.Outflow[X_AUT];
        state.XCOD_In = interface.Inflow[X_I] + interface.Inflow[X_S] + interface.Inflow[X_H]
 	   				   + interface.Inflow[X_PAO] + interface.Inflow[X_PAO] + interface.Inflow[X_AUT];
 	  
 	   state.E_R_XCOD = (1 - state.XCOD_Out / state.XCOD_In);
 
     }; 
  :};





# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl" 1
 


















# 623 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.lessardbeck.msl"



# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacs.msl" 1
 



















 CLASS PrimaryTakacs
 (* icon = "primary_clarifier" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1"*) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data":};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length  := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration  := {: group <- "Settling" :};  
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration  := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration  := {: group <- "Concentration" :}; 
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration  := {: group <- "Concentration" :};   
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate  := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {

    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001 
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE 
      - state.InFluxPerComponent[Comp_Index] * 
      (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual /
                  0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] -
      interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
    ELSE
      - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) *
      state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;
 
 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};



# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl" 1
 


















# 471 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacssolublespropagator.msl"



# 26 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsallfractionpropagator.msl" 1
 



















 CLASS PrimaryTakacsAllFractionPropagator
 (* icon = "primary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
   
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 96 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 45 ; group <- "Settling" :};  
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.0007 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.00019 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.0024 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
   
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 









{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
state.X_Layer[Layer_Index] = state.C[IndexOfTSSComponent][Layer_Index];
};


 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / 0.000001;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

 
 

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};



# 27 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl" 1
 


















# 625 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.primarytakacsreactive1.msl"




# 28 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\primary_clarifier/wwtp.base.primary_clarifier.DAF.msl" 1


 CLASS removal_rates
 (* class = "primary_clarifier" *)
 "Model of settling with removal rates and fixed DO, for DAF, CEPT etc."				

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
	  OBJ val (* terminal = "in_2" *) "Inflow" : 
         Real := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
   };

  parameters <- 
   { 
    OBJ threshold "value > threshold = removals a, value <= threshold = removals b" : 
         Real := {: value <- 1 ; group <- "Settling" :};
	  OBJ f_NH4a "Non-settleable fraction of NH4 above threshold" : 
         Fraction := {: value <- 1 ; group <- "Settling" :};
    OBJ f_PO4a "Non-settleable fraction of PO4 above threshold" : 
         Fraction := {: value <- 0.12 ; group <- "Settling" :};
	  OBJ f_sCODa "Non-settleable fraction of sCOD above threshold" : 
         Fraction := {: value <- 0.75 ; group <- "Settling" :};
	  OBJ f_TSSa "Non-settleable fraction of TSS above threshold" : 
         Fraction := {: value <- 0.11 ; group <- "Settling" :};
	  OBJ f_NH4b "Non-settleable fraction of NH4 below threshold" : 
         Fraction := {: value <- 1 ; group <- "Settling" :};
    OBJ f_PO4b "Non-settleable fraction of PO4 below threshold" : 
         Fraction := {: value <- 0.94 ; group <- "Settling" :};
	  OBJ f_sCODb "Non-settleable fraction of sCOD below threshold" : 
         Fraction := {: value <- 0.9 ; group <- "Settling" :};
	  OBJ f_TSSb "Non-settleable fraction of TSS below threshold" : 
         Fraction := {: value <- 0.45 ; group <- "Settling" :};
    OBJ Q_Under "Underflow rate" : FlowRate := {: value <- 0 ; group <- "Operational" :};
	  OBJ DO_out "Effluent DO" : Concentration := {: value <- 0.1 ; group <- "Operational" :};
   };

  state <-
   {
    OBJ f_NH4 "Non-settleable fraction of NH4" : Fraction := {: group <- "Settling" :};
    OBJ f_PO4 "Non-settleable fraction of PO4" : Fraction := {: group <- "Settling" :};
	  OBJ f_sCOD "Non-settleable fraction of sCOD" : Fraction := {: group <- "Settling" :};
	  OBJ f_TSS "Non-settleable fraction of TSS" : Fraction := {: group <- "Settling" :};
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
	  OBJ P_removed "P removed" : MassFlux := {: group <- "Operational" :};
   };

  equations <-
   {
      
      
  
      
      
      
	 
	 state.f_NH4 = IF (interface.val <= parameters.threshold)
	 			   		 THEN parameters.f_NH4b
				  			 ELSE parameters.f_NH4a;
	 state.f_PO4 = IF (interface.val <= parameters.threshold)
	 			  		  THEN parameters.f_PO4b
				   			ELSE parameters.f_PO4a;
	 state.f_sCOD = IF (interface.val <= parameters.threshold)
	 			  			 THEN parameters.f_sCODb
				  			  ELSE parameters.f_sCODa;
	 state.f_TSS = IF (interface.val <= parameters.threshold)
	 			  		  THEN parameters.f_TSSb
				   			ELSE parameters.f_TSSa;

   state.Q_Under_Actual = IF (state.Q_In <= parameters.Q_Under)
				   		  			   THEN state.Q_In * 0.9
				   		 			    ELSE parameters.Q_Under; 

   state.Q_Out = state.Q_In - state.Q_Under_Actual;


   state.f_Out = IF	(state.Q_In <= state.Q_Under_Actual)
		      	 		THEN 0
		      	 	  ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;
   state.f_Under = IF (state.Q_In <= state.Q_Under_Actual)
		          	 	THEN 1
		        			 ELSE state.Q_Under_Actual/state.Q_In ;

	  interface.Outflow[IndexOfSolvent] = - state.InFluxPerComponent[IndexOfSolvent] * state.f_Out ;
	  interface.Outflow[S_I] = - state.InFluxPerComponent[S_I] * state.f_sCOD ;
	  interface.Outflow[S_O] = - state.Q_Out * parameters.DO_out ;
	  interface.Outflow[S_N2] = - state.InFluxPerComponent[S_N2] * state.f_Out ;
	  interface.Outflow[S_F] = - state.InFluxPerComponent[S_F] * state.f_sCOD ;
	  interface.Outflow[S_A] = - state.InFluxPerComponent[S_A] * state.f_sCOD ;
	  interface.Outflow[S_Al] = - state.InFluxPerComponent[S_Al] * state.f_Out ;
	  interface.Outflow[S_NO] = - state.InFluxPerComponent[S_NO] * state.f_Out ;
	  interface.Outflow[S_NH] = - state.InFluxPerComponent[S_NH] * state.f_NH4 ;
	  interface.Outflow[S_PO] = - state.InFluxPerComponent[S_PO] * state.f_PO4 ;
	  interface.Outflow[S_ALK] = - state.InFluxPerComponent[S_ALK] * state.f_Out ;

    interface.Underflow[IndexOfSolvent] = IF	(state.Q_In <= state.Q_Under_Actual)
		  			 		   										  THEN - state.Q_In / 0.000001
		  			 		  										   ELSE - state.Q_Under_Actual / 0.000001 ;

    interface.Underflow[S_I] = - (state.InFluxPerComponent[S_I] + interface.Outflow[S_I]) ;
	  interface.Underflow[S_O] = 0;
	
	  {FOREACH Comp_Index IN {S_N2 .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]) ;};

      
      
      
      
      
      
      
      


    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out * state.f_TSS ;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = 
	   - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]);};

    state.X_In = 	IF (state.Q_In == 0)
			   			  	THEN 0
									 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out =  IF (state.Q_In <= state.Q_Under_Actual)
			 	  			  THEN 0
			 	  			  ELSE (- interface.Outflow[IndexOfTSSComponent] / (state.Q_In - state.Q_Under_Actual) );

    state.X_Under = IF (state.Q_In <= state.Q_Under_Actual) 
			  	  				THEN IF (state.Q_In == 0)
  		         	  		  THEN 0
		   	   		  			 ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
			  						ELSE IF (state.Q_Under_Actual == 0)
  		         	 		   THEN 0
		   	   		 			  ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_Under_Actual);
	  state.P_removed = interface.Inflow[S_PO] + interface.Outflow[S_PO];
   };
 :};

 CLASS sand_filter
 (* class = "primary_clarifier" *)
 "Model of a simple sand filter"				

 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
  interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
	  OBJ NO3_out (* terminal = "in_2"; manip = "1" *) "Effluent NO3" : 
         Concentration := {: causality <- "CIN" ; group <- "Operational" :};
	  OBJ PO4_out (* terminal = "in_2"; manip = "1" *) "Effluent PO4" : 
         Concentration := {: causality <- "CIN" ; group <- "Operational" :};
   };

  parameters <- 
   { 
    OBJ Q_BW "Backwash flow rate" : FlowRate := {: value <- 0 ; group <- "Operational" :};
   };

  state <-
   {
	  OBJ N_removed "N removed" : MassFlux := {: group <- "Operational" :};
	  OBJ P_removed "P removed" : MassFlux := {: group <- "Operational" :};
	  OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
    OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
    OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the overflow" : Fraction ;
    OBJ f_Under (* hidden = "1" *) "Fraction of the influent flux going to the underflow" : Fraction ;
    OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
   };

  equations <-
   {

   state.Q_Under_Actual = IF (state.Q_In <= parameters.Q_BW)
				   		  			   THEN state.Q_In * 0.9
				   		 			    ELSE parameters.Q_BW; 

   state.Q_Out = state.Q_In - state.Q_Under_Actual;

   state.f_Out = IF	(state.Q_In <= state.Q_Under_Actual)
		      	 		THEN 0
		      	 	  ELSE (state.Q_In - state.Q_Under_Actual) / state.Q_In ;
   state.f_Under = IF (state.Q_In <= state.Q_Under_Actual)
		          	 	THEN 1
		        			 ELSE state.Q_Under_Actual/state.Q_In ;

	  interface.Outflow[IndexOfSolvent] = - state.InFluxPerComponent[IndexOfSolvent] * state.f_Out ;
	  interface.Outflow[S_I] = - state.InFluxPerComponent[S_I] ;
	  interface.Outflow[S_O] = - state.InFluxPerComponent[S_O] ;
	  interface.Outflow[S_N2] = - state.InFluxPerComponent[S_N2];
	  interface.Outflow[S_F] = - state.InFluxPerComponent[S_F];
	  interface.Outflow[S_A] = - state.InFluxPerComponent[S_A];
	  interface.Outflow[S_Al] = - state.InFluxPerComponent[S_Al];
	  interface.Outflow[S_NO] = IF ((state.Q_Out * interface.NO3_out) > state.InFluxPerComponent[S_NO])
	 													 THEN - state.InFluxPerComponent[S_NO]
	 													 ELSE - state.Q_Out * interface.NO3_out;
	  interface.Outflow[S_NH] = - state.InFluxPerComponent[S_NH];
	  interface.Outflow[S_PO] = IF ((state.Q_Out * interface.PO4_out) > state.InFluxPerComponent[S_PO])
	 													 THEN - state.InFluxPerComponent[S_PO]
	 													 ELSE - state.Q_Out * interface.PO4_out;
	  interface.Outflow[S_ALK] = - state.InFluxPerComponent[S_ALK];

    interface.Underflow[IndexOfSolvent] = IF	(state.Q_In <= state.Q_Under_Actual)
		  			 		   										  THEN - state.Q_In / 0.000001
		  			 		  										   ELSE - state.Q_Under_Actual / 0.000001 ;

    interface.Underflow[S_I] = - (state.InFluxPerComponent[S_I] + interface.Outflow[S_I]) ;
	  interface.Underflow[S_O] = (state.InFluxPerComponent[S_O] + interface.Outflow[S_O]) ;
	
	  {FOREACH Comp_Index IN {S_N2 .. IndexOfLastSolubleComponent}:
     interface.Underflow[Comp_Index] = 
     - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]) ;};

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out;};   

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
     interface.Underflow[Comp_Index] = 
	   - (state.InFluxPerComponent[Comp_Index] + interface.Outflow[Comp_Index]);};

    state.X_In = 	IF (state.Q_In == 0)
			   			  	THEN 0
									 ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Out =  IF (state.Q_In <= state.Q_Under_Actual)
			 	  			  THEN 0
			 	  			  ELSE (- interface.Outflow[IndexOfTSSComponent] / (state.Q_In - state.Q_Under_Actual) );

    state.X_Under = IF (state.Q_In <= state.Q_Under_Actual) 
			  	  				THEN IF (state.Q_In == 0)
  		         	  		  THEN 0
		   	   		  			 ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_In)
			  						ELSE IF (state.Q_Under_Actual == 0)
  		         	 		   THEN 0
		   	   		 			  ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_Under_Actual);
	  
	  state.P_removed = state.InFluxPerComponent[S_PO] + interface.Outflow[S_PO];
	  state.N_removed = state.InFluxPerComponent[S_NO] + interface.Outflow[S_NO];
   };
 :};
 

# 29 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.primary_clarifier.msl" 2



# 38 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarypointsettler.msl" 1
 



















 CLASS SecondaryPointSettler
 (* icon = "secondary_clarifier" *)
 "Point-settler model for secondary clarifiers"
  EXTENDS PointSettler WITH
  {:
    comments <- "A model for a secondary point settler only using mass balances";
    parameters <-
    {
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.005 ; group <- "Settling" :};
    };
    equations <-
    {
    state.f_ns_help = parameters.f_ns ;
    };
  :};
  
 
    CLASS Empirical
    (* icon = "secondary_clarifier" *)
   "Empirical"				
  
   SPECIALISES PhysicalDAEModelType :=
   {:
    interface <-
     { 
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
           InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
      OBJ Outflow (* terminal = "out_1" *) "Overflow" : 
           OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
      OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
           OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		  OBJ X_out (* terminal = "out_3" *) "TSS out" : 
           Concentration := {: causality <- "COUT" ; group <- "Effluent" :};
  	  OBJ Q_Under (* terminal = "in_2" *) "Q_Under" : 
           FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  	  OBJ Inflow1 (* terminal = "in_2" *) "Measured plant inflow" : 
           FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
     };
  
    parameters <- 
     { 
  	  OBJ Q_a "f_ns=(Q_a*Q^Q_b)/Q" : Real := {: value <- 0.8 ; group <- "Clarification" :};
  	  OBJ Q_b "f_ns=(Q_a*Q^Q_b)/Q" : Real := {: value <- 0.8 ; group <- "Clarification" :};
  	  OBJ f_ns_DW "Non-settleable fraction of suspended solids in DWF" : Fraction := {: value <- 0.0005 ; group <- "Clarification" :};
  	  OBJ A "Surface of secondary clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
      OBJ H "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
  	  OBJ t_tol "Minimum time for start and stop of clarification problems" : Time := {: value <- 0.01 ; group <- "Clarification" :};
  	  OBJ Q_ON "Flow rate for start of clarification problems" : FlowRate := {: value <- 40000 ; group <- "Clarification" :};	
  	  OBJ Q_OFF "Flow rate for stop of clarification problems" : FlowRate := {: value <- 40000 ; group <- "Clarification" :};
  	  OBJ t_delay "f_ns = (t_start/t_delay)^t_delay_exp" : Time := {: value <- 0.25 ; group <- "Clarification" :};
  	  OBJ t_delay_exp "f_ns = (t_start/t_delay)^t_delay_exp" : Real := {: value <- 2 ; group <- "Clarification" :};
  	  OBJ t_after "f_ns = max_after - ((t-t_stop)/t_after)^t_after_exp" : Time := {: value <- 1 ; group <- "Clarification" :};
  	  OBJ t_after_exp "f_ns = max_after - ((t-t_stop)/t_after)^t_after_exp" : Real := {: value <- 0.5 ; group <- "Clarification" :};
  	  OBJ max_after "f_ns = max_after - ((t-t_stop)/t_after)^t_after_exp" : Real := {: value <- 2 ; group <- "Clarification" :};
  	  OBJ DW_Q_exp "Exponent for DW Q dependency, (Q/Q_ON)^DW_Q_exp" : Real := {: value <- 0.5 ; group <- "Clarification" :};
  	  OBJ C_c "Average TSS concentration entering the SST" : Concentration := {: value <- 4500 ; group <- "Clarification" :};
  	  	
  	  OBJ Q_ONs "Flow rate for start of settling problems" : FlowRate := {: value <- 40000 ; group <- "Settling" :};
  	  OBJ f_s_DW "fs1=f_s_DW*1000*f_ns" : Real := {: value <- 4; group <- "Settling" :};  	
  	  OBJ Q_as "fs2=Q_as*Q_ONs/Q" : Real := {: value <- 0.5 ; group <- "Settling" :};
  	  OBJ C_s "fs3=C_s*TSS" : Real := {: value <- 0.001 ; group <- "Settling" :};
  	  
  	  OBJ T_Average "Averaging time used for the inflow" : Time := {: value <- 0.1; group <- "" :};
     };
  	 
  	independent <- 
     { 
      OBJ t "Time"  : Time := {: group <- "Time" :}; 
     };
  
    state <-
     {
  	  OBJ V (* is_favorite = "1" *) "Volume" : Volume := {: group <- "Operational" :};
  	  OBJ M "Vector containing masses for all the components" : MassVector := {: group <- "Operational" :};
  	  OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};	
      OBJ C "Vector containing concentrations for all the components" : ConcentrationVector := {: group <- "Operational" :}; 
  	  OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Q_Under_Actual "Underflow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Q_Under_Actual_h "Underflow rate" : FlowRate := {: group <- "Operational" :};
      OBJ Help_X_In (* hidden = "1" *) "" : MassFlux;
      OBJ Help_X_Out (* hidden = "1" *) "" : MassFlux;
      OBJ Help_X_Under (* hidden = "1" *) "" : MassFlux;
      OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Operational" :};
      OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Operational" :};
      OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Operational" :};
  	  OBJ f_ns "Non-settleable fraction of suspended solids" : Real := {: group <- "Clarification" :};
  	  OBJ thelp (* hidden = "1" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ tstart (* hidden = "0" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ tstop (* hidden = "0" *) "Help variable to calculate the time from stop of event" : Real := {: group <- "Clarification" :};
  	  OBJ ON (* hidden = "0" *) "True if 1, False if 0" : Integer := {: group <- "Clarification" :};  
  	  OBJ counter (* hidden = "1" *) "Counts the number of starts" : Integer := {: group <- "Clarification" :};
  	  OBJ t_fromstart (* hidden = "1" *) "Help variable to calculate the time from start of event" : Real := {: group <- "Clarification" :};
  	  OBJ Inflow11 (* hidden = "0" *) "Effluent flow rate" : FlowRate := {: group <- "Clarification" :};
  	  OBJ fns1 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns2 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns3 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns4 (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ fns4_h (* hidden = "0" *) "Help variable" : Real := {: group <- "Clarification" :};
  	  OBJ tstart1 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  OBJ tstart2 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  OBJ tstart3 (* hidden = "1" *) "Help variable" : Boolean := {: group <- "Clarification" :};
  	  
  	  OBJ Underflow_help (* hidden = "1" *) "Underflow suspended solids concentration" : MassFluxVector := {: group <- "Settling" :};
  	  OBJ f_s "Settleable fraction of suspended solids" : Real := {: group <- "Settling" :};
  	  OBJ fs1 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
  	  OBJ fs2 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
  	  OBJ fs3 (* hidden = "0" *) "Help variable" : Real := {: group <- "Settling" :};
      
  	 
     };
     
    initial <-  
     {
  	  state.M[IndexOfSolvent] = parameters.A * parameters.H / 0.000001;
      state.ON = 0;
  	  state.tstart = 0;
  	  state.thelp = 0;
  	  state.tstop = 0;
  	  state.counter = 0;				
     };
  
    equations <-
     {
  		state.Q_In = (0.000001 * interface.Inflow[IndexOfSolvent]);
      
  		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       DERIV(state.M[Comp_Index],[independent.t]) = interface.Inflow[Comp_Index] + interface.Outflow[Comp_Index] + interface.Underflow[Comp_Index] ;};
  						
       DERIV(state.Inflow11,[independent.t]) = (interface.Inflow1 - state.Inflow11) / parameters.T_Average;
  	 
  	   state.tstart1 = previous(state.ON) == 0;
  	   state.tstart2 = state.Inflow11 > parameters.Q_ON;
  	   state.tstart3 =  previous(state.Inflow11) <= parameters.Q_ON;
  	 
  	   state.tstart = IF ((previous(state.ON) == 0) && (state.Inflow11 > parameters.Q_ON) && (previous(state.Inflow11) <= parameters.Q_ON))
  	 		  	  	      THEN independent.t
  					          ELSE previous(state.tstart);
  	   state.counter = IF ((previous(state.ON) == 0) && (state.Inflow11 > parameters.Q_ON) && (previous(state.Inflow11) <= parameters.Q_ON))
  	 		  	  	       THEN previous(state.counter) + 1
  					           ELSE previous(state.counter);
  	   state.thelp = IF (state.counter > 0)
  	 		  	         THEN independent.t - state.tstart
  				           ELSE 0;
  	   state.tstop = IF ((previous(state.ON) == 1) && (state.Inflow11 < parameters.Q_OFF) && (previous(state.Inflow11) >= parameters.Q_OFF))
  	 		  	         THEN independent.t
  				           ELSE previous(state.tstop);
  	   state.ON = IF ((state.thelp > parameters.t_tol) && (state.tstop < state.tstart))
  	 		  	      THEN 1
  				        ELSE 0;	
  	
  	   state.t_fromstart = IF ((state.ON == 0) && (state.Inflow11 <= parameters.Q_OFF))
  				  	             THEN 0 
  					               ELSE IF (state.thelp < parameters.t_delay)
  						                  THEN state.thelp
  						                  ELSE parameters.t_delay;
  	
  	   state.fns1 = IF (state.X_In < 100)
  	                THEN parameters.f_ns_DW * pow(state.Inflow11 / parameters.Q_ON,parameters.DW_Q_exp)
  	                ELSE parameters.f_ns_DW * pow(state.Inflow11 / parameters.Q_ON,parameters.DW_Q_exp) * parameters.C_c / state.X_In;
  	   
  	   state.fns2 = IF (state.Inflow11 > parameters.Q_OFF)
								    THEN parameters.Q_a * pow((state.Inflow11-parameters.Q_OFF),parameters.Q_b) / state.Inflow11
								    ELSE 0;
								    
  	   state.fns3 = pow((state.t_fromstart/parameters.t_delay),parameters.t_delay_exp);
  	   
  	   state.fns4_h = parameters.max_after - pow(((independent.t - state.tstop)/parameters.t_after),parameters.t_after_exp);
  	   
  	   state.fns4 = IF (state.fns4_h <= 0)
  							    THEN 0
  							    ELSE state.fns4_h;
  	
  	   state.f_ns = IF ((state.ON == 0) || (state.Inflow11 <= parameters.Q_ON))
  				          THEN state.fns1 * (1 + state.fns4)
  				          ELSE state.fns1 * (1 + state.fns4) + state.fns2 * state.fns3; 
  				          
  		 state.fs1 = IF (state.Inflow11 < parameters.Q_ONs)
								   THEN (parameters.f_s_DW - state.f_ns)
								   ELSE 1;
  		 
  		 state.fs2 = IF (state.Inflow11 > parameters.Q_ONs)
								   THEN parameters.Q_as * parameters.Q_ONs / state.Inflow11
								   ELSE 1;
								   
			 state.fs3 = IF (parameters.C_s * state.C[X_TSS] > 2)
								   THEN 2
								   ELSE IF (parameters.C_s * state.C[X_TSS] < 0.5)
								        THEN 0.5
								        ELSE parameters.C_s * state.C[X_TSS];
								   
			 state.f_s =  
								    
								    
								   state.fs1 * state.fs2 * state.fs3 - state.f_ns;
  	
  	   DERIV(state.Q_Under_Actual,[independent.t]) = (interface.Q_Under - state.Q_Under_Actual) / parameters.T_Average;
  	   state.Q_Under_Actual_h = IF (state.Q_In <= state.Q_Under_Actual)
  				   		                THEN 0.5 * state.Q_In
  				   		                ELSE state.Q_Under_Actual; 
  
       state.Q_Out = state.Q_In - state.Q_Under_Actual_h;
  					
  	   state.V = 0.000001*state.M[IndexOfSolvent];
  	
  	   {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.C[Comp_Index] = IF (state.V == 0)
  				                    THEN 0
  				                    ELSE state.M[Comp_Index]/state.V;};
  
       {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
        interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
  				                              THEN 0
  				                              ELSE - interface.Inflow[Comp_Index] * (state.Q_Out / state.Q_In);};
  
       {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
        interface.Underflow[Comp_Index] = IF (state.Q_In == 0)
  				                                THEN 0
  				                                ELSE - interface.Inflow[Comp_Index] * (state.Q_Under_Actual_h / state.Q_In) ;};
  
       {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        interface.Outflow[Comp_Index] = IF (state.Q_In == 0)
  				   		                        THEN 0
  							                        ELSE - interface.Inflow[Comp_Index] * state.f_ns ;};   
  
       {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        state.Underflow_help[Comp_Index] = IF (state.Q_In == 0)
  				   		   			                   THEN 0
  										                     ELSE - interface.Inflow[Comp_Index] * state.f_s * (state.M[Comp_Index] - 100000) / state.M[Comp_Index] ;};
     
  	   {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
        
        interface.Underflow[Comp_Index] = state.Underflow_help[Comp_Index];};
  
        state.X_In = 	IF (state.Q_In == 0)
  			   		        THEN 0
  					          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;
  
        state.X_Out =  IF (state.Q_In == 0)
    		         	     THEN 0
  		   	   		       ELSE IF (state.Q_Out <= (0.5 * state.Q_In))
  		   	   		            THEN (- interface.Outflow[IndexOfTSSComponent] / (0.5 * state.Q_In))
  		   	   		            ELSE (- interface.Outflow[IndexOfTSSComponent] / state.Q_Out);
  
        state.X_Under = IF ((0.5 * state.Q_In) <= interface.Q_Under) 
  			  	  	        THEN IF (state.Q_In == 0)
    		         	           THEN 0
  		   	   		             ELSE - interface.Underflow[IndexOfTSSComponent] / (0.5 * state.Q_In)
  			  		          ELSE IF (interface.Q_Under == 0)
    		         	           THEN 0
  		   	   		             ELSE - interface.Underflow[IndexOfTSSComponent] / (state.Q_Under_Actual);

        interface.X_out = state.X_Out;
     };
 :};
  
 




# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.marsililibelli.msl" 1
 



















 CLASS MarsiliLibelli
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
  {:
 
 
 
 
 
 
 
 
 
 
 
 
 
   Comments <- "A model for a secondary settler by Marsili Libelli";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

  parameters <- 
   { 
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ A (* is_favorite = "1" *) "Surface of secondary clarifier" : Area := {: value <- 400 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of secondary clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Limit sedimentation velocity for diluted suspensions" : Velocity := {: value <- 4 ; group <- "Settling" :};
    OBJ N "Cole sludge concentration dependency parameter" : Real := {: value <- 2.75 ; group <- "Settling" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

  state <-
   {
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ J_T "Total sludge flux" : ArealFlux := {: group <- "Settling" :};
    OBJ help (* hidden = "1" *) "Help variable" : Real;
    OBJ AA (* hidden = "1" *) "Help variable" : Real;
    OBJ U "Underflow velocity" : Velocity := {: group <- "Settling" :};
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ M "Mass of sludge in secondary clarifier" : Mass := {: group <- "Mass" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_L "Limiting sludge biomass concentration" : Concentration := {: group <- "Settling" :};
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

  equations <-
   {           
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 
    
    state.U = state.Q_Under_Actual / parameters.A;

    state.AA = 1 - parameters.N;
    state.help = IF (state.U == 0)
         THEN 0
         ELSE log(-state.U / (state.AA * parameters.v0)) ;

    state.J_T = 1000 * (parameters.v0 * exp(state.AA / (state.AA - 1) * state.help) + state.U *
               exp(1 / (state.AA - 1) * state.help));
    state.X_L = 1000 * exp(1 / (state.AA - 1) * state.help);

    state.Q_Out = state.Q_In - state.Q_Under_Actual;

    state.H_S = state.M / state.X_L / parameters.A;

    state.X_Out = IF (state.H_S <= parameters.H)
                THEN 0
                ELSE state.X_L;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0 
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };

    state.X_Under = IF (( state.SolidFlux_In) >= (parameters.A *state.J_T))   
          THEN
              IF (state.Q_Under_Actual == 0)
          THEN 0 
          ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                    ELSE
                      IF (state.H_S > 0)
                      THEN
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE (parameters.A *state.J_T) / state.Q_Under_Actual
                      ELSE
        IF (state.Q_Under_Actual == 0)
        THEN 0 
        ELSE state.SolidFlux_In / state.Q_Under_Actual;

    {DERIV(state.M,[independent.t]) =
             IF (state.SolidFlux_In >= (parameters.A * state.J_T))
             THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
             ELSE
               IF (state.H_S > 0)
               THEN state.SolidFlux_In - state.SolidFlux_Under - state.SolidFlux_Out
               ELSE 0;
    };

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
interface.Overflow[Comp_Index] = 
IF (state.Q_In == 0)
    THEN 0 
    ELSE
- state.InFluxPerComponent[Comp_Index] * state.Q_Out / state.Q_In;
      };

       interface.Underflow[IndexOfSolvent] = 
              - state.Q_Under_Actual / 0.000001;

    {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
       interface.Underflow[Comp_Index] = 
 - (state.InFluxPerComponent[Comp_Index]
        + interface.Overflow[Comp_Index]) ;
     };

    interface.TSS = state.M /(parameters.A * parameters.H);

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };
 :};




# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondaryotterpohlfreund.msl" 1
 



















 CLASS SecondaryOtterpohlFreund
 (* icon = "secondary_clarifier" *)
 "secondary clarifier"
 EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
 
 
 
 
 
 
 
 
 
 
 
 
 
 

   Comments <- "A model for a secondary settler by Otterpohl and Freund";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge volume index" : Real := 
        {: 
          causality <- "CIN" ; 
      value <- 100;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; upperBound <- 1000; :};
        :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v_FS "Settling velocity for small fraction of solids" : Velocity := {: value <- 0.24 ; group <- "Settling" :};
    OBJ f0 "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.04;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ A_FS "Parameter for the calculation of the small solids fraction" : Real :=
        {: 
          value <- 0.00078;
      group <- "Settling";
          interval  <- {: lowerBound <- 0; :};
        :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ J_Up_FS (* hidden = "1" *) "Upward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Up_FM (* hidden = "1" *) "Upward sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_Dn_FS (* hidden = "1" *) "Downward sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_Dn_FM (* hidden = "1" *) "Downward sludge flux macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FS (* hidden = "1" *) "Static sludge flux of the small solids fraction" : TakacsArealFluxVector;
    OBJ J_G_FM (* hidden = "1" *) "Static sludge flux of the macroflocs" : TakacsArealFluxVector;
    OBJ J_G_FM_Help (* hidden = "1" *) "Static sludge flux of the macroflocs": TakacsArealFluxVector;
    OBJ J_G_FS_Help (* hidden = "1" *) "Static sludge flux of the small solids fraction": TakacsArealFluxVector;
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;

    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};

    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    
    OBJ X_FM_Layer "Vector containing concentration of macroflocs for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ X_FS_Layer "Vector containing concentration of small solids  for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
    OBJ v_FM "Settling velocity for macroflocs" : TakacsVelocityVector := {: group <- "Settling" :};
    OBJ f1 "Fraction of small solids" : Fraction := {: group <- "Influent characterization" :};
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  

     
    OBJ B (* hidden = "1" *) "variable B of the omega function" : Real ;
    OBJ help_var_omega (* hidden = "1" *) "help state" : Real ;
    
    OBJ H_T "Height of transition point" : Length := {: group <- "Settling" :};
    OBJ H_C "Height of compressing point" : Length := {: group <- "Settling" :};
    OBJ H0 "Height of influent" : Length := {: group <- "Dimension" :};
    OBJ omega (* hidden = "1" *) "Hartels omega function" : Real[NrOfLayers;] ;
    OBJ z (* hidden = "1" *) "Vertical coordinate, bottom z=0" : LengthVector ;
    OBJ X_C "Solids concentration at compression point" : Concentration := {: group <- "Settling" :};
    OBJ X_AT "Solids concentration of the aeration tank" : Concentration := {: group <- "Concentration" :};
    OBJ X_FM_AT "Solids concentration of the aeration tank, macroflocs" : Concentration := {: group <- "Concentration" :};
    OBJ X_FS_AT "Solids concentration of the aeration tank, small solids" : Concentration := {: group <- "Concentration" :};
    OBJ k (* hidden = "1" *) "Part of the Vesilind equation, here results of Hartel" : Real ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of small solids and macroflocs" : Concentration ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
    state.H0 = ((NrOfLayers - IndexOfFeedLayer) + 0.5) * state.H_Layer;
    state.X_C = 480 / interface.SVI ;
    state.k = 1.043 - 0.9834 * exp( -0.00581 * interface.SVI) ;
    state.help_var_omega = -(1 + 2 * interface.SVI / (100 + interface.SVI));

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
     state.z[Layer_Index] =
        ((NrOfLayers - Layer_Index) + 0.5) * state.H_Layer ;
    };

   };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under; 

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


     
     
     
    state.B = - (( 100 + interface.SVI) / interface.SVI + 1)
                * pow(state.H_C, (1 + 2 * interface.SVI / (100 + interface.SVI)));

    

    state.H_T = IF(2 * state.H_C > state.H0)
                THEN state.H0
                ELSE 2 * state.H_C ;

    state.H_C = (state.X_AT * state.H0 / state.X_C) * (1 - 1 / (state.X_C * state.k)) ;
    state.X_AT = IF (state.Q_In == 0 )
             THEN 0
         ELSE state.SolidFlux_In / state.Q_In;

 
 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.omega[Layer_Index] = IF (state.H_T == 0)
             THEN 1 / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega))
             ELSE (1 - state.B * pow(state.H_T,state.help_var_omega))
              / (1 - state.B * pow(state.z[Layer_Index], state.help_var_omega));
    };

    state.f1 = parameters.f0 * exp( - parameters.A_FS * state.X_AT) ;

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.v_FM[Layer_Index] = 
             (17.4 * exp(-0.00581 * interface.SVI) + 3.931)
             * (exp(-(-0.9834e-3 * exp(-0.00581 * interface.SVI) + 1.043e-3)
                       * (state.X_FM_Layer[Layer_Index] + state.X_FS_Layer[Layer_Index])))
             * 24 ;
    };

     
     
     

    state.X_FM_AT = state.X_AT * (1 - state.f1) ;
    state.X_FS_AT = state.X_AT * state.f1 ;

    state.v_Up = state.Q_Out / parameters.A; 
    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FM_Help[Layer_Index] =
        state.v_FM[Layer_Index] * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_FS_Help[Layer_Index] =
        parameters.v_FS * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FS[Layer_Index] =
        state.v_Up * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up_FM[Layer_Index] =
        state.v_Up * state.X_FM_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FS[Layer_Index] =
        state.v_Dn * state.X_FS_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn_FM[Layer_Index] =
        state.v_Dn * state.X_FM_Layer[Layer_Index];
    };

     
     
     
     

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FS[Layer_Index] =
        IF (state.J_G_FS_Help[Layer_Index] > state.J_G_FS_Help[Layer_Index+1])
        THEN state.J_G_FS_Help[Layer_Index+1]
        ELSE state.J_G_FS_Help[Layer_Index] ;
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayersButOne}:
       state.J_G_FM[Layer_Index] =
        IF (state.J_G_FM_Help[Layer_Index] > state.J_G_FM_Help[Layer_Index+1])
        THEN state.J_G_FM_Help[Layer_Index+1]
        ELSE state.J_G_FM_Help[Layer_Index] ;
    };

     
     
     

    { DERIV(state.X_FS_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FS[2] - state.J_G_FS[1] - ( state.Q_Out / parameters.A * state.X_FS_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FS_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FS[Layer_Index] - state.J_Up_FS[Layer_Index]
             + state.J_G_FS[Layer_Index-1]
             - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * state.f1
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FS[Layer_Index+1] - ( state.J_Up_FS[Layer_Index])
                - state.J_G_FS[Layer_Index] + state.J_G_FS[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FS[Layer_Index-1] - ( state.J_Dn_FS[Layer_Index])
                + (state.J_G_FS[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FS[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FS_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FS[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FS_Layer[NrOfLayers])
       + (state.J_G_FS[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    { DERIV(state.X_FM_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * 
       (state.J_Up_FM[2] - state.J_G_FM[1] - ( state.Q_Out / parameters.A * state.X_FM_Layer[1]));
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_FM_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             ( - state.J_Dn_FM[Layer_Index] - state.J_Up_FM[Layer_Index]
             + state.J_G_FM[Layer_Index-1]
             - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]))
             + (1 / state.V_Layer) * state.SolidFlux_In * (1 - state.f1)
        ELSE
          IF(Layer_Index < IndexOfFeedLayer)
          THEN (1 / state.H_Layer) *
                (state.J_Up_FM[Layer_Index+1] - ( state.J_Up_FM[Layer_Index])
                - state.J_G_FM[Layer_Index] + state.J_G_FM[Layer_Index-1])
          ELSE (1 / state.H_Layer) *
                (state.J_Dn_FM[Layer_Index-1] - ( state.J_Dn_FM[Layer_Index])
                + (state.J_G_FM[Layer_Index-1] * state.omega[Layer_Index-1])
                - (state.J_G_FM[Layer_Index] * state.omega[Layer_Index]));
    };

    { DERIV(state.X_FM_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn_FM[NrOfLayersButOne] - ( state.Q_Under_Actual / parameters.A * state.X_FM_Layer[NrOfLayers])
       + (state.J_G_FM[NrOfLayersButOne] * state.omega[NrOfLayersButOne]));
    };

     
     
     

    state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_FS_Layer[1] + state.X_FM_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_FS_Layer[NrOfLayers] + state.X_FM_Layer[NrOfLayers];

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] = 
      IF (state.Q_In == 0)
      THEN 0
      ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
      IF ( state.SolidFlux_In == 0)
      THEN 0
      ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    }; 

    { state.SolidConcentration = (SUMOVER Layer_Index IN {1 .. NrOfLayers}:
       state.X_FS_Layer[Layer_Index] + state.X_FM_Layer[Layer_Index]) ;
    };

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacs.msl" 1
 



















 
 
 

 CLASS Takacs
 (* icon = "secondary_clarifier"*)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
   
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] = IF (state.Q_In == 0)
    																		THEN 0
	 																		 ELSE IF (state.SolidFlux_In == 0)
																						 THEN 0
   																					ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};




# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.takacssvi.msl" 1
 




















 CLASS Takacs_SVI
 (* icon = "secondary_clarifier"; is_default = "true" *)
 "Layered clarifier model by Takacs"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
	  OBJ Q_Out1_min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Outflow1 min rate" : 
         FlowRate := {: causality <- "CIN" ; value <- 50; group <- "Operational" :};
    OBJ SVI (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge Volume Index in mL/g" : 
         Real := {: causality <- "CIN" ; value <- 100 ; group <- "Settling" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
         Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
         Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
   
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)  "Volume of the layer" : Volume ;  
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.r_H = (0.148 + 0.00210 * interface.SVI) / 1000;

    state.Q_Under_Actual = IF ((state.Q_In - interface.Q_Out1_min) <= interface.Q_Under)
         THEN (state.Q_In - interface.Q_Out1_min)
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
      THEN 0
      ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

 
    state.v0_H = parameters.v0 * exp(state.r_H * state.X_Min); 

    state.v_Up = state.Q_Out / parameters.A; 

 








    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
         THEN parameters.v00
         ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
         IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
         THEN state.J_G_Help[Layer_Index]
         ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

    { DERIV(state.X_Layer[1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1]) -
       (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    };

    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]);
    };

    { DERIV(state.X_Layer[NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) *
       (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne]) -
       (interface.Q_Under / state.V_Layer) * state.X_Layer[NrOfLayers];
    };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.Q_In == 0)
        THEN 0
    ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
    IF (state.SolidFlux_In == 0)
    THEN 0
    ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
    IF (state.Q_In == 0)
    THEN 0
		ELSE IF (state.SolidFlux_In == 0)
				 THEN 0
    		 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

 
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};





# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl" 1
 


















# 475 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacssolublespropagator.msl"



# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.base.secondary_clarifier.secondarytakacsallfractionpropagator.msl" 1
 



















 CLASS SecondaryTakacsAllFractionPropagator
 (* icon = "secondary_clarifier" *)
 "Layered Takacs clarifier model + fractionation of components"

 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:

   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
    FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    OBJ Sludge_Blanket_Height (* terminal = "out_3"; is_favorite = "1" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
   };

   parameters <- 
   {     
  
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling" :}; 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 1000 ; group <- "Settling" :};
    OBJ X_T "Threshold suspended solids concentration" : Concentration := {: value <- 3000 ; group <- "Settling" :};
    OBJ F_TSS_COD (* hidden = "1" *) "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of layer top of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Concentration of particulates in the effluent" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Concentration of particulates in the underflow" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Concentration of particulates in a layer" : TakacsConcentrationVector := {: group <- "Concentration" :};
    OBJ C "Concentration for all the components per layer" : LayerConcentrationMatrix := {: group <- "Concentration" :};
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ; 
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : TakacsVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help term": TakacsVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : TakacsArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : TakacsArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : TakacsArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux help term": TakacsArealFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Massflux per component" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ V_Layer (* hidden = "1" *) "Volume of layer" : Volume ; 
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ D_Out "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ D_Under "Dilution rate per layer" : Rate := {: group <- "Settling" :};
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-

 

   {
   
    state.V_Layer = parameters.A * (parameters.H / NrOfLayers); 
    state.H_Layer = parameters.H / NrOfLayers;
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 

 

    state.D_Out = state.Q_Out / state.V_Layer;

    state.D_Under = state.Q_Under_Actual / state.V_Layer;

 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
                        THEN 0
                        ELSE state.SolidFlux_In / state.Q_In;
     };

 









{ FOREACH Layer_Index IN {1 .. NrOfLayers}:
state.X_Layer[Layer_Index] = state.C[IndexOfTSSComponent][Layer_Index];
};


 

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {1 .. NrOfLayers}:
                                         state.X_Layer[Layer_Index]) / NrOfLayers;
    };

    state.X_Min = IF (state.Q_In == 0)
      THEN parameters.f_ns * state.SolidConcentration
      ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);

    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min);

    state.v_Up = state.Q_Out / parameters.A; 

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S_Help[Layer_Index] =
        IF (state.X_Layer[Layer_Index] < state.X_Min) 
        THEN 0 
        ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
    };

    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.v_S[Layer_Index] =
        (IF (state.v_S_Help[Layer_Index] > parameters.v00)
        THEN parameters.v00
        ELSE state.v_S_Help[Layer_Index]);
    }; 
        
    { FOREACH Layer_Index IN {1 .. NrOfLayers}:
       state.J_G_Help[Layer_Index] =
        state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {2 .. IndexOfFeedLayer}:
       state.J_G[Layer_Index-1] =
        IF (state.X_Layer[Layer_Index] < parameters.X_T)
        THEN state.J_G_Help[Layer_Index-1]
        ELSE
        IF (state.J_G_Help[Layer_Index-1] > state.J_G_Help[Layer_Index])
        THEN state.J_G_Help[Layer_Index]
        ELSE state.J_G_Help[Layer_Index-1];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayer .. NrOfLayersButOne}:
       state.J_G[Layer_Index] =
        IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1])
        THEN state.J_G_Help[Layer_Index+1]
        ELSE state.J_G_Help[Layer_Index] ;
    };

 


{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
   { DERIV(state.C[Comp_Index][1],[independent.t]) =
       state.D_Out * (state.C[Comp_Index][2] - state.C[Comp_Index][1]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.V_Layer) *
             (state.InFluxPerComponent[Comp_Index] 
       - state.Q_In * state.C[Comp_Index][IndexOfFeedLayer])
        ELSE
        IF (Layer_Index < IndexOfFeedLayer)
        THEN state.D_Out * 
     (state.C[Comp_Index][Layer_Index+1] - state.C[Comp_Index][Layer_Index])
        ELSE state.D_Under * 
         (state.C[Comp_Index][Layer_Index-1] - state.C[Comp_Index][Layer_Index]);
    }; 
 };

{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
    { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       state.D_Under * (state.C[Comp_Index][NrOfLayersButOne] - state.C[Comp_Index][NrOfLayers]);
    };
 };

 

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
  { DERIV(state.C[Comp_Index][1],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Up[2] * state.C[Comp_Index][2] / state.X_Layer[2]
       - state.J_G[1] * state.C[Comp_Index][1] / state.X_Layer[1]) - state.D_Out * state.C[Comp_Index][1];
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
    { FOREACH Layer_Index IN {2 .. NrOfLayersButOne}:
       DERIV(state.C[Comp_Index][Layer_Index],[independent.t]) =
        IF (Layer_Index == IndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (state.J_G[Layer_Index-1] * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             - (state.J_G[Layer_Index] + state.J_Up[Layer_Index] + state.J_Dn[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index])
             + (1 / state.V_Layer) * state.InFluxPerComponent[Comp_Index]
        ELSE (1 / state.H_Layer) *
             ((state.J_G[Layer_Index-1] + state.J_Dn[Layer_Index-1]) 
             * state.C[Comp_Index][Layer_Index-1] / state.X_Layer[Layer_Index-1]
             + state.J_Up[Layer_Index+1] * state.C[Comp_Index][Layer_Index+1] / state.X_Layer[Layer_Index+1]
             - (state.J_G[Layer_Index] + state.J_Dn[Layer_Index] + state.J_Up[Layer_Index])
             * state.C[Comp_Index][Layer_Index] / state.X_Layer[Layer_Index]);
    };
 };

{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   { DERIV(state.C[Comp_Index][NrOfLayers],[independent.t]) =
       (1 / state.H_Layer) * (state.J_Dn[NrOfLayersButOne] + state.J_G[NrOfLayersButOne])
       * state.C[Comp_Index][NrOfLayersButOne] / state.X_Layer[NrOfLayersButOne]
       - state.D_Under * state.C[Comp_Index][NrOfLayers];
    };
 };

    state.X_Out = IF (state.Q_Out == 0)
      THEN 0
      ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
        THEN 0
        ELSE state.X_Layer[NrOfLayers];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayers,parameters.X_Lim);

    state.H_S = (NrOfLayers - state.IndexOfSludgeBlanket + 1) *
                state.H_Layer;

 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out / parameters.F_TSS_COD ;

    interface.Overflow[IndexOfSolvent] = -state.Q_Out / 0.000001;

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Overflow[Comp_Index] = - state.C[Comp_Index][1] * state.Q_Out ;
};

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual / parameters.F_TSS_COD ;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

 
 

{ FOREACH Comp_Index IN {2 .. NrOfComponents}:
    interface.Underflow[Comp_Index] = - state.C[Comp_Index][NrOfLayers] * state.Q_Under_Actual;
};

    interface.Sludge_Blanket_Height = state.H_S;
 
    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  

   
  DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;

   };

 :};




# 26 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burgerdoubleexponential.msl" 1
 





 
 






  OBJ Legendre_Index "Temporary iteration variable, index of Gaussian quadrature" : Integer;
  OBJ NrOfNodes "The number of nodes and weights used in the Gaussian Quadrature for compression calculation" : Integer := 16; 

CLASS BurgerDoubleExponential
 (* icon = "secondary_clarifier" ; is_default = "" *)
 "Layered clarifier model by Burger with double exponential settling function"

 

 SPECIALISES PhysicalDAEModelType :=
 {:
   comments <- "A model for a secondary settler by Takacs";
   interface <-
   { 
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Overflow (* terminal = "out_1" *) "Overflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    OBJ Underflow (* terminal = "out_2" *) "Underflow" : 
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
    OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : 
        Length := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : 
        Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : 
        Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : 
	 		 FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
   
    OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
    OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
  	OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling" :}; 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling" :};
	  OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};


    
      
 
 
	 
    
      
       OBJ NoComp "Parameter to switch off compression": Integer :={: value <- 1 ; group <- "Compression" :};
	   OBJ alpha "Effective solids stress parameter" : NormalStress := {: value <- 5 ; group <- "Compression" :};
       OBJ beta "Effective solids stress parameter" : Concentration := {: value <- 4 ; group <- "Compression" :};
	   OBJ rhos "Solid density": Density := {: value <- 1050 ; group <- "Compression" :};
	   OBJ rhof "Fluid density": Density := {: value <- 998 ; group <- "Compression" :};
	   OBJ C_crit "Gel point" : Concentration := {: value <- 600 ; group <- "Compression" :};
	   OBJ gr "Acceleration of gravity": Acceleration := {: value <- 9.81 ; group <- "Compression" :};
	   OBJ wl (* hidden = "1" *) "Vector of Legendre weights used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 2.715245941175406e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 9.515851168249290e-2 :},
		   {: value <- 1.246289712555339e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.691565193950026e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.894506104550684e-1 :},{: value <- 1.894506104550684e-1 :},{: value <- 1.826034150449236e-1 :},
		   {: value <- 1.691565193950026e-1 :},{: value <- 1.495959888165768e-1 :},{: value <- 1.246289712555339e-1 :},
		   {: value <- 9.515851168249290e-2 :},{: value <- 6.225352393864778e-2 :},{: value <- 2.715245941175406e-2 :}]; 
	   OBJ nl (* hidden = "1" *) "Vector of Legendre nodes used in the Gaussian quadrature for the calculation of compression": 
	   	   Real[NrOfNodes;] := [{: value <- 9.894009349916499e-1 :},{: value <- 9.445750230732326e-1 :},{: value <- 8.656312023878319e-1 :},
		   {: value <- 7.554044083550031e-1 :},{: value <- 6.178762444026438e-1 :},{: value <- 4.580167776572273e-1 :},{: value <- 2.816035507792589e-1 :},
		   {: value <- 9.501250983763748e-2 :},{: value <- -9.501250983763748e-2 :},{: value <- -2.816035507792589e-1 :},
		   {: value <- -4.580167776572273e-1 :},{: value <- -6.178762444026438e-1 :},{: value <- -7.554044083550031e-1 :},
		   {: value <- -8.656312023878319e-1 :},{: value <- -9.445750230732326e-1 :},{: value <- -9.894009349916499e-1 :}];
	    
	   OBJ C_min "Minimal packing concentration" : Concentration := {: value <- 0 ; group <- "Settling" :};
	   OBJ C_max "Maximal packing concentration" : Concentration := {: value <- 2000 ; group <- "Settling" :};
	   OBJ TOL "Tolerance level to calculate CHat" : Fraction := {: value <- 1e-15 ; group <- "Settling" :};     
   };

   state <-
   {
    
    
	OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
	OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};	
    OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};	 
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
	OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v_S (* hidden = "0" *) "Static settling velocity" : BurgerVelocityVector;
    OBJ J_Up "Upward sludge flux" : BurgerArealFluxVector;
    OBJ J_Dn "Downward sludge flux" : BurgerArealFluxVector;
    OBJ J_G "Static sludge flux" : BurgerArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
	OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
	OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;

	
	 
	   
       
 
 

    
	 
	   
	    OBJ X_comp (* hidden = "1" *) "Vector with max(Cj,Ccrit)" : BurgerConcentrationVector := {: group <- "Concentration" :};
	    OBJ J_comp_help (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ J_comp (* hidden = "1" *) "Compression sludge flux" : BurgerArealFluxVector;
		OBJ HelpPar1 (* hidden = "1" *) "rhos*v0*alpha/(g*(rhos-rhof))" : Real;
		OBJ HelpPar2 (* hidden = "1" *) "-Ccrit+beta" : Concentration; 
 
 
		OBJ HelpVar1 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b-a)/2" : Real[NrOfLayersPlusFourBurger;];
		OBJ HelpVar2 (* hidden = "1" *) "Help variable for Gaussian quadrature: (b+a)/2" : BurgerConcentrationVector;
	   
  	    OBJ Fbk_max "Maximum flux" : ArealFlux;
	    OBJ C_fbk_max "Concentration corresponding to maximal settling flux" : Concentration ;
 };

   initial <-
   {
    
    state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger); 
    state.H_Layer = parameters.H / NrOfLayersBurger;

	 
	state.C_fbk_max=CHat_DExp(parameters.v0,parameters.r_H,parameters.r_P,parameters.C_min,parameters.C_max,parameters.TOL);
	state.Fbk_max= parameters.v0*(exp(-parameters.r_H* state.C_fbk_max) - exp(- parameters.r_P*state.C_fbk_max));
    
	
	 
	state.HelpPar1 = parameters.NoComp * parameters.rhos * parameters.v0 * parameters.alpha / (parameters.gr * (parameters.rhos - parameters.rhof));
	state.HelpPar2 = -parameters.C_crit + parameters.beta;
    
	};
  
  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
				 THEN state.Q_In
				 ELSE interface.Q_Under;

    state.v_Dn = state.Q_Under_Actual / parameters.A; 
	
	{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
       state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
        In_Terminal[Comp_Index]; 
    };

    { state.Q_In = 
       (0.000001
                * state.InFluxPerComponent[IndexOfSolvent]);
    };

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 









    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    {state.X_In = IF (state.Q_In == 0)
			THEN 0
			ELSE state.SolidFlux_In / state.Q_In;
     };

    {
     state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
                                         state.X_Layer[Layer_Index]) / NrOfLayersBurger;
    };

	 
		 
		 

    	 

		 

    	state.v_Up = state.Q_Out / parameters.A; 

    	 
    	 
    	 
    	 
    	 
    	 
    	 

   		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
         state.v_S[Layer_Index] = 
parameters.v0*(exp(-parameters.r_H* state.X_Layer[Layer_Index]) -exp(- parameters.r_P * state.X_Layer[Layer_Index]));

 
           
          	  
          	  
    	}; 
	
    
	 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
       	   state.J_G_Help[Layer_Index] =
           state.v_S[Layer_Index] * state.X_Layer[Layer_Index];
    	};

		 
       		 
        	 
        	 
        	 
        	 
        	 
        	 
    		 
	
			 
			 
			 
			 
			 
			 
			
		 
			{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
    		  state.J_G[Layer_Index] = 
			   IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1])
			   THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE
			     IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0)
				 THEN state.Fbk_max
				 ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]);
    		};
	

	{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}:
       state.J_Up[Layer_Index] =
        state.v_Up * state.X_Layer[Layer_Index];
    };

    { FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}:
       state.J_Dn[Layer_Index] =
        state.v_Dn * state.X_Layer[Layer_Index];
    };

	
	 
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
        state.X_comp[Layer_Index] = MSLUGetMax2(parameters.C_crit,state.X_Layer[Layer_Index]);
      };
	  
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar1[Layer_Index] = (state.X_comp[Layer_Index+1]-state.X_comp[Layer_Index])/2;
	  };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.HelpVar2[Layer_Index] = (state.X_comp[Layer_Index+1]+state.X_comp[Layer_Index])/2;
	  };
	
	   
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
        state.J_comp_help[Layer_Index] = 
 
	    IF (state.X_comp[Layer_Index]>=state.X_comp[Layer_Index+1])
	    THEN 0
	    ELSE SUMOVER Legendre_Index IN {1 .. NrOfNodes}:
	  	  	   (state.HelpPar1*(exp(-parameters.r_H*(state.HelpVar1[Layer_Index] * parameters.nl[Legendre_Index] 
			   + state.HelpVar2[Layer_Index]))-exp(-parameters.r_P*(state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index])))/((state.HelpVar1[Layer_Index] 
			   * parameters.nl[Legendre_Index]+ state.HelpVar2[Layer_Index]) + state.HelpPar2)) * parameters.wl[Legendre_Index]; 
      };
	  
	  { FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}:
	    state.J_comp[Layer_Index] = state.J_comp_help[Layer_Index] * state.HelpVar1[Layer_Index];
	  };

	
	 
	
		 
		{ DERIV(state.X_Layer[1],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[2])
	   	  - (state.Q_Out / state.V_Layer) * state.X_Layer[1];
    	};

		{ DERIV(state.X_Layer[2],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Up[3] - state.J_Up[2] 
		  - state.J_G[2]
	   	   
	   	  );
    	};
	
		 
		{ FOREACH Layer_Index IN {3 .. NrOfLayersPlusOneBurger}:
       	  DERIV(state.X_Layer[Layer_Index],[independent.t]) =
          IF (Layer_Index == IndexOfFeedLayerBurger)
          THEN (1 / state.H_Layer) *
          	  (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			   
			 ) + (1 / state.V_Layer) * state.SolidFlux_In 
          ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index]
			  
			  );
    	};

    	 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusOneBurger] - state.J_Dn[NrOfLayersPlusTwoBurger] 
	   	  + state.J_G[NrOfLayersPlusOneBurger] - state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) =
       	  (1 / state.H_Layer) *
       	  (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] 
	   	  + state.J_G[NrOfLayersPlusTwoBurger] 
	   	   
	   	  ) ;
    	};
	
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) =
       	  (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger]
	   	  -state.J_Dn[NrOfLayersPlusFourBurger]);
    	};

	
    state.X_Out = IF (state.Q_Out == 0)
			THEN 0
			ELSE state.X_Layer[1];

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[NrOfLayersPlusFourBurger];

 

    state.IndexOfSludgeBlanket =
     MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusFourBurger,parameters.X_Lim);

    state.H_S = (NrOfLayersPlusFourBurger - state.IndexOfSludgeBlanket - 2) *
                state.H_Layer;


 
 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.Q_In == 0)
	      THEN 0
		ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In);
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Overflow[Comp_Index] =
		IF (state.SolidFlux_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ;
    };

 

    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;

    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ;
    };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Underflow[Comp_Index] =
		IF (state.Q_In == 0)
		THEN 0
		ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ;
    };
 

 

    interface.Sludge_Blanket_Height = state.H_S;

    interface.TSS = state.SolidConcentration;

    interface.V_Clarifier = parameters.A * parameters.H;  
   };

 :};





# 29 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.secondary_clarifier.plosz.msl" 1
 




















CLASS BasePlosz
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 SPECIALISES PhysicalDAEModelType :=
 {:
   interface <-
   {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" :};
   OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" :};
   OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" :};
   OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" :};
   OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" :};
   OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    
   OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
   };

   parameters <- 
   {     
    
    OBJ A (* is_favorite = "1" *) "Surface area of the clarifier" : Area := {: value <- 754 ; group <- "Dimension" :};
    OBJ H (* is_favorite = "1" *) "Height of the clarifier" : Length := {: value <- 3 ; group <- "Dimension" :};
 
    OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling" :};
 
    OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.001375 ; group <- "Settling" :};
    OBJ X_Lim "Minimal concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
 
    OBJ L_60 (* hidden = "1" *) "Fraction of underflow withdrawn from layer 60" : Fraction := {: value <- 1.0 :};
 







 
    OBJ Eta_Con "Downwards convection control" : Velocity := {: value <- 0.504 :};
    OBJ D_01 "Over flow dependent dispersion model parameter" : Diffusivity := {: value <- 3.95 :}; 
    OBJ V_OV_DIS "Boundary overflow velocity for dispersion" : Velocity := {: value <- 15 :}; 
    OBJ V_F_CON "Boundary feedflow velocity for convection" : Length := {: value <- 30.5 :};
    OBJ g_DIS "Dispersion function coefficient" : Time := {: value <- 0.022 :}; 
 
    OBJ D_C_max "Maximum value of the dispersion coefficient" : Diffusivity := {: value <- 15 :};
 
 
    OBJ L_F_max "Maximum height of the feed layer" : Integer := {: value <- 32 :};
 
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
   };

   state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out (* is_favorite = "1" *) "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Under_Actual (* is_favorite = "1" *) "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
    OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
    OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :}; 
    OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :}; 
    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out (* is_favorite = "1" *) "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Under (* is_favorite = "1" *) "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};  
    OBJ X_Layer "Vector containing concentration of particulates for all the layers" : PloszConcentrationVector := {: group <- "Concentration" :};
 
    OBJ D_Con_Help (* hidden = "1" *) "Help for the over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ D_Con "Over flow velocity dependent dispersion coefficient" : Diffusivity;
    OBJ V_Ff "Clarifier feed velocity" : Velocity;
    OBJ V_Fo "Clarifier overflow velocity" : Velocity;
    OBJ Eta_CC "Feed velocity dependent convection reduction factor" : Real;
    OBJ Eta_Con_Help (* hidden = "1" *) "Help for convection reduction factor" : Real;
 
    OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;	
    OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
    OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
    OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ; 
    OBJ v_S (* hidden = "1" *) "Static settling velocity" : PloszVelocityVector;
    OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": PloszVelocityVector;
    OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : PloszArealFluxVector;
    OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : PloszArealFluxVector;
    OBJ J_G (* hidden = "1" *) "Static sludge flux" : PloszArealFluxVector;
    OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": PloszArealFluxVector;
 
    OBJ DynamicIndexOfFeedLayer_Help (* hidden = "1" *) "Dynamic Index of Feed Layer - HELP" : Real := {: group <- "Operational" :};
    OBJ DynamicIndexOfFeedLayer "Dynamic Index of Feed Layer" : Real := {: group <- "Operational" :};
 
    OBJ J_Dis (* hidden = "1" *) "Dispersion flux": PloszArealFluxVector;
    OBJ D_1 (* hidden = "1" *) "Dispersion with the following layer ": PloszDiffusivityVector; 
    OBJ D_2 (* hidden = "1" *) " Dispersion with the precedent layer ": PloszDiffusivityVector; 
    OBJ J_GUp_Help (* hidden = "1" *) "Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective help fluxes": PloszArealFluxVector; 
    OBJ J_GUp (* hidden = "1" *) " Treatment of the minimum settling flux conditions by Godunov - gravity and upwards convective fluxes": PloszArealFluxVector; 
 
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
    OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
    OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
    OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;	
    OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
    OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
    OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
   };

   initial <-
   {
   
    state.V_Layer = parameters.A * (parameters.H / 60); 
    state.H_Layer = parameters.H / 60;
   };

  independent <- { OBJ t "Time": Time; };

  equations <-
   {
    state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under)
         THEN state.Q_In
         ELSE interface.Q_Under;

 
    state.v_Dn = (state.Q_Under_Actual / parameters.A) * state.Eta_CC; 

 
 
    state.DynamicIndexOfFeedLayer_Help = MSLUFindThreshold(ref(state.X_Layer[1]),60,state.X_In);
    state.DynamicIndexOfFeedLayer = MSLUGetMax2(state.DynamicIndexOfFeedLayer_Help,parameters.L_F_max);
 

    { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
			SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

    state.Q_In = (0.000001 * state.InFluxPerComponent[IndexOfSolvent]) ;

    state.Q_Out = state.Q_In - state.Q_Under_Actual; 







    state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];


    state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;

	{ state.SolidConcentration =
			(SUMOVER Layer_Index IN {1 .. 60}: state.X_Layer[Layer_Index]) / 60 ; };

    state.X_Min = IF (state.Q_In == 0) THEN parameters.f_ns * state.SolidConcentration
			ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

 




    state.v_Up = state.Q_Out / parameters.A; 

 
    state.V_Ff = state.Q_In / parameters.A;
    state.V_Fo = state.Q_Out / parameters.A;

    state.D_Con_Help = IF (state.V_Fo < parameters.V_OV_DIS) THEN parameters.D_01
			ELSE parameters.D_01 + parameters.g_DIS * (state.V_Fo - parameters.V_OV_DIS) * (state.V_Fo - parameters.V_OV_DIS) ;

    state.D_Con = MSLUGetMin2(state.D_Con_Help, parameters.D_C_max);
	 
    state.Eta_Con_Help = IF (state.V_Ff < parameters.V_F_CON) THEN parameters.Eta_Con
			ELSE parameters.Eta_Con + (state.V_Ff - parameters.V_F_CON) /  parameters.V_F_CON * (state.V_Ff - parameters.V_F_CON) / parameters.V_F_CON;

    state.Eta_CC = MSLUGetMin2(state.Eta_Con_Help, 1.0);
 
    
 
    { FOREACH Layer_Index IN {1 .. 59}: state.D_1[Layer_Index] = state.D_Con ; };
    { FOREACH Layer_Index IN {1 .. 60}: state.D_2[Layer_Index] = state.D_Con ; };
 

 







        
    { FOREACH Layer_Index IN {1 .. 60}: state.J_G_Help[Layer_Index] =
			state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };

 
    { FOREACH Layer_Index IN {2 .. 60}: state.J_Up[Layer_Index] = 
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 0		   
					ELSE state.v_Up * state.X_Layer[Layer_Index]; };	 

 
    { FOREACH Layer_Index IN {1 .. 59}: state.J_Dn[Layer_Index] =
			IF (Layer_Index >= state.DynamicIndexOfFeedLayer) THEN state.v_Dn * state.X_Layer[Layer_Index]	 
					ELSE 0; }; 								  	   		 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_Dis[Layer_Index] =
			- state.D_2[Layer_Index] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) / state.H_Layer
			+ state.D_1[Layer_Index] * (state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) / state.H_Layer ; };
 

 

 

 
    { FOREACH Layer_Index IN {2 .. 59}: state.J_G[Layer_Index-1] =
			IF (Layer_Index <= state.DynamicIndexOfFeedLayer) THEN
					IF (state.J_G_Help[Layer_Index-1] <= state.J_G_Help[Layer_Index]) THEN state.J_G_Help[Layer_Index-1]
					   		ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index-1] ; };

    { FOREACH Layer_Index IN {1 .. 59}: state.J_G[Layer_Index] =
			IF (Layer_Index > state.DynamicIndexOfFeedLayer) THEN 
					IF (state.J_G_Help[Layer_Index] > state.J_G_Help[Layer_Index+1]) THEN state.J_G_Help[Layer_Index+1]
							ELSE state.J_G_Help[Layer_Index]
			ELSE state.J_G_Help[Layer_Index] ; };
 


 
    { DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * (state.J_Up[2] - state.J_G[1] + state.D_1[1] * (state.X_Layer[2]
			- state.X_Layer[1]) / state.H_Layer) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };

    { FOREACH Layer_Index IN {2 .. 59}:
       DERIV(state.X_Layer[Layer_Index],[independent.t]) =
        IF (Layer_Index == state.DynamicIndexOfFeedLayer)
        THEN (1 / state.H_Layer) *
             (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]) +
             (1 / state.V_Layer) * state.SolidFlux_In 
        ELSE (1 / state.H_Layer) *
             (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index]
              + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index]
              + state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + state.J_Dis[Layer_Index]);
    };

 
 
















































    { DERIV(state.X_Layer[60],[independent.t]) =  IF (60 == state.DynamicIndexOfFeedLayer)
			THEN (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] + (1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Dn[59] + state.J_G[59] - state.D_2[60] * (state.X_Layer[60]
			- state.X_Layer[59]) / state.H_Layer) - ((state.Q_Under_Actual * parameters.L_60) / state.V_Layer) *
			state.X_Layer[60] ; };

    state.X_Out = IF (state.Q_Out == 0) THEN 0
			ELSE state.X_Layer[1]; 
 

 

    state.X_Under = IF (state.Q_Under_Actual == 0)
			  THEN 0
			  ELSE state.X_Layer[60] ; 
 



 

 
    state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),60,parameters.X_Lim) ;
    state.H_S = (60 - state.IndexOfSludgeBlanket + 1) * state.H_Layer ;

 
    state.SolidFlux_Out = state.X_Out * state.Q_Out;

    { FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}: interface.Overflow[Comp_Index] =
	  		IF (state.Q_In == 0) THEN 0
			ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
			IF (state.SolidFlux_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

 
    state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
    interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / 0.000001 ;

    { FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
			interface.Underflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };

    { FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
			IF (state.Q_In == 0) THEN 0
			ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

 
 
    interface.Sludge_Blanket_Height = state.H_S;
    interface.TSS = state.SolidConcentration;
    interface.V_Clarifier = parameters.A * parameters.H;  

	 
	DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual ;
	interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
   };

 :};




CLASS Plosz
 (* icon = "secondary_clarifier" *)
 "One-dimensional (1-D) convection-dispersion model of the secondary settling tank (SST) - Benedek Gy. Plosz"

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    OBJ v0 "Maximum theoretical settling velocity" : Velocity := {: value <- 103.012 ; group <- "Settling" :};
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.0002526 ; group <- "Settling" :}; 
   };

  equations <-
   {
    state.v0_P = parameters.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = parameters.v0 * exp(parameters.r_H * state.X_Min); 

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v0) THEN parameters.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.secondary_clarifier.ploszsvi.msl" 1
 




















CLASS PloszSVI
 (* icon = "secondary_clarifier" *)
 "Layered convection-dispersion model of the secondary settling tank - Benedek Gy. Plosz"

 
 
 
 
 

 EXTENDS BasePlosz WITH
 {:
   comments <- " A layered dispersion model calibrated and validated for flat-bottom secondary clarifiers - Benedek Plosz ";

   parameters <- 
   {     
    
    OBJ V_alpha "SSVI3.5(ml/g) - V0(m/d) exponential regression - alpha value" : Velocity := {: value <- 133.7472 :};
    OBJ V_beta "SSVI3.5(ml/g) - V0(m/d) exponential regression - exponent" : Concentration := {: value <- 3446.7 :};
    OBJ r_H_lambda "SSVI3.5(ml/g) - r_H(m3/g) linear regression - slope" : Real := {: value <- 0.0000026 :};
    OBJ r_H_kappa "SSVI3.5(ml/g) - r_H(m3/g) linear regression - y-intercept" : SpecificVolume := {: value <- 0.0000628 :};
    OBJ DSVI "Diluted sludge volume index, DSVI" : SpecificVolume := {: value <- 0.000085 :};
    OBJ p_SVI "SSVI3.5/DSVI ratio" : Real := {: value <- 0.658 :};
    
   };

   state <-
   {
 
    OBJ v0 "Maximum theoretical settling velocity" : Velocity ;
    OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume ;
 
   };

  equations <-
   {
 
    state.v0 = parameters.V_alpha * exp(- parameters.V_beta * parameters.DSVI * parameters.p_SVI);
    state.r_H = parameters.r_H_lambda * parameters.DSVI * parameters.p_SVI + parameters.r_H_kappa;
	
    state.v0_P = state.v0 * exp(parameters.r_P * state.X_Min);
    state.v0_H = state.v0 * exp(state.r_H * state.X_Min);

    { FOREACH Layer_Index IN {1 .. 60}: state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) THEN 0
			   		ELSE (state.v0_H * exp( - state.r_H * state.X_Layer[Layer_Index])
					- state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index])) ; };

 
    { FOREACH Layer_Index IN {1 .. 60}: state.v_S[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > state.v0) THEN state.v0
					ELSE state.v_S_Help[Layer_Index]) ; }; 
 
   };

 :};




# 31 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\secondary_clarifier/wwtp.secondary_clarifier.burger.msl" 1
 














 
 




 

CLASS Burger
  (* icon = "secondary_clarifier" *)
  "Layered clarifier model by Burger with Vesilind settling function" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model for a secondary settler by Burger with Vesilind settling";
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
		OBJ Overflow (* terminal = "out_1" *) "Overflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
		OBJ Underflow (* terminal = "out_2" *) "Underflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Underflow" :};
		OBJ Sludge_Blanket_Height (* terminal = "out_3" *) "Height of the sludge blanket" : Length := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ TSS(* terminal = "out_3" *) "Total suspended solids concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ V_Clarifier (* terminal = "out_3" *)"Volume measurement data" : Volume := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ PumpingEnergy (* terminal = "out_3" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
		 
		OBJ Q_Under (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Underflow rate" : FlowRate := {: causality <- "CIN" ; value <- 200 ; group <- "Operational" :}; 
    };
    parameters <-
    {
		OBJ WWTPSpecificVolume (* hidden = "1" *) "Vector containing specific volume for all the components" : SpecificVolumeVector;
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/d2)": Acceleration := {: value <- 7.32312576e10 :};
		OBJ PI (* hidden = "1" *) "PI": Real := {: value <- 3.141592653 :};
		OBJ A "Surface area of the clarifier" : Area := {: value <- 1500 ; group <- "Dimension" :};
		OBJ H "Height of the clarifier" : Length := {: value <- 4 ; group <- "Dimension" :};
		OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
		OBJ X_Lim "Minimum concentration in sludge blanket" : Concentration := {: value <- 900 ; group <- "Settling general" :};
		OBJ Vs_Switch "1=Vsilind, 2=Takacs, 3=Cho" : Integer :={: value <-2 ; group <- "Settling general" :};
		
		 
		OBJ v0_V "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling Vesilind" :};
		OBJ r_V "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling Vesilind" :};
		
		 
		OBJ v0_T "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling Takacs" :};
		OBJ v00 "Maximum practical settling velocity" : Velocity := {: value <- 250 ; group <- "Settling Takacs" :}; 
		OBJ r_P "Settling parameter (low concentration)" : SpecificVolume := {: value <- 0.00286 ; group <- "Settling Takacs" :};
		OBJ r_H "Settling parameter (hindered settling)" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling Takacs" :}; 
		OBJ f_ns "Non-settleable fraction of suspended solids" : Fraction := {: value <- 0.00228 ; group <- "Settling Takacs" :};
		
		 
		OBJ k "Maximum theoretical settling velocity" : Velocity := {: value <- 474 ; group <- "Settling Cho" :};
		OBJ n "Settling parameter" : SpecificVolume := {: value <- 0.000576 ; group <- "Settling Cho" :};
		
		 
		OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
		
		 
		 
		OBJ Comp_ON "Switch on/off compression": Integer :={: value <- 0 ; group <- "Compression" :};
		OBJ Alpha "Effective solids stress parameter" : BurgerSolidsStress := {: value <- 0.8 ; group <- "Compression" :};
		OBJ Rhos "Solid density": Density := {: value <- 1050000 ; group <- "Compression" :};
		OBJ Rhof "Fluid density": Density := {: value <- 998000 ; group <- "Compression" :};
		OBJ C_crit "Gel point" : Concentration := {: value <- 6000 ; group <- "Compression" :};
		 
		OBJ C_min "Minimum packing concentration" : Concentration := {: value <- 0 ; group <- "Settling flux" :};
		OBJ C_max "Maximum packing concentration" : Concentration := {: value <- 20000 ; group <- "Settling flux" :};
		OBJ TOL "Tolerance level to calculate concentration with maximum settling flux" : Fraction := {: value <- 1e-10 ; group <- "Settling flux" :};
		 
		OBJ Disp_ON "Switch on/off dispersion": Integer :={: value <- 0 ; group <- "Dispersion" :};
		OBJ a_mix "Dispersion parameter" : Length := {: value <- 0.4 ; group <- "Dispersion" :};
		OBJ b_mix "Dispersion parameter" : BurgerDispersion := {: value <- 0.00001 ; group <- "Dispersion" :}; 
		OBJ batch "Switch ON/OFF batch mode" : Integer :={: value <- 1 ; group <- "Settling general" :};
    };
    state <-
    {
		 
		OBJ IndexOfSludgeBlanket (* hidden = "1" *) "Index of top layer of sludge blanket" : Integer ;
		OBJ v_Up (* hidden = "1" *) "Upward bulk velocity" : Velocity ;
		OBJ v_Dn (* hidden = "1" *) "Downward bulk velocity" : Velocity ;
		OBJ X_Min "Non-settleable sludge concentration" : Concentration := {: group <- "Settling" :};
		OBJ v0_P (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
        OBJ v0_H (* hidden = "1" *) "Correction term for non-settleables" : Velocity ;
		OBJ v_S_Help (* hidden = "1" *) "Static settling velocity help variable": BurgerVelocityVector;
		OBJ v_S_Help2 (* hidden = "1" *) "Static settling velocity help variable": BurgerVelocityVector;
		OBJ v_S (* hidden = "1" *) "Static settling velocity" : BurgerVelocityVector;
		OBJ J_Up (* hidden = "1" *) "Upward sludge flux" : BurgerArealFluxVector;
		OBJ J_Dn (* hidden = "1" *) "Downward sludge flux" : BurgerArealFluxVector;
		OBJ J_G (* hidden = "1" *) "Static sludge flux" : BurgerArealFluxVector;
		OBJ J_G_Help (* hidden = "1" *) "Static sludge flux": BurgerArealFluxVector;
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector;
		OBJ SolidFlux_In (* hidden = "1" *) "Sum of massfluxes of particulates" : MassFlux ;
		OBJ SolidConcentration (* hidden = "1" *) "Sum of concentrations of particulates" : Concentration ;
		OBJ V_Layer (* hidden = "1" *)	"Volume of the layer" : Volume ;
		OBJ H_Layer (* hidden = "1" *) "Height of layer" : Length ;
		OBJ SolidFlux_Out (* hidden = "1" *) "Fraction of influx that goes to the effluent" : MassFlux ;
		OBJ SolidFlux_Under (* hidden = "1" *) "Fraction of influx that goes to the underflow" : MassFlux ;
		
		 
		OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Out "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
		OBJ Q_Under_Actual "Actual underflow rate" : FlowRate := {: group <- "Operational" :};
		OBJ H_S "Height of sludge blanket" : Length := {: group <- "Settling" :};
		OBJ X_In "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Out "Effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Under "Underflow suspended solids concentration" : Concentration := {: group <- "Concentration" :};
		OBJ X_Layer "Vector containing concentration of particulates for all the layers" : BurgerConcentrationVector := {: group <- "Concentration" :};
		 
		OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
		 
		 
	    	OBJ D_comp (* hidden = "0" *) "Primitive of compression function" : BurgerLengthFluxVector;
		
		 
		OBJ Fbk_max "Maximum flux" : ArealFlux := {: group <- "Settling" :};
		OBJ C_fbk_max "Concentration corresponding to maximal settling flux" : Concentration := {: group <- "Settling" :};
		
		 
	    	OBJ d_mix (* hidden = "0" *) "Dispersion function" : BurgerDiffusivityVector;
		OBJ z (* hidden = "0" *) "Height in clarifier" : BurgerLengthVector;

		 
        OBJ FbkPrimeVector (* hidden = "1" *) "Vector containing derivative of flux function for all the layers" : BurgerArealFluxVector2;
		OBJ ConcVector (* hidden = "1" *) "Vector containing concentrations between Cmin and Cmax" : BurgerConcentrationVector2;
		OBJ FbkPrimeMax (* hidden = "1" *) "Maximum of flux derivative" : ArealFlux;
		OBJ QfMax (* hidden = "1" *) "maximum incoming velocity" : Velocity;
		OBJ DcompMax (* hidden = "1" *) "maximum value of compression" : LengthFlux;
		OBJ d_mixMax (* hidden = "1" *) "maximal value of disperion" : Diffusivity; 
		OBJ d_mixMaxHelp (* hidden = "1" *) "maximal value of disperion" : Diffusivity; 
		OBJ CFL (* hidden = "0" *) "maximum allowed time-step" : Time;
		};
    initial <-
    {
		parameters.WWTPSpecificVolume[IndexOfSolvent] := 1e-6;
		state.V_Layer = parameters.A * (parameters.H / NrOfLayersBurger);
		state.H_Layer = parameters.H / (NrOfLayersBurger);

		 
		 
		
		state.C_fbk_max = IF (parameters.Vs_Switch == 1) 
			THEN MSLUBurgerCHat(parameters.v0_V, parameters.r_V, parameters.C_min, parameters.C_max, parameters.TOL)
			ELSE MSLUBurgerCHat(parameters.v0_T, parameters.r_H, parameters.C_min, parameters.C_max, parameters.TOL);
		state.Fbk_max = IF (parameters.Vs_Switch == 1) THEN parameters.v0_V * exp(-parameters.r_V * state.C_fbk_max) * state.C_fbk_max 
			ELSE parameters.v0_T * exp(-parameters.r_H * state.C_fbk_max) * state.C_fbk_max;
		
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.z[Layer_Index] =
		  	fabs(state.H_Layer * (Layer_Index - IndexOfFeedLayerBurger)) ; };
			
		 
		{ FOREACH Conc_Index IN {1 .. NrOfConcentration}: state.ConcVector[Conc_Index] =(Conc_Index-1)*(parameters.C_max-parameters.C_min)/(NrOfConcentration-1);};
	
		{ FOREACH Conc_Index IN {1 .. NrOfConcentration}: state.FbkPrimeVector[Conc_Index] =
		  	IF (parameters.Vs_Switch == 1)
			THEN parameters.v0_V * exp(-parameters.r_V * state.ConcVector[Conc_Index])*(1-parameters.r_V*state.ConcVector[Conc_Index])
			ELSE 
				IF (parameters.Vs_Switch == 2)
				THEN parameters.v0_T * (
				     (exp(-parameters.r_H * state.ConcVector[Conc_Index])-exp(-parameters.r_P*state.ConcVector[Conc_Index]))
				     +(exp(-parameters.r_H*state.ConcVector[Conc_Index])*(-parameters.r_H)-exp(-parameters.r_P*state.ConcVector[Conc_Index])*(-parameters.r_P))
				     *state.ConcVector[Conc_Index])
				ELSE 0;
		};
		
		state.FbkPrimeMax=MSLUGetMax(ref(state.FbkPrimeVector[1]),NrOfConcentration);
		
		state.DcompMax=
			IF (parameters.Vs_Switch == 1)
			THEN parameters.Comp_ON*parameters.Alpha*pow(24*3600,2)* parameters.Rhos * parameters.v0_V *
				exp(-parameters.r_V * parameters.C_crit)/(parameters.g*(parameters.Rhos-parameters.Rhof))
			ELSE parameters.Comp_ON*parameters.Alpha*pow(24*3600,2)* parameters.Rhos * parameters.v0_T *
				exp(-parameters.r_H * parameters.C_crit)/(parameters.g*(parameters.Rhos-parameters.Rhof));
    };
    independent <-
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    equations <-
    {
		state.Q_Under_Actual = IF (state.Q_In <= interface.Q_Under) THEN state.Q_In
			ELSE interface.Q_Under ;
		state.v_Dn = state.Q_Under_Actual / parameters.A ;
		
		{ FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}: state.InFluxPerComponent[Comp_Index] =
		  	SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index] ; };

		state.Q_In = (parameters.WWTPSpecificVolume[IndexOfSolvent] * state.InFluxPerComponent[IndexOfSolvent]);
		state.Q_Out = state.Q_In - state.Q_Under_Actual ;

		




		
		state.SolidFlux_In =  state.InFluxPerComponent[IndexOfTSSComponent];
		

		state.X_In = IF (state.Q_In == 0) THEN 0
			ELSE state.SolidFlux_In / state.Q_In ;
		{state.SolidConcentration = ( SUMOVER Layer_Index IN {3 .. NrOfLayersPlusTwoBurger}:
			state.X_Layer[Layer_Index]) / NrOfLayersBurger; };
		
		state.X_Min = IF (state.Q_In == 0)
		THEN parameters.f_ns * state.SolidConcentration
		ELSE parameters.f_ns * state.SolidFlux_In / state.Q_In ;

		state.v0_P = parameters.v0_T * exp(parameters.r_P * state.X_Min);

		state.v0_H = parameters.v0_T * exp(parameters.r_H * state.X_Min); 
			
		state.v_Up = state.Q_Out / parameters.A ;

		 
		
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
			state.v_S_Help[Layer_Index] =
			IF (state.X_Layer[Layer_Index] < state.X_Min) 
			THEN 0 
			ELSE (state.v0_H * exp( - parameters.r_H * state.X_Layer[Layer_Index]) 
              - state.v0_P * exp( - parameters.r_P * state.X_Layer[Layer_Index]));
		};
		
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}:
			state.v_S_Help2[Layer_Index] =
			(IF (state.v_S_Help[Layer_Index] > parameters.v00)
			THEN parameters.v00
			ELSE state.v_S_Help[Layer_Index]);
		};


		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.v_S[Layer_Index] =
		  	IF (parameters.Vs_Switch == 1)
			THEN parameters.v0_V * exp(-parameters.r_V * state.X_Layer[Layer_Index])
			ELSE 
				IF (parameters.Vs_Switch == 2)
				THEN state.v_S_Help2[Layer_Index]
				ELSE 
					IF (state.X_Layer[Layer_Index]==0)
					THEN 0
					ELSE parameters.k*exp(-parameters.n*state.X_Layer[Layer_Index])/state.X_Layer[Layer_Index];
		};		

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.J_G_Help[Layer_Index] =
		  	state.v_S[Layer_Index] * state.X_Layer[Layer_Index] ; };
	
		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusThreeBurger}: state.J_G[Layer_Index] =
		  	IF (state.X_Layer[Layer_Index]<state.X_Layer[Layer_Index+1]) THEN MSLUGetMin2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1])
			   ELSE IF (((state.C_fbk_max-state.X_Layer[Layer_Index])*(state.C_fbk_max-state.X_Layer[Layer_Index+1]))<0) THEN state.Fbk_max
			   ELSE MSLUGetMax2(state.J_G_Help[Layer_Index],state.J_G_Help[Layer_Index+1]) ; };
	
		 
		{ FOREACH Layer_Index IN {2 .. IndexOfFeedLayerBurger}: state.J_Up[Layer_Index] =
		  	state.v_Up * state.X_Layer[Layer_Index] ; };
		{ FOREACH Layer_Index IN {IndexOfFeedLayerBurger .. NrOfLayersPlusFourBurger}: state.J_Dn[Layer_Index] =
		  	state.v_Dn * state.X_Layer[Layer_Index] ; };

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.D_comp[Layer_Index] =
		       (IF (state.X_Layer[Layer_Index] < parameters.C_crit) THEN 0
		 	   ELSE
				(IF (parameters.Vs_Switch == 1) 
				THEN parameters.Comp_ON * parameters.Alpha *pow(24*3600,2) * parameters.Rhos * parameters.v0_V *
				(exp(-parameters.r_V * state.X_Layer[Layer_Index])-exp(-parameters.r_V * parameters.C_crit)) /
				(-parameters.r_V * parameters.g * (parameters.Rhos-parameters.Rhof))
				ELSE parameters.Comp_ON * parameters.Alpha *pow(24*3600,2) * parameters.Rhos * parameters.v0_T *
				(exp(-parameters.r_H * state.X_Layer[Layer_Index])-exp(-parameters.r_H * parameters.C_crit)) /
				(-parameters.r_H * parameters.g * (parameters.Rhos-parameters.Rhof)))
			   ) ;
   	    	};

		 
		{ FOREACH Layer_Index IN {1 .. NrOfLayersPlusFourBurger}: state.d_mix[Layer_Index] =
		  	IF (state.z[Layer_Index] < (parameters.b_mix*state.Q_In))
			THEN parameters.Disp_ON * parameters.a_mix/parameters.A * state.Q_In *
			  pow(cos(parameters.PI*state.z[Layer_Index]/(2*parameters.b_mix*state.Q_In)),2)
			ELSE 0 ; };

		
		 
				
		state.QfMax = MSLUGetMax2(state.Q_In/parameters.A, state.QfMax);
				
		state.d_mixMaxHelp=parameters.Disp_ON*parameters.a_mix/parameters.A * state.Q_In;
		state.d_mixMax =MSLUGetMax2(state.d_mixMaxHelp,state.d_mixMax);
		
		state.CFL=1/(1/state.H_Layer*(state.QfMax+state.FbkPrimeMax)+(2/pow(state.H_Layer,2))*(state.DcompMax+state.d_mixMax));	
				

		 
		 
		{ DERIV(state.X_Layer[1],[independent.t]) = (1 / state.H_Layer) * parameters.batch * (state.J_Up[2]) - (state.Q_Out / state.V_Layer) * state.X_Layer[1] ; };
		{ DERIV(state.X_Layer[2],[independent.t]) = (1 / state.H_Layer) * parameters.batch * (state.J_Up[3] - state.J_Up[2] - state.J_G[2] + (1 / state.H_Layer) *(state.D_comp[3]- state.D_comp[2])); };
		
		 
		{ DERIV(state.X_Layer[3],[independent.t]) = IF (3 == IndexOfFeedLayerBurger)
		  	THEN (1 / state.H_Layer) * (- state.J_Up[3] - state.J_Dn[3] + state.J_G[2] - state.J_G[3] +
			(1 / state.H_Layer) *(state.d_mix[3]*(state.X_Layer[4]-state.X_Layer[3]) + state.D_comp[4]+state.D_comp[2]-2*state.D_comp[3])) + 
			(1 / state.V_Layer) * state.SolidFlux_In
			ELSE (1 / state.H_Layer) * (state.J_Up[4] - state.J_Up[3] + state.J_Dn[2] - state.J_Dn[3] + state.J_G[2] -
			state.J_G[3] + (1 / state.H_Layer) *(state.d_mix[3]*((state.X_Layer[4]-state.X_Layer[3])) + state.D_comp[4]+state.D_comp[2] -
			2*state.D_comp[3])); };
		
		 
		{ FOREACH Layer_Index IN {4 .. NrOfLayersPlusOneBurger}: DERIV(state.X_Layer[Layer_Index],[independent.t]) =
		  	IF (Layer_Index == IndexOfFeedLayerBurger) THEN (1 / state.H_Layer) * (- state.J_Up[Layer_Index] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
			   state.d_mix[Layer_Index] *(state.X_Layer[Layer_Index+1] - state.X_Layer[Layer_Index]) 
			   - state.d_mix[Layer_Index-1] * (state.X_Layer[Layer_Index] - state.X_Layer[Layer_Index-1]) + 
			   state.D_comp[Layer_Index+1] + state.D_comp[Layer_Index-1] - 2*state.D_comp[Layer_Index])) +
			   (1 / state.V_Layer) * state.SolidFlux_In
			   ELSE (1 / state.H_Layer) * (state.J_Up[Layer_Index+1] - state.J_Up[Layer_Index] + state.J_Dn[Layer_Index-1] - state.J_Dn[Layer_Index] +
			   state.J_G[Layer_Index-1] - state.J_G[Layer_Index] + (1 / state.H_Layer) *(
				state.d_mix[Layer_Index]*(state.X_Layer[Layer_Index+1] - 
			   state.X_Layer[Layer_Index]) - state.d_mix[Layer_Index-1] *(state.X_Layer[Layer_Index]-state.X_Layer[Layer_Index-1]) +
			   state.D_comp[Layer_Index+1]+state.D_comp[Layer_Index-1]-2*state.D_comp[Layer_Index])) ; };

		 
		{ DERIV(state.X_Layer[NrOfLayersPlusTwoBurger],[independent.t]) = (1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusOneBurger] 
				- parameters.batch*state.J_Dn[NrOfLayersPlusTwoBurger] +
		  		state.J_G[NrOfLayersPlusOneBurger] - parameters.batch*state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) * (
				-state.d_mix[NrOfLayersPlusOneBurger] * (parameters.batch*state.X_Layer[NrOfLayersPlusTwoBurger] - state.X_Layer[NrOfLayersPlusOneBurger]) + 
				parameters.batch*state.D_comp[NrOfLayersPlusThreeBurger] + state.D_comp[NrOfLayersPlusOneBurger] - state.D_comp[NrOfLayersPlusTwoBurger]
				- parameters.batch*state.D_comp[NrOfLayersPlusTwoBurger])) ; };
		
		 
		{ DERIV(state.X_Layer[NrOfLayersPlusThreeBurger],[independent.t]) = parameters.batch*((1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusTwoBurger] - state.J_Dn[NrOfLayersPlusThreeBurger] +
		  		state.J_G[NrOfLayersPlusTwoBurger] + (1 / state.H_Layer) *(state.D_comp[NrOfLayersPlusTwoBurger]-state.D_comp[NrOfLayersPlusThreeBurger]))) ; };
		{ DERIV(state.X_Layer[NrOfLayersPlusFourBurger],[independent.t]) = parameters.batch*((1 / state.H_Layer) * (state.J_Dn[NrOfLayersPlusThreeBurger] - state.J_Dn[NrOfLayersPlusFourBurger])); };

		state.X_Out = IF (state.Q_Out == 0)	THEN 0 ELSE state.X_Layer[1] ;
		state.X_Under = IF (state.Q_Under_Actual == 0) THEN 0 ELSE state.X_Layer[NrOfLayersPlusFourBurger] ;
		
		 
		state.IndexOfSludgeBlanket = MSLUFindThreshold(ref(state.X_Layer[1]),NrOfLayersPlusTwoBurger,parameters.X_Lim) ;
		state.H_S = (NrOfLayersPlusTwoBurger - state.IndexOfSludgeBlanket) * state.H_Layer ;

		 
		state.SolidFlux_Out = state.X_Out * state.Q_Out ;
		{ FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent} : interface.Overflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0	ELSE - state.InFluxPerComponent[Comp_Index] * (state.Q_Out / state.Q_In) ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Overflow[Comp_Index] =
		  		IF (state.SolidFlux_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Out ; };

		 
		state.SolidFlux_Under = state.X_Under * state.Q_Under_Actual;
		interface.Underflow[IndexOfSolvent] = - state.Q_Under_Actual / parameters.WWTPSpecificVolume[IndexOfSolvent] ;
		{ FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: interface.Underflow[Comp_Index] =
		  		- state.InFluxPerComponent[Comp_Index] - interface.Overflow[Comp_Index] ; };
		{ FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}: interface.Underflow[Comp_Index] =
		  		IF (state.Q_In == 0) THEN 0 ELSE - (state.InFluxPerComponent[Comp_Index] / state.SolidFlux_In) * state.SolidFlux_Under ; };

		 
		 
		interface.Sludge_Blanket_Height = state.H_S ;
		interface.TSS = state.SolidConcentration ;
		interface.V_Clarifier = parameters.A * parameters.H ;  
		 
		 
		DERIV(state.Integ_PE,[independent.t])=  state.Q_Under_Actual;
		interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
    };

 :};
 



# 32 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.secondary_clarifier.msl" 2




# 39 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sand_filter.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl" 1
 



















 CLASS SimpleDownFlow
  (* icon = "sand_filter" ; is_default = "true" *)
  "Semicontinuous Downflow granular medium filter"
 SPECIALISES PhysicalDAEModelType :=
 {:
  comments <- "A model for sand filtration";

  interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
    OBJ Inflow_Backwash (* terminal = "in_3" *) "Inflow" :
         InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent backwash" :};
    OBJ Outflow_Filtered (* terminal = "out_1" *) "Outflow filtered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Filtered" :};
    OBJ Outflow_Unfiltered (* terminal = "out_3" *) "Outflow unfiltered" :
         OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent Unfiltered" :};
    OBJ Backwash  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Backwashing state" : Integer := 
         {:
       causality <- "CIN" ; 
       group <- "Operational" ;
           interval <- {: lowerBound <- 0; upperBound <- 1; :};  
         :};
   };

  parameters <-
   {
   



    OBJ A (* is_favorite = "1" *) "Surface" : Area:= {: value <- 10 ; group <- "Dimension" :};
    OBJ k "Sludge resistance coefficient" : Real := {: value <- 0.001 ; group <- "Hydraulic" :};
    OBJ f_nf "Non-filterable fraction" : Fraction := {: value <- 0.005 ; group <- "Filtration" :};
    OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ alfa "Outflow parameter" : PhysicalQuantityType := {: value <- 2500 ; group <- "Hydraulic" :};
    OBJ beta "Outflow parameter" : PhysicalQuantityType := {: value <- 1 ; group <- "Hydraulic" :};
    OBJ f0 "Clean filter bed resistance factor": Fraction := {: value <- 0.025 ; group <- "Hydraulic" :};
    OBJ H_Max (* is_favorite = "1" *) "Maximum height of the water in the sand filter" : Length := {: value <- 1 ; group <- "Dimension" :};
    OBJ Backwash_Intensity "Backwash Intensity" : Real := 
         {:
           unit <- "m-3";
           value <- 0.02 ;
       group <- "Filtration";
           interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};  
         :};
   };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ Q_In (* is_favorite = "1" *) "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Backwash  (* is_favorite = "1" *) "Backwash flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Filtered (* is_favorite = "1" *) "Filtered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent flow rate" : FlowRate := {: group <- "Operational" :};
    OBJ Q_Out_Unfiltered_Help (* hidden = "1" *) "Unfiltered effluent flow rate" : Real := {: group <- "Operational" :};
    OBJ H (* is_favorite = "1" *) "Height of the water on the sand filter" : Length := {: group <- "Operational" :};
    OBJ V "Volume" : Volume := {: group <- "Dimension" :};
    OBJ s_X "Mass of Sludge on the sand filter" : SurfaceDensity := {: group <- "Operational" :};
    OBJ M_X "Mass of sludge on the sand filter" : MassVector := {: group <- "Operational" :};
    OBJ f_Out_Filtered (* hidden = "1" *) "Fraction of the influent flux going to the filtered outflow" : Fraction ;
    OBJ f_Out_Unfiltered (* hidden = "1" *) "Fraction of the influent flux going to the unfiltered outflow" : Fraction ;






    OBJ X_In (* is_favorite = "1" *) "Influent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Backwash (* is_favorite = "1" *) "Backwash suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Filtered (* is_favorite = "1" *) "Filtered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ X_Out_Unfiltered (* is_favorite = "1" *) "Unfiltered effluent suspended solids concentration" : Concentration := {: group <- "Concentration" :};
    OBJ b_Backwash "Backwash rate" : Frequency := {: group <- "Operational" :};
   };

  initial <-
   {
   
   };

  equations <-
   {
 

    state.Q_In = 0.000001 * interface.Inflow[IndexOfSolvent];
    state.Q_Backwash = 0.000001 * interface.Inflow_Backwash[IndexOfSolvent];

 
 

    state.Q_Out_Filtered = IF (interface.Backwash <= 0)
                           THEN
      state.Q_Backwash +
                  parameters.alfa * pow(state.H, parameters.beta) * (1 - (parameters.f0 * exp(parameters.k * state.s_X)))
                           ELSE 0;

 
 
 
 

    state.Q_Out_Unfiltered_Help = state.Q_In
                           - parameters.alfa * pow(state.H, parameters.beta)
                             * (1 - (parameters.f0 * exp(parameters.k * state.s_X)));

    state.Q_Out_Unfiltered = IF (state.H > parameters.H_Max)
                   THEN 
                 IF (interface.Backwash <= 0)
                 THEN
                     IF (state.Q_Out_Unfiltered_Help < 0)
                   THEN 0
                   ELSE state.Q_Out_Unfiltered_Help
                 ELSE state.Q_In + state.Q_Backwash
                   ELSE 0;

 

    DERIV(state.H,[independent.t]) = 1/parameters.A * (state.Q_In + state.Q_Backwash - state.Q_Out_Filtered - state.Q_Out_Unfiltered);

    state.V = state.H * parameters.A;

 

    state.f_Out_Filtered = IF (interface.Backwash <= 0)
                 THEN
                 IF ((state.Q_Out_Filtered + state.Q_Out_Unfiltered) == 0)
                     THEN 0
                             ELSE state.Q_Out_Filtered / (state.Q_Out_Filtered + state.Q_Out_Unfiltered)
                 ELSE 0;

    state.f_Out_Unfiltered = 1 - state.f_Out_Filtered;

 
 
    DERIV(state.s_X,[independent.t]) =
  ((state.X_In * state.Q_In + state.X_Backwash * state.Q_Backwash - state.Q_Out_Filtered * state.X_Out_Filtered - state.Q_Out_Unfiltered * state.X_Out_Unfiltered)
    / parameters.A);

 
    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
       DERIV(state.M_X[Comp_Index],[independent.t]) =
      ( interface.Inflow[Comp_Index] + interface.Inflow_Backwash[Comp_Index]
    + interface.Outflow_Filtered[Comp_Index] + interface.Outflow_Unfiltered[Comp_Index]);
     };

 

# 204 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sandfilter/wwtp.base.sand_filter.simpledownflow.msl"




    state.X_In =  IF (state.Q_In == 0)
            THEN 0
          ELSE interface.Inflow[IndexOfTSSComponent] / state.Q_In;

    state.X_Backwash =  IF (state.Q_Backwash == 0)
            THEN 0
            ELSE interface.Inflow_Backwash[IndexOfTSSComponent] / state.Q_Backwash;

    state.X_Out_Filtered =  IF (state.Q_Out_Filtered == 0)
                THEN 0
                ELSE (- interface.Outflow_Filtered[IndexOfTSSComponent] / state.Q_Out_Filtered );

    state.X_Out_Unfiltered = IF (state.Q_Out_Unfiltered == 0)
                         THEN 0
                             ELSE - interface.Outflow_Unfiltered[IndexOfTSSComponent] / (state.Q_Out_Unfiltered );



 
 

    state.b_Backwash =  IF (state.H > parameters.H_Max)
            THEN interface.Backwash * state.Q_Backwash * parameters.Backwash_Intensity
            ELSE 0;

 

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Filtered[Comp_Index] = - interface.Inflow[Comp_Index] * parameters.f_nf * state.f_Out_Filtered
                   - (1 - interface.Backwash) * interface.Inflow_Backwash[Comp_Index] ;
     };

    {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index];
     };

    {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
      interface.Outflow_Unfiltered[Comp_Index] = - interface.Inflow[Comp_Index] * state.f_Out_Unfiltered 
                 - interface.Backwash * interface.Inflow_Backwash[Comp_Index] 
                 - state.M_X[Comp_Index] * state.b_Backwash;
     };

   };
 :};




# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sand_filter.msl" 2




# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.anaerobic_digestion.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl" 1
 


















# 253 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.lessarddesjardins.msl"



# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.anaerobic_digestion.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl" 1
 


















# 804 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion.siegrist.msl"



# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.anaerobic_digestion.msl" 2



# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 1
 


















CLASS Sensor
  "sensor"
  SPECIALISES PhysicalDAEModelType :=
  {:
    interface <-
    {
		OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent":};
		OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent":};
    };
    parameters <- 
    {
	 
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components" : MassFluxVector ;
		OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
    };
    initial <- 
    {
		 
    };
    equations <- 
    {
		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			state.InFluxPerComponent[Comp_Index] =
				SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: (In_Terminal[Comp_Index]) ; };

		{FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
			interface.Outflow[Comp_Index] = - state.InFluxPerComponent[Comp_Index] ; }; 

		state.Q_In = 0.000001 * state.InFluxPerComponent[IndexOfSolvent] ;
    };
  :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_flow.msl" 1
 














 




CLASS Sensor_Flow
  (* icon = "sensor_flow" ; is_default = "true" *)
  "Flow sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the flow rate";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
    };

    equations <-
    {
      {interface.y_M = state.Q_In ;};
    };
 :};





# 59 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_do.msl" 1
 



















CLASS Sensor_DO
  (* icon = "sensor_do" ; is_default = "true" *)
  "Oxygen sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the dissolved oxygen";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_O] / state.Q_In ; };
     };
  :};




# 60 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_nh4.msl" 1
 



















CLASS Sensor_NH4
  (* icon = "sensor_nh4" ; is_default = "true" *)
  "Ammonia sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the ammonia concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
   
    equations <-
    {
       {interface.y_M = IF (state.Q_In == 0)
        THEN 0
        ELSE interface.Inflow[S_NH] / state.Q_In ; };
    };
  :};




# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_no3.msl" 1
 



















CLASS Sensor_NO3
  (* icon = "sensor_no3" ; is_default = "true" *)
  "Nitrate sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the nitrate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE interface.Inflow[S_NO] / state.Q_In ; };
    };
  :};




# 62 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tss.msl" 1
 



















CLASS Sensor_TSS
  (* icon = "sensor_tss" ; is_default = "true" *)
  "Suspended solids sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the particulate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {
      OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};
    };

    equations <-
    {

 










       interface.y_M = IF (state.Q_In == 0)
              THEN 0
            ELSE interface.Inflow[X_TSS] / state.Q_In ; 

    };
  :};




# 63 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl" 1
 



















CLASS Sensor_COD
  (* icon = "sensor_cod" ; is_default = "true" *)
  "COD sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the Chemical Oxygen Demand";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
# 44 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"



    interface.y_M = IF (state.Q_In == 0)
            THEN 0
            ELSE (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S]
          + interface.Inflow[S_I] + interface.Inflow[X_I]
          + interface.Inflow[X_AUT] + interface.Inflow[X_H] 
          + interface.Inflow[X_PAO] + interface.Inflow[X_PHA])
             / state.Q_In ; 
  


# 66 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"


# 77 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_cod.msl"

  };
    :};




# 64 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl" 1
 



















CLASS Sensor_BOD
  (* icon = "sensor_bod" ; is_default = "true" *)
  "BOD sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the Biodegradable Oxygen Demand";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {





     OBJ f_X_I "Fraction of inert COD generated in biomass lysis"
      : Fraction := {:value <- 0.10 ; group <- "Stoichiometry" :};





     OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};
     };

    equations <-
    {
# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"



    interface.y_M = IF (state.Q_In == 0)
                THEN 0
                ELSE parameters.F_BOD_COD *
    (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S] + interface.Inflow[X_PHA]
     + (1 - parameters.f_X_I) * (interface.Inflow[X_AUT] + interface.Inflow[X_H] + interface.Inflow[X_PAO] ))
      / state.Q_In ; 
  


# 81 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"


# 91 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_bod.msl"

  };
    :};




# 65 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl" 1
 














 




CLASS Sensor_TN
  (* icon = "sensor_tn" ; is_default = "true" *)
  "Total nitrogen sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the total nitrogen concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {








     OBJ i_N_S_I "Nitrogen content of inert soluble COD S_I"
      : NitrogenConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
     OBJ i_N_S_F "Nitrogen content of soluble substrate S_F"
      : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
     OBJ i_N_X_I "Nitrogen content of inert particulate COD X_I"
      : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
     OBJ i_N_X_S "Nitrogen content of particulate substrate X_S"
      : NitrogenConversionFactor := {:value <- 0.04 ; group <- "Composition parameters" :};
     OBJ i_N_BM "Nitrogen content of biomass X_H, X_PAO, X_AUT"
      : NitrogenConversionFactor := {:value <- 0.07 ; group <- "Composition parameters" :};


# 67 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 80 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"

     };

    equations <-
    {
# 93 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"



  {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE 
    (interface.Inflow[S_NO] + interface.Inflow[S_NH]
     + parameters.i_N_S_I * interface.Inflow[S_I] 
     + parameters.i_N_S_F * interface.Inflow[S_F] 
     + parameters.i_N_X_I * interface.Inflow[X_I] 
     + parameters.i_N_X_S * interface.Inflow[X_S] 
     + parameters.i_N_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) 
    / state.Q_In ; };


# 119 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"


# 132 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tn.msl"

    };
  :};




# 66 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl" 1
 














 




CLASS Sensor_TKN
  (* icon = "sensor_tkn" ; is_default = "true" *)
  "Total Kjeldal nitrogen sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the total Kjeldal nitrogen concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {








     OBJ i_N_S_I "Nitrogen content of inert soluble COD S_I"
      : NitrogenConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
     OBJ i_N_S_F "Nitrogen content of soluble substrate S_F"
      : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
     OBJ i_N_X_I "Nitrogen content of inert particulate COD X_I"
      : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
     OBJ i_N_X_S "Nitrogen content of particulate substrate X_S"
      : NitrogenConversionFactor := {:value <- 0.04 ; group <- "Composition parameters" :};
     OBJ i_N_BM "Nitrogen content of biomass X_H, X_PAO, X_AUT"
      : NitrogenConversionFactor := {:value <- 0.07 ; group <- "Composition parameters" :};


# 67 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 80 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"

     };

    equations <-
    {
# 93 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"



  {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE 
    (+ interface.Inflow[S_NH]
     + parameters.i_N_S_I * interface.Inflow[S_I] 
     + parameters.i_N_S_F * interface.Inflow[S_F] 
     + parameters.i_N_X_I * interface.Inflow[X_I] 
     + parameters.i_N_X_S * interface.Inflow[X_S] 
     + parameters.i_N_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) 
    / state.Q_In ; };


# 119 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"


# 132 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tkn.msl"

    };
  :};




# 67 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl" 1
 




















CLASS Sensor_TP
  (* icon = "sensor_tp" ; is_default = "true" *)
  "Total phosphorus sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the total phosphorus concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    parameters <-
    {

     OBJ i_P_S_I "Phosphorus content of inert soluble COD S_I"
      : PhosphorusConversionFactor := {:value <- 0.00 ; group <- "Composition parameters" :};
     OBJ i_P_S_F "Phosphorus content of soluble substrate S_F"
      : PhosphorusConversionFactor := {:value <-0.01 ; group <- "Composition parameters" :};
     OBJ i_P_X_I "Phosphorus content of inert particulate COD X_I"
      : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
     OBJ i_P_X_S "Phosphorus content of particulate substrate X_S"
      : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
     OBJ i_P_BM "Phosphorus content of biomass X_H, X_PAO, X_AUT"
      : PhosphorusConversionFactor := {:value <- 0.02 ; group <- "Composition parameters" :};


# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl"

     };

        equations <-
    {

      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE 
    (interface.Inflow[S_PO] + interface.Inflow[X_PP] + 
     + 0.205 * interface.Inflow[X_MEP]
       + parameters.i_P_S_I * interface.Inflow[S_I] 
     + parameters.i_P_S_F * interface.Inflow[S_F] 
     + parameters.i_P_X_I * interface.Inflow[X_I] 
     + parameters.i_P_X_S * interface.Inflow[X_S] 
     + parameters.i_P_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) )
    / state.Q_In ; };


# 91 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_tp.msl"

    };
  :};




# 68 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_po4.msl" 1
 



















CLASS Sensor_PO4
  (* icon = "sensor_po4" ; is_default = "true" *)
  "Phosphate sensor"
  EXTENDS Sensor WITH 
  {:
    comments <- "A model for a sensor measuring the phosphate concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2"; is_favorite = "1" *) "Sensor measured output" :
         Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
    equations <-
    {
      {interface.y_M = IF (state.Q_In == 0)
           THEN 0
           ELSE interface.Inflow[S_PO] / state.Q_In ; };
    };
  :};




# 69 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sensor/wwtp.base.sensors.sensor_multi.msl" 1
 














 




CLASS MultiSensor (* icon = "sensor_multi"; is_default = "true" *) "Multi-probe sensor" EXTENDS Sensor WITH 
  {:
    comments <- "A model for a multi-probe sensor";
    interface <-
    {
		OBJ y_Q (* terminal = "out_2"; is_favorite = "1" *) "Flow rate" : FlowRate := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		OBJ y_DO (* terminal = "out_2"; is_favorite = "1" *) "Oxygen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NH (* terminal = "out_2"; is_favorite = "1" *) "Ammonia concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_NO (* terminal = "out_2"; is_favorite = "1" *) "Nitrate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TSS (* terminal = "out_2"; is_favorite = "1" *) "Particulates concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_COD (* terminal = "out_2"; is_favorite = "1" *) "COD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_BOD (* terminal = "out_2"; is_favorite = "1" *) "BOD concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TN (* terminal = "out_2"; is_favorite = "1" *) "Total Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_TKN (* terminal = "out_2"; is_favorite = "1" *) "Total Kjeldahl Nitrogen concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		
		
		OBJ y_TP (* terminal = "out_2"; is_favorite = "1" *) "Total Phosphorous concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		OBJ y_PO (* terminal = "out_2"; is_favorite = "1" *) "Phosphate concentration" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
		
    };
    parameters <- 
    {
		OBJ F_TSS_COD "Fraction TSS/COD" : Ratio := {: value <- 0.75 ; group <- "Conversion factors":};

		


		
		OBJ f_X_I "Fraction of inert COD generated in biomass lysis" : Fraction := {: value <- 0.10 ; group <- "Stoichiometry" :};
		
		


		OBJ F_BOD_COD "Conversion factor BOD/COD" : Fraction := {:value<- 0.65 ; group <- "Conversion factors":};

		



		
		OBJ i_N_S_I "Nitrogen content of inert soluble COD S_I" : NitrogenConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
		OBJ i_N_X_I "Nitrogen content of inert particulate COD X_I" : NitrogenConversionFactor := {:value <- 0.03 ; group <- "Composition parameters" :};
		OBJ i_N_X_S "Nitrogen content of particulate substrate X_S" : NitrogenConversionFactor := {:value <- 0.04 ; group <- "Composition parameters" :};
		OBJ i_N_BM "Nitrogen content of biomass X_H, X_PAO, X_AUT" : NitrogenConversionFactor := {:value <- 0.07 ; group <- "Composition parameters" :};
		
		






		







		
		OBJ i_P_S_I "Phosphorus content of inert soluble COD S_I" : PhosphorusConversionFactor := {:value <- 0.00 ; group <- "Composition parameters" :};
		OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : PhosphorusConversionFactor := {:value <-0.01 ; group <- "Composition parameters" :};
		OBJ i_P_X_I "Phosphorus content of inert particulate COD X_I" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_P_X_S "Phosphorus content of particulate substrate X_S" : PhosphorusConversionFactor := {:value <- 0.01 ; group <- "Composition parameters" :};
		OBJ i_P_BM "Phosphorus content of biomass X_H, X_PAO, X_AUT" : PhosphorusConversionFactor := {:value <- 0.02 ; group <- "Composition parameters" :};
		
		






    };
    equations <- 
    {
		interface.y_Q = state.Q_In ;

		
		interface.y_DO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_O] / state.Q_In ;

		interface.y_NH = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NH] / state.Q_In ;

		interface.y_NO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_NO] / state.Q_In ;
		 
		 
		




		
		interface.y_TSS = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[X_TSS] / state.Q_In ; 
		
		 
		 
		




		
		interface.y_COD = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_A] + interface.Inflow[S_F] + interface.Inflow[X_S] +
			interface.Inflow[S_I] + interface.Inflow[X_I] + interface.Inflow[X_AUT] +
			interface.Inflow[X_H] + interface.Inflow[X_PAO] + interface.Inflow[X_PHA]) / state.Q_In ; 
		
		




		





		 
		 
		




		
		interface.y_BOD = IF (state.Q_In == 0) THEN 0
			ELSE parameters.F_BOD_COD * (interface.Inflow[S_A] + interface.Inflow[S_F] +
			interface.Inflow[X_S] + interface.Inflow[X_PHA] + (1 - parameters.f_X_I) * (interface.Inflow[X_AUT] +
			interface.Inflow[X_H] + interface.Inflow[X_PAO] )) / state.Q_In ; 
		
		




		





		 
		 
		





		
		interface.y_TN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NO] + interface.Inflow[S_NH] + parameters.i_N_S_I * interface.Inflow[S_I] +
			parameters.i_N_S_F * interface.Inflow[S_F] + parameters.i_N_X_I * interface.Inflow[X_I] +
			parameters.i_N_X_S * interface.Inflow[X_S] + parameters.i_N_BM * (interface.Inflow[X_H] +
			interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		





		






		 
		 
		





		
		interface.y_TKN = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_NH] + parameters.i_N_S_I * interface.Inflow[S_I] +
			parameters.i_N_S_F * interface.Inflow[S_F] + parameters.i_N_X_I * interface.Inflow[X_I] +
			parameters.i_N_X_S * interface.Inflow[X_S] + parameters.i_N_BM * (interface.Inflow[X_H] +
			interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		





		






		 
		 
		
		interface.y_TP = IF (state.Q_In == 0) THEN 0
			ELSE (interface.Inflow[S_PO] + interface.Inflow[X_PP] + 0.205 * interface.Inflow[X_MEP] +
			parameters.i_P_S_I * interface.Inflow[S_I] + parameters.i_P_S_F * interface.Inflow[S_F] +
			parameters.i_P_X_I * interface.Inflow[X_I] + parameters.i_P_X_S * interface.Inflow[X_S] +
			parameters.i_P_BM * (interface.Inflow[X_H] + interface.Inflow[X_AUT] + interface.Inflow[X_PAO]) ) / state.Q_In ;
		
		






		 
		 
		
		interface.y_PO = IF (state.Q_In == 0) THEN 0
			ELSE interface.Inflow[S_PO] / state.Q_In ; 
		

		
    };

  :};

  CLASS NH4_load
  (* icon = "sensor_multi" *)
  "sensor"
  EXTENDS Sensor WITH
  {:
    comments <- "A model for a sensor measuring the ammonia concentration";

    interface <-
    {
      OBJ y_M (* terminal = "out_2" *) "Sensor measured output" :
         Real := {: causality <- "COUT" ; group <- "Measurement data" :};
    };
    
   
    equations <-
    {
       interface.y_M = interface.Inflow[S_NH];
    };
  :};




# 72 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sensors.msl" 2




# 42 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.onoffideal.msl" 1
 


















CLASS OnOffIdeal
  (* icon = "controller_on_off" ; is_default = "" *)
  "Ideal On-off controller"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help_u (* hidden = "1" *) "Previous u help variable" : Real;
     OBJ help_t (* hidden = "1" *) "Previous t help variable" : Real;
    };

    equations <-
    {
    state.e = interface.y_S - interface.y_M;

    state.help_u = interface.u;
    state.help_t = independent.t;
    interface.u = IF (interface.y_M > interface.y_S)
                  THEN interface.u_Off
                  ELSE interface.u_On;
   };

 :};

CLASS OnOff_rivdev
  (* icon = "controller_on_off" ; is_default = "" *)
  "On-off controller  for river diversion when CSO active" 
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
         Real := {: causality <- "CIN" ; value <- 2  ; group <- "Operational":};

    };

    parameters <-
    {
	    OBJ u_Off "Output when CSO not active" : Real := {: value <- 1 ; group <- "Operational" :};  
      OBJ u_On  "Output when CSO active"  : Real := {: value <- 1 ; group <- "Operational" :};
    };
	
   independent <- 
   { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
    };

    equations <-
    {
    interface.u = IF (interface.y_M < interface.y_S)
                  THEN parameters.u_Off
                  ELSE parameters.u_On;
   };

 :};


# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.onoffband.msl" 1
 


















CLASS OnOffBand
  (* icon = "controller_on_off" ; is_default = "true" *)
  "On-off controller with a band"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for an on-off controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ y_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 1.8  ; group <- "Operational":};
    OBJ y_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum allowed measured value" : 
         Real := {: causality <- "CIN" ; value <- 2.2  ; group <- "Operational":};
    OBJ u_Off (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when off" : 
    Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u_On  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Output when on"  : 
    Real := {: causality <- "CIN" ; value <- 20 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

  independent <- 
  { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
   };

    state <-
    {
    };

    equations <-
    {
    interface.u = IF(interface.y_M < interface.y_Min)
                  THEN interface.u_On
                  ELSE
                    IF (interface.y_M > interface.y_Max)
                    THEN interface.u_Off
                    ELSE previous(interface.u) ;
   };

 :};

 


# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.constantratio.msl" 1
 


















CLASS ConstantRatio
  (* icon = "controller_ratio" *)
  "Ratio controller"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a ratio controller";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" :
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" :
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ ConstantRatio (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Ratio between measured value and controller output" :
        Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    equations <-
    {

    interface.u = interface.ConstantRatio * interface.y_M;

    };
  :};

CLASS ConstantRatio_double
    (* icon = "controller_ratio" *)
    "Ratio controller with two ratios for two input ranges"
  
    SPECIALISES
    PhysicalDAEModelType :=
    {:
      comments <- "A model for a ratio controller";
      interface <-
      {
        OBJ y_M (* terminal = "in_1" *) "Sensor measured output" :
                 Real := {: causality <- "CIN" ; group <- "Measurement data" :};
        OBJ u (* terminal = "out_1" *) "Controlled variable" :
                 Real := {: causality <- "COUT" ; group <- "Control action" :};
      };
  
      parameters <-
      {
      OBJ ConstantRatio1 "Ratio between measured value and controller output, first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
      OBJ ConstantRatio2 "Ratio between measured value and controller output, second input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
  	  OBJ y_M_min "Minimumum measured value for first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
  	  OBJ y_M_mid "Maximum measured value for first input range" :
           Real := {: value <- 1 ; group <- "Operational" :};
      OBJ u_min "Minimum output, calculated as y_M_min*ConstantRatio1" :
           Real := {: value <- 1 ; group <- "Operational" :};
	    OBJ u_max "Maximum output, calculated as y_M_min*ConstantRatio1" :
           Real := {: value <- 1 ; group <- "Operational" :};
      };
  
      equations <-
      {
  
      interface.u = IF (interface.y_M < parameters.y_M_min)
  				  				THEN parameters.u_min
  				  				ELSE IF (interface.y_M < parameters.y_M_mid)
  				  	   				THEN interface.y_M * parameters.ConstantRatio1
  					   					ELSE IF ((parameters.ConstantRatio2 * interface.y_M) < parameters.u_max)
															THEN parameters.ConstantRatio2 * interface.y_M
															ELSE parameters.u_max;
  
      };
  :};

 


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.p_saturation.msl" 1
 


















CLASS P_Saturation
  (* icon = "controller_p" *)
  "P controller with saturation"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.e = interface.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

CLASS P_sp_Saturation
  (* icon = "controller_p" *)
  "P controller with saturation, proportional to set-point"

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
     OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable " : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
	   OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "u=u0+kp*ys" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
    };

    equations <-
    {

     state.uhelp = interface.u0 + interface.K_P * interface.y_S;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

CLASS P_Saturation_seas
  (* icon = "controller_p" *)
  "P controller with saturation, seasonal"

 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S_s  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable, summer" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
	   OBJ y_S_w  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable, winter" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) " Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
	   OBJ seas  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Season: 1 = winter, 0 = summer" : 
     Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
      
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional control action" : Real;
	   OBJ y_S (* hidden = "0" *) "Set-point" : Real;
    };

    equations <-
    {
     state.y_S = IF(interface.seas == 1)
                 THEN interface.y_S_w
                 ELSE interface.y_S_s;
     state.e = state.y_S - interface.y_M ;
     state.uhelp = interface.u0 + interface.K_P * state.e;

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
   };

 :};

CLASS shared_capacity
  (* icon = "controller_p" *)
  "Defines set-point of downstream controller as spare capacity from a shared resource"  

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Used capacity" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Spare capacity" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
           
    };

    parameters <-
    {
	   OBJ max  "Maximum capacity" : Real := {: group <- "Operational" :};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
    };

    equations <-
    {
     interface.u = parameters.max - interface.y_M;
   };

 :};

 


# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.pi_saturation.msl" 1
 


















CLASS PI_Saturation
  (* icon = "controller_pi"; is_default = "true" *)
  "PI controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ y_S  (* terminal = "in_2"; manip = "1" *) "Setpoint value for controlled variable" : 
     Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
     OBJ K_P  (* terminal = "in_2"; manip = "1" *) "Factor of proportionality" : 
     Real := {: causality <- "CIN" ; value <- 25 ; group <- "Operational" :};
     OBJ T_I  (* terminal = "in_2"; manip = "1" *) "Integral time" : 
     Time := {: causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
     OBJ u0 (* terminal = "in_2"; manip = "1" *) "No error action" : 
     Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
     OBJ u_Min  (* terminal = "in_2"; manip = "1" *) "Minimum control action" : 
     Real := {: causality <- "CIN" ;value <- 0 ; group <- "Operational" :};
     OBJ u_Max  (* terminal = "in_2"; manip = "1" *) "Maximum control action" : 
     Real := {: causality <- "CIN" ;value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ e "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral control action" : Real;
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 + interface.K_P 
                     * (state.e + (1 / interface.T_I) * state.Integ_e); 

     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};
 

 


# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\controller/wwtp.base.controllers.pid_saturation.msl" 1
 


















CLASS PID_Saturation
  (* icon = "controller_pid" *)
  "PID controller with saturation"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    comments <- "A model for a proportional-integral-derivative controller with saturation";
    interface <-
    {
      OBJ y_M (* terminal = "in_1"; is_favorite = "1" *) "Sensor measured output" : 
               Real := {: causality <- "CIN" ; group <- "Measurement data" :};
      OBJ u (* terminal = "out_1"; is_favorite = "1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
      OBJ K_P (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Factor of proportionality" : 
        Real := {: causality <- "CIN" ; value <- 11.31977725 ; group <- "Operational" :};
      OBJ T_I (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Integral time" : 
        Time := {: causality <- "CIN" ; value <- 0.5062161847 ; group <- "Operational" :};
      OBJ T_D (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Derivative time" : 
        Time := {: causality <- "CIN" ; value <- 0.2531080923 ; group <- "Operational" :};
      OBJ y_S (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Setpoint value for controlled variable" : 
        Real := {: causality <- "CIN" ; value <- 2 ; group <- "Operational" :};
      OBJ u0  (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "No error action" : 
        Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};
      OBJ u_Min (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Minimum control action" : 
        Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
      OBJ u_Max (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Maximum control action" : 
        Real := {: causality <- "CIN" ; value <- 1000 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
     OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
     OBJ Integ_e "Integral of error": PhysicalQuantityType := {: group <- "Operational" :};
     OBJ e (* is_favorite = "1" *) "Error" : PhysicalQuantityType := {: group <- "Operational" :};
     OBJ help (* hidden = "1" *) " Previous time help variable" : Time;
     OBJ uhelp (* hidden = "1" *) "Help variable to calculate the proportional-integral-derivative control action" : Real;
     OBJ Deriv_e  "Derivative of error" : Real := {: group <- "Operational" :};
     OBJ Prev_t (* hidden = "1" *) : Time;
    };

    equations <-
    {
     state.e = interface.y_S - interface.y_M;

     state.help = independent.t;

   state.Deriv_e = IF (previous(state.help) != state.help)
             THEN (previous(state.e) - state.e) / (previous(state.help) - state.help)
             ELSE previous(state.Deriv_e);  

     DERIV(state.Integ_e, [independent.t]) = state.e ;

     state.uhelp = interface.u0 
           + interface.K_P * (state.e + interface.T_D * state.Deriv_e 
                       + state.Integ_e / interface.T_I); 
                      
     interface.u = IF(state.uhelp < interface.u_Min)
                   THEN (interface.u_Min)
                   ELSE
                     IF (state.uhelp > interface.u_Max)
                     THEN interface.u_Max
                     ELSE state.uhelp;
    };
  :};

 


# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.controllers.msl" 2

 


# 43 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer21.msl" 1
 














 



CLASS Timer21
  (* icon = "timer" ; is_default = "true" *)
  "Timer with 2 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
     OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
     OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
      THEN  interface.u11
      ELSE  interface.u12;

    };
  :};

  

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer22.msl" 1
 


















CLASS Timer22
  (* icon = "timer" *)
  "Timer with 2 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 0 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};    
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE  interface.u12;

    interface.u2 = IF  (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE  interface.u22;
    };
  :};

  

# 21 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer31.msl" 1
 


















CLASS Timer31
  (* icon = "timer" *)
  "Timer with 3 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};     
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
       THEN interface.u11
       ELSE
         IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
         THEN interface.u12
         ELSE interface.u13;
    };
  :};

  


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer32.msl" 1
 


















CLASS Timer32
  (* icon = "timer" *)
  "Timer with 3 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u12
          ELSE  interface.u13;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u22
          ELSE  interface.u23;

    };
  :};
	
	CLASS Timer33
  (* icon = "timer" *)
  "Timer with 3 periods and 3 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ u3 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};  
		OBJ u31 (* terminal = "in_2"; manip = "1" *) "Output 3 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u32 (* terminal = "in_2"; manip = "1" *) "Output 3 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u33 (* terminal = "in_2"; manip = "1" *) "Output 3 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};       
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u12
          ELSE  interface.u13;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u22
          ELSE  interface.u23;
		
		interface.u3 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u31
        ELSE
          IF  (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN  interface.u32
          ELSE  interface.u33;

    };
  :};

  


# 23 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer41.msl" 1
 


















CLASS Timer41
  (* icon = "timer" *)
  "Timer with 4 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};      
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;
    };
  :};

  


# 24 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer42.msl" 1
 


















CLASS Timer42
  (* icon = "timer" *)
  "Timer with 4 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third period" : Real := {: causality <- "CIN" ; value <- 50 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.125 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.1 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.025 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < (state.T))
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE  interface.u14;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE  interface.u24;
    };
  :};

  


# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer51.msl" 1
 


















CLASS Timer51
  (* icon = "timer" *)
  "Timer with 5 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;
    };
  :};

  


# 26 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer52.msl" 1
 


















CLASS Timer52
  (* icon = "timer" *)
  "Timer with 5 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 100 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};         
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 800 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4+ interface.T5 ;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
        THEN interface.u11
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u12
          ELSE 
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u13
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u14
              ELSE  interface.u15;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
        THEN  interface.u21
        ELSE
          IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
          THEN interface.u22
          ELSE
        IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
            THEN  interface.u23
            ELSE
          IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
              THEN  interface.u24
              ELSE  interface.u25;

    };
  :};

  


# 27 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer61.msl" 1
 


















CLASS Timer61
  (* icon = "timer" *)
  "Timer with 6 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;
    };
  :};

  


# 28 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer62.msl" 1
 


















CLASS Timer62
  (* icon = "timer" *)
  "Timer with 6 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE  interface.u16;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE  interface.u26;

    };
  :};

  


# 29 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer71.msl" 1
 


















CLASS Timer71
  (* icon = "timer" *)
  "Timer with 7 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;
    };
  :};

  


# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer72.msl" 1
 


















CLASS Timer72
  (* icon = "timer" *)
  "Timer with 7 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE  interface.u17;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE  interface.u27;

    };
  :};

  

# 31 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer81.msl" 1
 














 



CLASS Timer81
  (* icon = "timer" *)
  "Timer with 8 periods and 1 output"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eight period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
  OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eight period" : Time := {:causality <- "CIN" ; value <- 0.020 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
               THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;
    };
  :};

  

# 32 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\timer/wwtp.base.timers.timer82.msl" 1
 


















CLASS Timer82
  (* icon = "timer" *)
  "Timer with 8 periods and 2 outputs"

 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
     OBJ u1 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
     OBJ u2 (* terminal = "out_1" *) "Controlled variable" : 
               Real := {: causality <- "COUT" ; group <- "Control action" :};
    OBJ u11 (* terminal = "in_2"; manip = "1" *) "Output 1 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u12 (* terminal = "in_2"; manip = "1" *) "Output 1 in the second period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u13 (* terminal = "in_2"; manip = "1" *) "Output 1 in the third period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u14 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u15 (* terminal = "in_2"; manip = "1" *) "Output 1 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u16 (* terminal = "in_2"; manip = "1" *) "Output 1 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u17 (* terminal = "in_2"; manip = "1" *) "Output 1 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u18 (* terminal = "in_2"; manip = "1" *) "Output 1 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};          
    OBJ u21 (* terminal = "in_2"; manip = "1" *) "Output 2 in the first period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :}; 
    OBJ u22 (* terminal = "in_2"; manip = "1" *) "Output 2 in the second reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};
    OBJ u23 (* terminal = "in_2"; manip = "1" *) "Output 2 in the third reaction period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u24 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fourth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};   
    OBJ u25 (* terminal = "in_2"; manip = "1" *) "Output 2 in the fifth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u26 (* terminal = "in_2"; manip = "1" *) "Output 2 in the sixth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u27 (* terminal = "in_2"; manip = "1" *) "Output 2 in the seventh period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ u28 (* terminal = "in_2"; manip = "1" *) "Output 2 in the eigth period" : Real := {: causality <- "CIN" ; value <- 1 ; group <- "Operational" :};               
    OBJ T1 (* terminal = "in_2"; manip = "1" *) "First period" : Time := {:causality <- "CIN" ; value <- 0.04 ; group <- "Operational" :};
    OBJ T2 (* terminal = "in_2"; manip = "1" *) "Second reaction period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T3 (* terminal = "in_2"; manip = "1" *) "Third reaction period" : Time := {:causality <- "CIN" ; value <- 0.060 ; group <- "Operational" :};
    OBJ T4 (* terminal = "in_2"; manip = "1" *) "Fourth and draw period" : Time := {:causality <- "CIN" ; value <- 0.065 ; group <- "Operational" :};
    OBJ T5 (* terminal = "in_2"; manip = "1" *) "Fifth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T6 (* terminal = "in_2"; manip = "1" *) "Sixth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T7 (* terminal = "in_2"; manip = "1" *) "Seventh period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    OBJ T8 (* terminal = "in_2"; manip = "1" *) "Eigth period" : Time := {:causality <- "CIN" ; value <- 0.02 ; group <- "Operational" :};
    };

    parameters <-
    {
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
     {
    OBJ Prev_t (* hidden = "1" *) "Help variable to calculate the begin of each period" : Time ;
    OBJ T "Total cycle" : Time := {: group <- "Operational" :};
     };

    initial <-
    {
    };

    equations <-
    {
    state.T = interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7 + interface.T8;

    state.Prev_t =  IF  (independent.t - previous(state.Prev_t) < state.T)
        THEN  previous(state.Prev_t)
        ELSE  previous(state.Prev_t) + state.T;

    interface.u1 = IF (independent.t - state.Prev_t < interface.T1)
             THEN interface.u11
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u12
             ELSE 
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u13
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u14
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u15
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u16
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u17
                       ELSE  interface.u18;

    interface.u2 = IF (independent.t - state.Prev_t < interface.T1)
             THEN  interface.u21
             ELSE
               IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2))
             THEN interface.u22
             ELSE
             IF   (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3))
               THEN interface.u23
               ELSE
                 IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4))
                 THEN  interface.u24
                 ELSE
                   IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5))
                   THEN  interface.u25
                   ELSE
                     IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6))
                     THEN  interface.u26
                     ELSE
                         IF    (independent.t - state.Prev_t < (interface.T1 + interface.T2 + interface.T3 + interface.T4 + interface.T5 + interface.T6 + interface.T7))
                       THEN  interface.u27
                       ELSE  interface.u28;

    };
  :};

  

# 33 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.timers.msl" 2

  

# 44 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.loopbreaker.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\loopbreaker/wwtp.base.loopbreaker.differentialloopbreaker.msl" 1
 


















CLASS DifferentialLoopBreaker
(* icon = "loop_breaker" *)
"An Explicit Implicit Algebraic Loop Breaker using differential equations "

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker without differential equations";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "inflow" :
        InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "outflow" :
        OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  parameters <-
  {
   OBJ Tau "Implicit loop breaker time constant, d" : Time := {: value <- 0.0005 ; group <- "Miscellaneous" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

  state <-
  {
   OBJ FluxPerComponent (* hidden = "1" *) : MassFluxVector;
  };

  equations <-
  {

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      DERIV(state.FluxPerComponent[Comp_Index],[independent.t]) =
       - (1 / parameters.Tau) *
       (state.FluxPerComponent[Comp_Index] - interface.Inflow[Comp_Index]);
   };

   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      interface.Outflow[Comp_Index] =
       - state.FluxPerComponent[Comp_Index];
   };

  };

:};




# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.loopbreaker.msl" 2


CLASS LoopBreaker
(* icon = "loop_breaker" ; is_default = "true" *)
"An Explicit Implicit Algebraic Loop Breaker using previous"

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker with previous functions";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" :
        InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" :
        OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

 parameters <-
 {
   
 };

 state <-
 {
  OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : MassFluxVector;
 };

 initial <-
 {
   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] = 0;
        
   };
 };

 equations <-
 {
   { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
       (In_Terminal[Comp_Index]);
   };

  { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
     interface.Outflow[Comp_Index] =
       - previous(state.InFluxPerComponent[Comp_Index]);
  };

 };

:};




# 45 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.process_calculator.msl" 1
 


















CLASS BaseParameters
  "Base class for all process calculators, ie cost and process parameters"

  SPECIALISES
  PhysicalDAEModelType :=
  {:

    interface <-
    {
   
  OBJ V1 (* terminal = "in_1" *)"Volume of unit 1" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V2 (* terminal = "in_1" *)"Volume of unit 2" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V3 (* terminal = "in_1" *)"Volume of unit 3" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V4 (* terminal = "in_1" *)"Volume of unit 4" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V5 (* terminal = "in_1" *)"Volume of unit 5" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V6 (* terminal = "in_1" *)"Volume of unit 6" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V7 (* terminal = "in_1" *)"Volume of unit 7" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V8 (* terminal = "in_1" *)"Volume of unit 8" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V9 (* terminal = "in_1" *)"Volume of unit 9" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
    OBJ V10 (* terminal = "in_1" *)"Volume of unit 10" : Volume := {:causality <- "CIN" ; group <- "Dimension" :};
   
  OBJ TSS1 (* terminal = "in_1" *) "Tot.susp.solids (unit 1)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS2 (* terminal = "in_1" *) "Tot.susp.solids (unit 2)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS3 (* terminal = "in_1" *) "Tot.susp.solids (unit 3)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS4 (* terminal = "in_1" *) "Tot.susp.solids (unit 4)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS5 (* terminal = "in_1" *) "Tot.susp.solids (unit 5)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS6 (* terminal = "in_1" *) "Tot.susp.solids (unit 6)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS7 (* terminal = "in_1" *) "Tot.susp.solids (unit 7)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS8 (* terminal = "in_1" *) "Tot.susp.solids (unit 8)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS9 (* terminal = "in_1" *) "Tot.susp.solids (unit 9)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
    OBJ TSS10 (* terminal = "in_1" *) "Tot.susp.solids (unit 10)": Concentration:= {:causality <- "CIN" ; group <- "Measurement data" :};
   
   
  OBJ Q_Waste (*terminal = "in_1" *) "Flow rate of waste sludge": FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
  OBJ TSS_waste (* terminal = "in_1" *) "Suspended solids in the waste sludge" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };
  
  independent <-
    {
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

  parameters <-
    {
    };

  state <-
    {
  OBJ m_TSS (* hidden = "1" *) "Amount of sludge accumulated in the system" : Mass :={:group <- "Measurement data":};
    OBJ V (* hidden = "1" *) "Total volume of the tanks" : Volume := {: group <- "Dimension" :};
    };

  equations <-
    {
  state.m_TSS = interface.V1 * interface.TSS1 + interface.V2 * interface.TSS2 + interface.V3 * interface.TSS3
         + interface.V4 * interface.TSS4 + interface.V5 * interface.TSS5 + interface.V6 * interface.TSS6
         + interface.V7 * interface.TSS7 + interface.V8 * interface.TSS8 + interface.V9 * interface.TSS9
         + interface.V10 * interface.TSS10 ;
  state.V = interface.V1 + interface.V2 + interface.V3 + interface.V4 + interface.V5
        + interface.V6 + interface.V7 + interface.V8 + interface.V9 + interface.V10 ;
    };

  :};

  
CLASS OperationalParameters
  (* icon = "process_calculator" ; is_default = "true" *)
  "Calculation of the basic operational parameters of the plant: eg SRT, HRT"
 
 
 
 

  EXTENDS BaseParameters WITH
  {:
    comments <- "A model for the calculation of basic operational parameters";
    interface <-
    {
   
    OBJ TSS_out (* terminal = "in_1" *) "Sludge concentration in the effluent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
   
  OBJ Q_In (* terminal = "in_1" *) "Influent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational":};
  OBJ Q_Out (* terminal = "in_1" *) "Effluent flow rate": FlowRate:= {:causality <- "CIN" ; group <- "Operational" :};
   
    OBJ BOD_In (* terminal = "in_1" *) "BOD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ COD_In (* terminal = "in_1" *) "COD concentration in the influent" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
    };

    state <-
    {
    OBJ SRT "Instantenous Sludge retention time" : Time := {: group <- "Operational" :};
    OBJ HRT "Hydraulic retention time" : Time := {: group <- "Operational" :};
    OBJ F_M_BOD "Food to microorganism ratio on BOD basis" : Rate := {: group <- "Operational" :};
    OBJ F_M_COD "Food to microorganism ratio on COD basis" : Rate := {: group <- "Operational" :};
    };

    equations <-
    {
   
    state.SRT =  IF ((interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste) <= 0)
                 THEN 0
                 ELSE state.m_TSS / (interface.TSS_out * interface.Q_Out + interface.TSS_waste * interface.Q_Waste);
   
    state.HRT = IF (interface.Q_In == 0)
        THEN 0
        ELSE state.V / interface.Q_In;
    state.F_M_BOD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.BOD_In / (state.m_TSS / interface.Q_In);
    state.F_M_COD = IF (interface.Q_In == 0)
        THEN 0
        ELSE interface.COD_In / (state.m_TSS / interface.Q_In);
     };
  :};
	
	CLASS Sampler
  (* class = "" *)
  "sampler"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
      OBJ y_M (* terminal = "in_1" *) "Quantity to be measured with the sampler" : 
         Concentration := {: causality <- "CIN" :};
      OBJ Q (* terminal = "in_1" *) "Flow rate" : 
         FlowRate := {: causality <- "CIN" :};
      OBJ u (* terminal = "out_1" *) "Measured quantity" : 
         Real := {: causality <- "COUT" :};
    };

    independent <- 
    {
      OBJ t "Time": Time ;
    };
		
	 parameters <- 
    {
	  OBJ unit_cost "Cost of analysis of one sample" : Euro := {: value <- 50 ; group <- "Cost" :};
	};

    state <-
    {
      OBJ Q_in "Influent flow rate" : FlowRate := {: group <- "Sampling" :};
	  OBJ meas_C "Measured concentration" : Concentration := {: group <- "Sampling" :};
	  OBJ meas_L "Measured load" : MassFlux := {: group <- "Sampling" :};
	  OBJ cost "Total sampling cost" : Euro := {: group <- "Cost" :};
    };


    equations <-
    {
      state.Q_in = interface.Q;
	  interface.u = state.meas_L;
    };
 :};

CLASS flow_proportional_time_based_sampler
  (* icon = "process_calculator" *)
  "Flow proportional sampler with time-based emptying of bottle(s)"
  SPECIALISES
  Sampler :=
  {:
    parameters <-
    {
      OBJ t_start "Start time for sampling" : Time := {: value <- 0 ; group <- "Sampling" :};
	  OBJ t_stop "Stop time for sampling" : Time := {: value <- 1 ; group <- "Sampling" :};
	  OBJ detection_limit "Detection limit" : Concentration := {: value <- 0.1 ; group <- "Sampling" :};
	  OBJ min_flow "Minimum flow above which sampling starts" : FlowRate := {: value <- 0 ; group <- "Sampling" :};
	  OBJ V_sample "Volume of each sample; must be <= V_bottles" : Volume := {: value <- 0.0001 ; group <- "Sampling" :};
	  OBJ V_frequency "Volume of water between each sample; must be >= V_sample" : Volume := {: value <- 100 ; group <- "Sampling" :};
	  OBJ frequency "Sampling frequency of composite samples" : Time := {: value <- 1 ; group <- "Sampling" :};
	  OBJ T "Time frame for avg calculation" : Time := {: value <- 1.0 ; group <- "Operational":};
    };

    state <-
    {
	  OBJ flag_samp_per "True if time is in the sampling period" : Boolean := {: group <- "Sampling" :};
	  OBJ V_through "Volume passed through since last sample" : Volume := {: group <- "Sampling" :};
	  OBJ n_samples "Number of samples collected so far in total" : Integer := {: group <- "Sampling" :};
	  OBJ n_samples_bottle "Maximum number of samples per bottle" : Integer := {: group <- "Sampling" :};
	  OBJ n_samples_bottle_temp "Number of samples collected so far in the bottle" : Integer := {: group <- "Sampling" :};
	  OBJ n_comp_samples "Number of composite samples collected so far" : Integer := {: group <- "Sampling" :};
	  OBJ meas_C_comp "Measured concentration in the composite sample before full bottle" : Concentration := {: group <- "Sampling" :};
	  OBJ t1 "Start time for filling bottle" : Time := {: group <- "Sampling" :};
	  OBJ t2 "Stop time for filling bottle" : Time := {: group <- "Sampling" :};
	  OBJ meas_C_av "Measured average concentration" : Concentration := {: group <- "Sampling" :};
    };
	
	initial <-
    {
	  state.flag_samp_per = 0;
	  state.V_through = 0;
	  state.n_samples = 0;
	  state.n_samples_bottle = 0;
	  state.n_samples_bottle_temp = 0;
	  state.meas_C_comp = 0;
	};

    equations <-
    {
	  DERIV(state.meas_C_av,[independent.t]) = (state.meas_C - state.meas_C_av) / parameters.T;
	  state.flag_samp_per = IF ((independent.t >= parameters.t_start) && (independent.t <= parameters.t_stop))
	  					    THEN True
						    ELSE False;
							
	  state.V_through = IF (state.flag_samp_per == True)
	  			        THEN IF (state.Q_in >= parameters.min_flow)
	  				         THEN previous(state.V_through) + state.Q_in * (independent.t - previous(independent.t))
						     ELSE previous(state.V_through)
						ELSE 0;
						
	  state.n_samples = IF (state.flag_samp_per == True)
	  			        THEN IF (state.V_through >= (parameters.V_frequency * (previous(state.n_samples) + 1)))
	  				         THEN previous(state.n_samples) + 1
						     ELSE previous(state.n_samples)
						ELSE 0;
	  
	  state.n_samples_bottle = IF (state.n_comp_samples > previous(state.n_comp_samples))
	  						   THEN state.n_samples
							   ELSE previous(state.n_samples_bottle);
	  
	  state.n_comp_samples = IF (floor((independent.t - parameters.t_start) / parameters.frequency) > 0)
	  					   	 THEN floor((independent.t - parameters.t_start) / parameters.frequency)
							 ELSE 0;
	  
	  state.n_samples_bottle_temp = state.n_samples - state.n_samples_bottle;
	  
	  state.cost = parameters.unit_cost * state.n_comp_samples; 
	  
	  state.meas_C_comp = IF (state.flag_samp_per == True)
	  			          THEN IF (state.n_comp_samples == previous(state.n_comp_samples))
						  	   THEN IF (state.n_samples == previous(state.n_samples))
							   		THEN previous(state.meas_C_comp)
									ELSE (previous(state.meas_C_comp) * (state.n_samples_bottle_temp - 1) + interface.y_M) / (state.n_samples_bottle_temp)
							   ELSE 0
						  ELSE 0;
							    
	  state.meas_C = IF (state.flag_samp_per == True)
	  			   THEN IF (state.n_comp_samples > previous(state.n_comp_samples))
	  			   		THEN IF (previous(state.meas_C_comp) < parameters.detection_limit)
				   			 THEN parameters.detection_limit / 2
							 ELSE (previous(state.meas_C_comp) * (previous(state.n_samples_bottle_temp)) + interface.y_M) / (previous(state.n_samples_bottle_temp) + 1)
				   		ELSE previous(state.meas_C)
				   ELSE 0;
			   
	  state.t1 = IF (state.flag_samp_per == True)
	  	  	  			      THEN IF (state.n_comp_samples > previous(state.n_comp_samples))
	  	  	  			   		   THEN previous(state.t2)
	  	  				   		   ELSE previous(state.t1)
	  				              ELSE parameters.t_start;
	  	  
	  state.t2 = IF (state.flag_samp_per == True)
	  	  	  	  		      THEN IF (state.n_comp_samples > previous(state.n_comp_samples))
	  	  	  	  			   		   THEN independent.t
	  	  	  				   		   ELSE previous(state.t2)
	  				              ELSE parameters.t_start;
	  				   
	  state.meas_L = IF ((state.t2 - state.t1) > 0)
	  	  		 THEN state.meas_C * parameters.V_sample * state.n_samples_bottle_temp / (state.t2 - state.t1)
	  	  		 ELSE 0;

    };
 :};


# 46 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.evaluator.msl" 1
 


















CLASS OperationalCost
  (* icon = "cost" ; is_default = "true" *)
  "Calculation of the operational cost of the plant"

 
 
 
 
 
 
 
 
 
 
 

  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
   
    OBJ AerationEnergy1 (* terminal = "in_1" *) "AerationEnergy unit 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy2 (* terminal = "in_1" *) "AerationEnergy unit 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy3 (* terminal = "in_1" *) "AerationEnergy unit 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy4 (* terminal = "in_1" *) "AerationEnergy unit 4" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy5 (* terminal = "in_1" *) "AerationEnergy unit 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy6 (* terminal = "in_1" *) "AerationEnergy unit 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy7 (* terminal = "in_1" *) "AerationEnergy unit 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy8 (* terminal = "in_1" *) "AerationEnergy unit 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy9 (* terminal = "in_1" *) "AerationEnergy unit 9" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
    OBJ AerationEnergy10 (* terminal = "in_1" *) "AerationEnergy unit 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Aeration" :};
   
   
    OBJ PumpingEnergy1 (* terminal = "in_1" *) "PumpingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy2 (* terminal = "in_1" *) "PumpingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy3 (* terminal = "in_1" *) "PumpingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy4 (* terminal = "in_1" *) "PumpingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy5 (* terminal = "in_1" *) "PumpingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy6 (* terminal = "in_1" *) "PumpingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy7 (* terminal = "in_1" *) "PumpingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy8 (* terminal = "in_1" *) "PumpingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy9 (* terminal = "in_1" *) "PumpingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy10 (* terminal = "in_1" *) "PumpingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy11 (* terminal = "in_1" *) "PumpingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy12 (* terminal = "in_1" *) "PumpingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy13 (* terminal = "in_1" *) "PumpingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy14 (* terminal = "in_1" *) "PumpingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy15 (* terminal = "in_1" *) "PumpingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy16 (* terminal = "in_1" *) "PumpingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy17 (* terminal = "in_1" *) "PumpingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy18 (* terminal = "in_1" *) "PumpingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy19 (* terminal = "in_1" *) "PumpingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Pumping" :};
    OBJ PumpingEnergy20 (* terminal = "in_1" *) "PumpingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Pumping" :};
   
   
    OBJ MixingEnergy1 (* terminal = "in_1" *) "MixingEnergy 1" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy2 (* terminal = "in_1" *) "MixingEnergy 2" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy3 (* terminal = "in_1" *) "MixingEnergy 3" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy4 (* terminal = "in_1" *) "MixingEnergy 4" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy5 (* terminal = "in_1" *) "MixingEnergy 5" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy6 (* terminal = "in_1" *) "MixingEnergy 6" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy7 (* terminal = "in_1" *) "MixingEnergy 7" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy8 (* terminal = "in_1" *) "MixingEnergy 8" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy9 (* terminal = "in_1" *) "MixingEnergy 9" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy10 (* terminal = "in_1" *) "MixingEnergy 10" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy11 (* terminal = "in_1" *) "MixingEnergy 11" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy12 (* terminal = "in_1" *) "MixingEnergy 12" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy13 (* terminal = "in_1" *) "MixingEnergy 13" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy14 (* terminal = "in_1" *) "MixingEnergy 14" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy15 (* terminal = "in_1" *) "MixingEnergy 15" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy16 (* terminal = "in_1" *) "MixingEnergy 16" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy17 (* terminal = "in_1" *) "MixingEnergy 17" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy18 (* terminal = "in_1" *) "MixingEnergy 18" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy19 (* terminal = "in_1" *) "MixingEnergy 19" : ElectricalEnergy:= {: causality <- "CIN" ; group <- "Mixing" :};
    OBJ MixingEnergy20 (* terminal = "in_1" *) "MixingEnergy 20" : ElectricalEnergy := {: causality <- "CIN" ; group <- "Mixing" :};
   
   
    OBJ TSS1 (* terminal = "in_1" *) "TSS1" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 1" :};
    OBJ TSS2 (* terminal = "in_1" *) "TSS2" : Concentration := {: causality <- "CIN" ; group <- "TSS concentration in the wastage flow 2" :};
    OBJ Q_Pump_Waste1 (* terminal = "in_1" *) "Q_Pump sludge wastage 1" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
    OBJ Q_Pump_Waste2 (* terminal = "in_1" *) "Q_Pump sludge wastage 2" : FlowRate := {: causality <- "CIN" ; group <- "Measurement data" :};
   
   
    OBJ Q1_COD (* terminal = "in_1" *) "External COD dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q1_MeOH (* terminal = "in_1" *) "Metal dosed (unit 1)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_COD (* terminal = "in_1" *) "External COD dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q2_MeOH (* terminal = "in_1" *) "Metal dosed (unit 2)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_COD (* terminal = "in_1" *) "External COD dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    OBJ Q3_MeOH (* terminal = "in_1" *) "Metal dosed (unit 3)" : FlowRate := {: causality <- "CIN" ; group <- "Chemicals" :};
    };

    parameters <-
    {
    OBJ F_AC "Aeration cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_PC "Pumping cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_MC "Mixing cost factor (Euro/kW)" : Ratio := {: value <- 0.07 ; group <- "Cost" :};
    OBJ F_SC "Sludge cost factor (Euro/kg)" : Ratio := {: value <- 0.58 ; group <- "Cost" :};
  OBJ C1_COD "COD cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C1_MeOH "Metal hydroxide cost factor (unit 1) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_COD "COD cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C2_MeOH "Metal hydroxide cost factor (unit 2) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_COD "COD cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ C3_MeOH "Metal hydroxide cost factor (unit 3) (Euro/m3)" : Ratio := {: value <- 0.5 ; group <- "Chemicals" :};
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
    };

    independent <- 
    { 
    OBJ t "Time" : Time := {: group <- "Time" :}; 
    };

    state <-
    {
   
    OBJ TotalAerationEnergy "Aeration energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalPumpingEnergy "Pumping energy" : ElectricalEnergy := {: group <- "Energy" :};
   
    OBJ TotalMixingEnergy "Mixing energy" : ElectricalEnergy := {: group <- "Energy" :};
   
 
    OBJ SludgeProduction "Sludge production" : Mass := {: group <- "Sludge" :};
    OBJ Integ_SP (* hidden = "1" *)"Integral sludge production" : Mass ;
   
  OBJ CODdosed "External COD dosed" : Volume := {: group <- "Chemicals" :};
  OBJ MeOHdosed "Metal hydroxide dosed" : Volume := {: group <- "Chemicals" :};
    OBJ Integ_COD (* hidden = "1" *) "Integral ext.COD addition" : Volume ;
    OBJ Integ_MeOH (* hidden = "1" *) "Integral MeOH addition" : Volume ;
    OBJ Integ_ChemicalCost (* hidden = "1" *) "Integral cost of chemicals" : Euro ;
   
    OBJ AerationCost "Aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PumpingCost "Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MixingCost "Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SludgeCost "Sludge cost" : Euro := {: group <- "Cost" :};
    OBJ ChemicalCost "Cost of chemicals" : Euro := {: group <- "Chemicals" :};
    OBJ TotalCost "Total cost" : Euro := {: group <- "Cost" :};
    OBJ Prev_t (* hidden = "1" *) "Help variable for time" : Time ;
    OBJ Prev_TotalAerationEnergy (* hidden = "1" *) "Help variable to calculate the Periodical aeration cost" : ElectricalEnergy ;
    OBJ Prev_TotalPumpingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical pumping cost" : ElectricalEnergy ;
    OBJ Prev_TotalMixingEnergy (* hidden = "1" *) "Help variable to calculate the Periodical mixing cost" : ElectricalEnergy ;
    OBJ Prev_Integ_SP (* hidden = "1" *) "Help variable to calculate the Periodical sludge cost" : Mass ;
    OBJ Prev_Integ_ChemicalCost (* hidden = "1" *) "Help variable to calculate the Periodical chemical cost (carbon addition)" : Euro ;
    OBJ AC_Period "Periodical aeration cost" : Euro := {: group <- "Cost" :};
    OBJ PC_Period "Periodical Pumping cost" : Euro := {: group <- "Cost" :};
    OBJ MC_Period "Periodical Mixing cost" : Euro := {: group <- "Cost" :};
    OBJ SC_Period "Periodical sludge cost" : Euro := {: group <- "Cost" :};
    OBJ CC_Period "Periodical cost of COD addition" : Euro := {: group <- "Cost" :};
    OBJ TC_Period "Periodical total cost" : Euro := {: group <- "Cost" :};
    };

    equations <-
    {
   
   
  state.TotalAerationEnergy = interface.AerationEnergy1 + interface.AerationEnergy2 + interface.AerationEnergy3
                    + interface.AerationEnergy4 + interface.AerationEnergy5+ interface.AerationEnergy6 
                + interface.AerationEnergy7 + interface.AerationEnergy8 + interface.AerationEnergy9 
                + interface.AerationEnergy10;
   
   
   
   
   
  state.TotalPumpingEnergy = interface.PumpingEnergy1 + interface.PumpingEnergy2 + interface.PumpingEnergy3 + interface.PumpingEnergy4 
                 + interface.PumpingEnergy5 + interface.PumpingEnergy6  + interface.PumpingEnergy7 + interface.PumpingEnergy8 
                 + interface.PumpingEnergy9 + interface.PumpingEnergy10 + interface.PumpingEnergy11 + interface.PumpingEnergy12 
                 + interface.PumpingEnergy13 + interface.PumpingEnergy14 + interface.PumpingEnergy15+ interface.PumpingEnergy16 
                 + interface.PumpingEnergy17 + interface.PumpingEnergy18 + interface.PumpingEnergy19 + interface.PumpingEnergy20;
   
   
  state.TotalMixingEnergy = interface.MixingEnergy1 + interface.MixingEnergy2 + interface.MixingEnergy3 + interface.MixingEnergy4 
                + interface.MixingEnergy5 + interface.MixingEnergy6 + interface.MixingEnergy7 + interface.MixingEnergy8 
                + interface.MixingEnergy9 + interface.MixingEnergy10 + interface.MixingEnergy11 + interface.MixingEnergy12 
                + interface.MixingEnergy13 + interface.MixingEnergy14 + interface.MixingEnergy15+ interface.MixingEnergy16 
                + interface.MixingEnergy17 + interface.MixingEnergy18 + interface.MixingEnergy19 + interface.MixingEnergy20;
   
   
  DERIV(state.Integ_SP,[independent.t])= interface.TSS1 * interface.Q_Pump_Waste1 + interface.TSS2 * interface.Q_Pump_Waste2;
  state.SludgeProduction = state.Integ_SP ;
   
   
  DERIV(state.Integ_COD,[independent.t]) = interface.Q1_COD + interface.Q2_COD + interface.Q3_COD;
  DERIV(state.Integ_MeOH,[independent.t]) = interface.Q1_MeOH + interface.Q2_MeOH + interface.Q3_MeOH;
  state.CODdosed = state.Integ_COD;
  state.MeOHdosed = state.Integ_MeOH;
   
   
   
  state.AerationCost = state.TotalAerationEnergy * parameters.F_AC;
  state.PumpingCost = state.TotalPumpingEnergy * parameters.F_PC;
  state.SludgeCost = state.SludgeProduction * parameters.F_SC / 1000.0;
  state.MixingCost = state.TotalMixingEnergy * parameters.F_MC;
  DERIV(state.Integ_ChemicalCost,[independent.t]) =
      interface.Q1_COD * parameters.C1_COD + interface.Q2_COD  * parameters.C2_COD
      + interface.Q3_COD * parameters.C3_COD + interface.Q1_MeOH * parameters.C1_MeOH
      + interface.Q2_MeOH * parameters.C2_MeOH + interface.Q3_MeOH * parameters.C3_MeOH ;
  state.ChemicalCost = state.Integ_ChemicalCost;
  state.TotalCost = state.AerationCost + state.PumpingCost + state.SludgeCost + state.MixingCost + state.ChemicalCost;
   
    state.Prev_t =  IF (independent.t < previous(state.Prev_t))
          THEN 0
          ELSE
            IF  (independent.t - previous(state.Prev_t) < parameters.Period)
            THEN  previous(state.Prev_t)
            ELSE  independent.t;
  state.Prev_TotalAerationEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
              THEN previous(state.Prev_TotalAerationEnergy)
              ELSE state.TotalAerationEnergy;
  state.Prev_TotalPumpingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalPumpingEnergy)
                ELSE state.TotalPumpingEnergy;
  state.Prev_TotalMixingEnergy = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_TotalMixingEnergy)
                ELSE state.TotalMixingEnergy;
  state.Prev_Integ_SP = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Prev_Integ_SP)
                ELSE state.Integ_SP;
  state.Prev_Integ_ChemicalCost = IF (independent.t < previous(state.Prev_t))
                THEN 0
                ELSE
                IF (independent.t - previous(state.Prev_t) < parameters.Period)
                THEN previous(state.Integ_ChemicalCost)
                ELSE state.Integ_ChemicalCost;
     
  state.AC_Period = parameters.F_AC * (state.TotalAerationEnergy - state.Prev_TotalAerationEnergy);
  state.PC_Period = parameters.F_PC * (state.TotalPumpingEnergy - state.Prev_TotalPumpingEnergy);
  state.MC_Period = parameters.F_MC * (state.TotalMixingEnergy - state.Prev_TotalMixingEnergy);
  state.SC_Period = parameters.F_SC * (state.Integ_SP - state.Prev_Integ_SP) / 1000.0 ;
  state.CC_Period = state.Integ_ChemicalCost - state.Prev_Integ_ChemicalCost;
  state.TC_Period = state.AC_Period + state.PC_Period + state.SC_Period + state.CC_Period + state.MC_Period;
    };
  :};

  
  

# 47 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 1
 


















 CLASS DosingUnit
 "A dosing unit model"
 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-
  {
   
   
   
  OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  OBJ Q_Dose (* terminal = "in_1"; manip = "1" *) "Flowrate of the solution" : 
      FlowRate := {: causality <- "CIN"; value <- 10 ; group <- "Operational" :};
   OBJ PumpingEnergy (* terminal = "out_2" *)"Pumping energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
  };

  parameters <-
  {
   
    
  OBJ C_Dose "Concentration of the solution" : 
       Concentration := {: value <- 1 ; group <- "Concentration" :};
  OBJ MW (* hidden = "1" *) "Molecular weight of the chemical species dosed"
        : Real := {: group <- "System" :};
 
    OBJ F_Energy_FlowRate "Conversion factor Energy needed/Pump flow rate" : Ratio := {: value <- 0.04 ; group <- "Energy":};
  };

  independent <-
  {
  OBJ t "Time": Time := {: group <- "Time" :};
  };

  state <-
  {
 
    OBJ Integ_PE (* hidden = "1" *)"Integral Pumping energy" : ElectricalEnergy ;
  };
  initial <-
  {
  
  };

  equations <-
  {
  interface.Outflow[IndexOfSolvent] = - interface.Q_Dose
      / 0.000001;

 
  DERIV(state.Integ_PE,[independent.t])=  interface.Q_Dose;
  interface.PumpingEnergy = parameters.F_Energy_FlowRate * state.Integ_PE ;
  };

 :};


 CLASS AdditionOfFermentationProducts
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {




    

   interface.Outflow[S_A] = - interface.Q_Dose * parameters.C_Dose *
      (parameters.COD / parameters.MW) ;

  };
	 
	 :};
	 


 CLASS AdditionOfCOD
	 (* icon = "dosing_unit_acetate" *)
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
	 OBJ f_S_A (* hidden = "0" *) "COD fraction of S_A"
        : Fraction := {: value <- 0.5 ; group <- "System" :};
	 OBJ f_S_F (* hidden = "0" *) "COD fraction of S_F"
        : Fraction := {: value <- 0.25 ; group <- "System" :};
	 OBJ f_X_S (* hidden = "0" *) "COD fraction of X_S"
        : Fraction := {: value <- 0.25 ; group <- "System" :};
  };
	 
	   initial <-
  {
   parameters.f_X_S = 1 - parameters.f_S_A - parameters.f_S_F;
  };

  equations <-
  {




    

   interface.Outflow[S_A] = - interface.Q_Dose * parameters.C_Dose *
      parameters.f_S_A ;
	 interface.Outflow[S_F] = - interface.Q_Dose * parameters.C_Dose *
      parameters.f_S_F ;

	 
	 interface.Outflow[X_S] = - interface.Q_Dose * parameters.C_Dose *
      parameters.f_X_S ;
  };

:};



 CLASS AdditionOfFermentableCOD
 "A dosing unit model for the addition of external source of carbon"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ COD (* hidden = "1" *) "COD equivalent of the chemical dosed"
        : Real := {: group <- "System" :};
  };

  equations <-
  {




    

   interface.Outflow[S_F] = - interface.Q_Dose * parameters.C_Dose *
      (parameters.COD / parameters.MW) ;

  };

:};



 CLASS P_Precipitation
 "A dosing unit model for the chemical precipitation of P"
 EXTENDS DosingUnit WITH
 {:

  parameters <-
  {
   OBJ MW_FeOH (* hidden = "1" *) "Molecular weight of Ferric Hydroxyde"
        : Real := {: value <- 106.85 ; group <- "System" :};
   OBJ Equiv_P "Molar equivalence to phosphorous"
        : Fraction := {: group <- "Operational" :};
  };

  equations <-
  {
   interface.Outflow[X_MEOH] = - interface.Q_Dose * parameters.C_Dose *
      parameters.Equiv_P * (parameters.MW/parameters.MW_FeOH) ;
  };

:};


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\dosing_unit/wwtp.base.dosing_units.acetate.msl" 1
 














 




 CLASS Acetate
 (* icon = "dosing_unit_acetate"; is_default = "true" *)
 "A simple model for dosage of acetate"
 EXTENDS AdditionOfFermentationProducts WITH
 {:
  comments <- "A model for the addition of acetate as external carbon source";
  
  interface <-
  {
  OBJ M_Acetate (* terminal = "out_2" *) "Amount of acetate dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Acetate (* terminal = "out_2" *) "Flow rate of acetate dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  



  };
  
  initial <-
  {
  parameters.COD = 64;
  parameters.MW = 60;
  };

  equations <-
  {
  


   
  interface.M_Acetate = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Acetate = interface.Q_Dose ;
  };

:};


 


# 198 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\dosing_unit/wwtp.base.dosing_units.methanol.msl" 1
 



















 CLASS Methanol
 (* icon = "dosing_unit_methanol" *)
 "A simple model for dosage of methanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of methanol as external carbon source";

  interface <-
  {
  OBJ M_Methanol (* terminal = "out_2" *) "Amount of methanol dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Methanol (* terminal = "out_2" *) "Flow rate of methanol dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  initial <-
  {
  parameters.COD = 48;
  parameters.MW = 32;
  };

  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  equations <-
  {

  state.Help_SF = - interface.Q_Dose * parameters.C_Dose * (parameters.COD / parameters.MW);
  interface.Outflow[S_NH] = - parameters.i_N_S_F * state.Help_SF ;
  interface.Outflow[S_PO] = - parameters.i_P_S_F * state.Help_SF ;

   
  interface.M_Methanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Methanol = interface.Q_Dose ;
  };

:};



# 199 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\dosing_unit/wwtp.base.dosing_units.ethanol.msl" 1
 



















 CLASS Ethanol
 (* icon = "dosing_unit_ethanol" *)
 "A simple model for dosage of ethanol"
 EXTENDS AdditionOfFermentableCOD WITH
 {:
  comments <- "A model for the addition of ethanol as external carbon source";

  interface <-
  {
  OBJ M_Ethanol (* terminal = "out_2" *) "Amount of ethanol dosed" : MassFlux
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Ethanol (* terminal = "out_2" *) "Flow rate of ethanol dosed" : FlowRate
  := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  parameters <-
  {
  OBJ i_N_S_F "Nitrogen content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.03 ; group <- "Composition parameters" :};
  OBJ i_P_S_F "Phosphorus content of soluble substrate S_F" : ConversionFactor
      := {: value <- 0.01 ; group <- "Composition parameters" :}; 
  };
  
  state <-
  {
  OBJ Help_SF (* hidden="1" *) "Resulting COD output as S_F, ie for ASM2" : 
       MassFlux := {: group <- "Concentration" :};
  };
  
  initial <-
  {
  parameters.COD = 96;
  parameters.MW = 46;
  };

  equations <-
  {

  state.Help_SF = - interface.Q_Dose * parameters.C_Dose * (parameters.COD / parameters.MW);
  interface.Outflow[S_NH] = - parameters.i_N_S_F * state.Help_SF ;
  interface.Outflow[S_PO] = - parameters.i_P_S_F * state.Help_SF ;

   
  interface.M_Ethanol = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Ethanol = interface.Q_Dose ;
  };

:};




# 200 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\dosing_unit/wwtp.base.dosing_units.alum.msl" 1
 



















 CLASS Alum
 (* icon = "dosing_unit_alum" *)
 "A simple model for dosage of a Al2(SO4)3 solution"
 EXTENDS P_Precipitation WITH
 {:
  comments <- "A model for the addition of alum for chemical precipitation";

  interface <-
  {
  OBJ M_Alum (* terminal = "out_2" *) "Amount of alum dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_Alum (* terminal = "out_2" *) "Flow rate of alum dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  initial <-
  {
   parameters.MW = 342;
   parameters.Equiv_P = 1.0;
  };

  equations <-
  {
  interface.M_Alum = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_Alum = interface.Q_Dose ;
  interface.Outflow[S_Al] = - interface.Q_Dose * parameters.C_Dose ;
  };

:};

CLASS MEChemical 
(* icon = "activated_sludge_unit" *)
"A dosing unit for chemical P removal"

SPECIALISES PhysicalDAEModelType :=

 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   
   };

   parameters <-
   {
   
   OBJ pH	"pH wastewater at chemical dosing point"
	: Real	:= {: value <- 7 ; group <- "Kinetic" :}; 
   
    
   	
	OBJ pKa1_P	"pKa1 H3PO4/H2PO4" : Real	:= {: value <- 2.05 ; group <- "Kinetic" :}; 
	OBJ pKa2_P	"pKa2 H2PO4/HPO4" : Real	:= {: value <- 7.07 ; group <- "Kinetic" :}; 
	OBJ pKa3_P	"pKa3 HPO4/PO4" : Real	:= {: value <- 12.07 ; group <- "Kinetic" :}; 
	OBJ pKa1_Al	"pKa1  Al/AlOH"	: Real	:= {: value <- 5.23 ; group <- "Kinetic" :}; 
	OBJ pKa2_Al	"pKa2 AlOH/Al(OH)2"	: Real	:= {: value <- 9.06 ; group <- "Kinetic" :}; 
	OBJ pKa3_Al	"pKa3 Al(OH)2/Al(OH)3" : Real	:= {: value <- 15.61 ; group <- "Kinetic" :}; 
	OBJ pKa4_Al	"pKa4 Al(OH)3/Al(OH)4" : Real	:= {: value <- 23.66 ; group <- "Kinetic" :}; 
	OBJ pKs_AlPO4	"pKs AlPO4"	: Real	:= {: value <- 22 ; group <- "Kinetic" :}; 
	OBJ pKs_AlOH3	"pKs AlOH3"	: Real	:= {: value <- 32.3 ; group <- "Kinetic" :}; 
	OBJ pK_AlH2PO4	"" : Real	:= {: value <- -5.72 ; group <- "Kinetic" :}; 
	OBJ MW_P	"Molecular weight phosphorus" : Real	:= {: value <- 31 ; group <- "Kinetic" :}; 
	OBJ MW_Al	"Molecular weight Alum"	: Real	:= {: value <- 27 ; group <- "Kinetic" :}; 
	OBJ MW_OH "Molecular weight hydroxide" : Real	:= {: value <- 17 ; group <- "Kinetic" :};
	OBJ MW_H "Molecular weight hydrogen" : Real	:= {: value <- 1 ; group <- "Kinetic" :};  
	OBJ MW_O "Molecular weight oxygen" : Real	:= {: value <- 16 ; group <- "Kinetic" :};  
	OBJ a2	"parameter empirical model"	: Real	:= {: value <- 1.42 ; group <- "Kinetic" :}; 
	OBJ a1	"parameter empirical model"	: Real	:= {: value <- 1.09 ; group <- "Kinetic" :}; 
	OBJ r "formula precipitate Me(r)H(2)P(1)O(4)OH(3r-1)" : Real := {: value <- 1.2 ; group <- "Kinetic" :};    
   };

   independent <- 
   { 
   OBJ t "Time"  : Time := {: group <- "Time" :}; 
    
   
   };

   initial <- 
   { 
   
   state.S_OH := 7;
   };

   state <-
   {
   OBJ Q_In "Influent flow rate" : Real;
   OBJ C_In "Incoming concentrations for all the components" : ConcentrationVector := {: group <- "Concentration" :};
   OBJ S_H	"Molar Concentration H+ ions": Real := {: group <- "Concentration" :};
   OBJ pOH	"pOH"	: Real;
   OBJ S_OH	"Molar Concentration OH- ions"	: Real := {: group <- "Concentration" :};
   OBJ S_PO4	"chemical equilibrium molar concentration PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_HPO4	"chemical equilibrium molar concentration HPO4"	: Real := {: group <- "Concentration" :};
   OBJ S_H2PO4	"chemical equilibrium molar concentration H2PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_H3PO4	"chemical equilibrium molar concentration H3PO4"	: Real := {: group <- "Concentration" :};
   OBJ S_AlChem	"chemical equilibrium molar concentration Al"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH	"chemical equilibrium molar concentration AlOH"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH2	"chemical equilibrium molar concentration AlOH2"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH3	"chemical equilibrium molar concentration AlOH3"	: Real := {: group <- "Concentration" :};
   OBJ S_AlOH4	"chemical equilibrium molar concentration AlOH4"	: Real := {: group <- "Concentration" :};
   OBJ X_AlH2PO4	"chemical equilibrium molar concentration AlH2PO4"	: Real := {: group <- "Concentration" :};
   OBJ TP	"chemical equilibrium PO4-P concentration (sum of all species)"	: Real := {: group <- "Concentration" :};
   OBJ TAl	"chemical equilibrium Al concentration(sum of all species)"	: Real := {: group <- "Concentration" :};
   OBJ RatioBis	"Ratio of mass metal dosed over P in influent"	: Real;
   OBJ TP_emp	"empirical equation PO4-P concentration"	: Real := {: group <- "Concentration" :};
   OBJ TP_limit	"limited PO4-P concentration by Al dosing"	: Real := {: group <- "Concentration" :};
   OBJ Presult_help	"PO4-P concentration after chemical dosing (help)"	: Real;
   OBJ Presult_help2	"PO4-P concentration after chemical dosing (help2)"	: Real;
   OBJ Presult	"PO4-P concentration after chemical dosing"	: Real := {: group <- "Concentration" :};
   OBJ MW_prec	"molecular weight precipitate Me(r)H(2)P(1)O(4)OH(3r-1)" : Real;   
   OBJ RatioPrec "gram Al/gram P in precipitaat" : Real;   
   OBJ Ratio_in "" : Real;
   OBJ Al_actual	"Actual Al concentration in effluent"	: Real := {: group <- "Concentration" :}; 
   };

   equations <-
   {
   state.Q_In = 0.000001 * interface.Inflow[IndexOfSolvent] ;
   
    interface.Outflow[IndexOfSolvent] =
			- interface.Inflow[IndexOfSolvent];
  
  
   {FOREACH Comp_Index IN {S_I .. S_NO}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
  
  {FOREACH Comp_Index IN {S_NH .. S_ALK}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
			
			
  {FOREACH Comp_Index IN {X_I .. X_AUT}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
  
  {FOREACH Comp_Index IN {X_MEOH .. X_MEP}:
			interface.Outflow[Comp_Index] =
			- interface.Inflow[Comp_Index]; };
			
    state.pOH = 14 - parameters.pH;
	state.S_H = pow(10, - parameters.pH);
	state.S_OH = pow(10, - state.pOH);
	state.S_PO4 = pow(10, - parameters.pKs_AlPO4) / pow(10, - parameters.pKs_AlOH3) * pow(state.S_OH,3);
	state.S_HPO4 = state.S_PO4 * state.S_H / pow(10, - parameters.pKa3_P);
	state.S_H2PO4 = state.S_HPO4 * state.S_H / pow(10, - parameters.pKa2_P);
	state.S_H3PO4 = state.S_H2PO4 * state.S_H / pow(10, - parameters.pKa1_P);
	state.S_AlChem = pow(10, - parameters.pKs_AlOH3) / pow(state.S_OH,3);
	state.S_AlOH = pow(10, - parameters.pKa1_Al) * state.S_AlChem / state.S_H;
	state.S_AlOH2 = pow(10, - parameters.pKa2_Al) * state.S_AlOH / state.S_H;
	state.S_AlOH3 = pow(10, - parameters.pKa3_Al) * state.S_AlOH2 / state.S_H;
	state.S_AlOH4 = pow(10, - parameters.pKa4_Al) * state.S_AlOH3 / state.S_H;
	state.X_AlH2PO4 = pow(10, - parameters.pK_AlH2PO4) * state.S_AlChem * state.S_H2PO4;
	state.TP = (state.S_PO4 + state.S_HPO4 + state.S_H2PO4 + state.S_H3PO4 + state.X_AlH2PO4) * parameters.MW_P * 1000;
	state.TAl = (state.S_AlChem + state.S_AlOH + state.S_AlOH2 + state.S_AlOH3 + state.S_AlOH4) * parameters.MW_Al * 1000;
	
	state.Ratio_in = IF (interface.Inflow[S_PO] == 0) 
			THEN 1
				   ELSE interface.Inflow[S_Al] / interface.Inflow[S_PO];
	state.TP_emp = IF (state.Q_In == 0) 
				   THEN 0
				   ELSE parameters.a1 * interface.Inflow[S_PO] / state.Q_In * exp( - parameters.a2 * state.Ratio_in);
	state.TP_limit = IF (state.Q_In == 0) 
				     THEN 0
				     ELSE(interface.Inflow[S_PO]/state.Q_In)- (interface.Inflow[S_Al]/(state.Q_In*state.RatioPrec));

  {FOREACH Comp_Index IN {1 .. NrOfComponents}:
	state.C_In[Comp_Index] = IF (state.Q_In == 0) 
				             THEN 0
				             ELSE interface.Inflow[Comp_Index]/state.Q_In;
   };
	
	
 
 
	state.Presult_help = max(state.TP_limit,state.TP_emp);
	state.Presult_help2 = max(state.TP,state.Presult_help);
	state.Presult = min(state.C_In[S_PO],state.Presult_help2);  
	
	interface.Outflow[S_PO]=-state.Presult*state.Q_In;
    
	state.MW_prec = parameters.r * parameters.MW_Al+2*parameters.MW_H+parameters.MW_P+4*parameters.MW_O+(3*parameters.r-1)*parameters.MW_OH;
	state.RatioPrec=parameters.r * parameters.MW_Al/parameters.MW_P;
	
	interface.Outflow[X_I_i]=-interface.Inflow[X_I_i]-state.MW_prec/parameters.MW_P*(interface.Inflow[S_PO]+interface.Outflow[S_PO]);
	
	interface.Outflow[S_Al]=  -interface.Inflow[S_Al]+state.RatioPrec*(interface.Inflow[S_PO]+interface.Outflow[S_PO]) ;
	
	state.Al_actual = IF (state.Q_In == 0) 
				   THEN 0
				   ELSE - interface.Outflow[S_Al]/state.Q_In ;
	
	 



	interface.Outflow[X_TSS]=-interface.Inflow[X_TSS]-state.MW_prec/parameters.MW_P*(interface.Inflow[S_PO]+interface.Outflow[S_PO]);  
 

   };

 :};




# 201 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\dosing_unit/wwtp.base.dosing_units.ironhydroxide.msl" 1
 



















 CLASS IronHydroxide
 (* icon = "dosing_unit_iron" *)
 "A simple model for dosage of a Fe(OH)3 solution"
 EXTENDS P_Precipitation WITH
 {:
  comments <- "A model for the addition of iron hydroxide for chemical precipitation";

  interface <-
  {
  OBJ M_FeOH (* terminal = "out_2" *) "Amount of iron hydroxyde dosed" : MassFlux
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  OBJ Q_FeOH (* terminal = "out_2" *) "Flow rate of iron hydroxyde dosed" : FlowRate
      := {: causality <- "COUT" ; group <- "Measurement data" :};
  };

  initial <-
  {
   parameters.MW = 106.85;
   parameters.Equiv_P = 1.0;
  };

  equations <-
  {
  interface.M_FeOH = interface.Q_Dose * parameters.C_Dose ;
  interface.Q_FeOH = interface.Q_Dose ;
  };

:};



# 202 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.dosing_units.msl" 2



# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sludge_dewatering.msl" 1
 


















CLASS SolidSeparationModel EXTENDS WWTPAtomicModelWithoutVolume WITH
 {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ OutflowPermeate (* terminal = "out_1" *) "Permeate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
   OBJ OutflowConcentrate (* terminal = "out_3" *) "Concentrate flow" : OutWWTPTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
    
   };

   parameters <-
   { 
   OBJ rho_sludge "Specific gravity of dewatered sludge" : Concentration := {: value <- 1.07e6 ; group <- "Operational" :};
    
   OBJ F_TSS_COD "Fraction TSS/COD" : Fraction := {: value <- 0.75 ; group <- "Conversion factors" :};
    
   };

   state <-
   {
   OBJ Q_Permeate "Effluent flow rate" : FlowRate := {: group <- "Operational" :};
   OBJ Q_Concentrate_Actual "Concentrate flow rate" : FlowRate := {: group <- "Operational" :};
    
   OBJ Help_X_Sludge (* hidden = "1" *) "Working variable to calculate TSS in the concentrate" : MassFlux;
   OBJ f_Out (* hidden = "1" *) "Fraction of the influent flux going to the outflow" : Fraction ;
   };

   equations <-
   {
    
   



    
    
   
   state.Help_X_Sludge = (- interface.OutflowConcentrate[IndexOfTSSComponent]) ;
   
   };

 :};

 
 
 
CLASS EfficiencyDewateringModel
 "efficiency-based dewatering"
 EXTENDS SolidSeparationModel WITH
 {:

  interface <-
  {
  OBJ DS (* terminal = "out_2" *) "Dry solids" : Real := {: causality <- "COUT" ; group <- "Measurement" :};
  OBJ e_X (* terminal = "in_2"; manip = "1" *) "Separation efficiency (fraction of solids going to sludge flow)" :
    Fraction := {: causality <- "CIN" ; value <- 0.96; group <- "Operational" :}; 
  OBJ Q_Concentrate (* terminal = "in_2"; manip = "1" *) "Desired flow rate of the concentrated sludge" :
    FlowRate := {: causality <- "CIN" ; value <- 10 ; group <- "Operational" :};
  };

  parameters <-
  { 
  };
 
  state <-
  {
  OBJ DrySolids "Dry solid content (of the cake)" : Real := {: group <- "Operational" :};
  };
  
  equations <-
  {
   
   
   
   
   
   
   
   
   
  state.DrySolids = IF (state.Q_Concentrate_Actual == 0.0)
              THEN 0.0
            ELSE 100.0 * (state.Help_X_Sludge / (state.Q_Concentrate_Actual * parameters.rho_sludge));
   
   
  state.Q_Concentrate_Actual = IF (state.Q_In <= interface.Q_Concentrate)
                     THEN state.Q_In
                     ELSE interface.Q_Concentrate;
   
  state.Q_Permeate = state.Q_In - state.Q_Concentrate_Actual;
   
   
   
  state.f_Out = IF (state.Q_In <= interface.Q_Concentrate)
            THEN 0
            ELSE (state.Q_In - interface.Q_Concentrate) / state.Q_In ;
   
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowPermeate[Comp_Index] =
      - state.InFluxPerComponent[Comp_Index] * state.f_Out;
  };
   
  {FOREACH Comp_Index IN {IndexOfSolvent .. IndexOfLastSolubleComponent}:
   interface.OutflowConcentrate[Comp_Index] =
         - state.InFluxPerComponent[Comp_Index] * (1 - state.f_Out);
  };
   
   
   
   
   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowPermeate[Comp_Index] = IF (state.Q_Concentrate_Actual == 0.0)
                         THEN - state.InFluxPerComponent[Comp_Index]
                       ELSE - state.InFluxPerComponent[Comp_Index] * (1-interface.e_X);
  };   
   
  {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. IndexOfLastParticulateComponent}:
   interface.OutflowConcentrate[Comp_Index] = - state.InFluxPerComponent[Comp_Index] * interface.e_X;
  };
   
  interface.DS = state.DrySolids ;
  }; 
 
 :};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencythickener.msl" 1
 


















CLASS EfficiencyThickener
  (* icon = "dewatering_unit"; is_default = "true" *)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge thickener based on dewatering efficiency";
  :};


# 149 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencycentrifuge.msl" 1
 


















CLASS EfficiencyCentrifuge
  (* icon = "centrifuge"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 150 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sludge_dewatering.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sludge_dewatering/wwtp.base.sludge_dewatering.efficiencybeltpress.msl" 1
 


















CLASS EfficiencyBeltPress
  (* icon = "beltpress"; is_default = "true"*)
  "efficiency-based dewatering"
  EXTENDS EfficiencyDewateringModel WITH
  {:
  comments <- "A basic solids separation model for a sludge centrifuge based on dewatering efficiency";
  :};


# 151 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.sludge_dewatering.msl" 2





# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 1
 














 





 CLASS AtomicBiofilm "The base equations for the Biofilm"
     SPECIALISES PhysicalDAEModelType :=
   {:
   
   interface <-
   { 
   OBJ Inflow (* terminal = "in_1" *) "Inflow" : InWWTPTerminal
       := {: causality <- "CIN" ; group <- "Influent":};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutWWTPTerminal
       := {: causality <- "COUT" ; group <- "Effluent":};
   };
   
   parameters <- 
   {  
   OBJ Stoichiometry (* hidden = "1" *) "stoichiometry of the reactions" :
         PhysicalQuantityType[NrOfReactions;][NrOfComponents;];
   };

   independent <-
   {
   OBJ t "Time": Time := {: group <- "Time" :};
   };

   state <-
   {  
   OBJ Kla_Actual "Gas transfer coefficient" : OxygenTransferCoefficient := {: group <- "Operational" :};     
   OBJ Temp_Actual "Actual temperature of the activated sludge" : CelsiusTemperature  := {: group <- "Operational" :}; 
   OBJ Kinetics_Biofilm (* hidden = "1" *) "Kinetics of the biological processes within the biofilm" :
          Rate[NrOfReactions;][NrOfLayers;];
   OBJ Kinetics (* hidden = "1" *) "Kinetics of the biological processes in the bulk liquid" :
          Rate[NrOfReactions;];
   OBJ ConversionTermPerComponent (* hidden = "1" *) "Reaction term in the bulk liquid phase" : Rate[NrOfComponents;];   
    
   OBJ C_Biofilm "Concentration of each component per biofilm layer" : LayerConcentrationMatrix
          := {: group <- "Concentration" :};
   OBJ M_Biofilm "Mass of each component per biofilm layer" : Mass[NrOfComponents;][NrOfLayers;]








   :=[{: value <- 4500 :}, {: value <- 0.01 :}, {: value <- 0.01 :},{: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 0.01 :} ,
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 0.01 :} ,
   {: value <- 0.01 :}, 
   {: value <- 0.01 :}, {: value <- 0.01 :}, {: value <- 1000 :},
   {: value <- 100 :}, {: value <- 0.01 :}, {: value <- 0.01 :},
   {: value <- 100 :}, {: value <- 1100 :}, {: value <- 0.01 :},
   {: value <- 0.01 :}, {: value <- 0.01 :}; ]
















;
   OBJ C "Concentration of each component in the bulk liquid": ConcentrationVector
          := {: group <- "Concentration" :};     
   OBJ V "Volume of the bulk liquid phase" : Volume:= {: group <- "Operational" :};
   };
 
   :};

 CLASS AtomicConversionBiofilm EXTENDS AtomicBiofilm WITH
   {:
    
   
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 1
 
















  interface <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.interface.msl" 1
 
 
 
 
 


	OBJ DO (* terminal = "out_2" *) "Dissolved oxygen concentration measurement"
	: DissolvedOxygen := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NH4 (* terminal = "out_2" *) "Ammonium concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NO3 (* terminal = "out_2" *) "Nitrate+Nitrite concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ TSS (* terminal = "out_2" *) "Total suspended solids concentration"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineCOD (* terminal = "out_2" *) "Chemical Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineBOD (* terminal = "out_2" *) "Biological Oxygen Demand measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTN (* terminal = "out_2" *) "Total nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OfflineTKN (* terminal = "out_2" *) "Total Kjeldal nitrogen concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OnlineTP (* terminal = "out_2" *) "Total phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PO4 (* terminal = "out_2" *) "Phosphorous concentration measurement"
	: Concentration := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ V_ASU (* terminal = "out_2" *) "Volume measurement data"
	: Volume := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ OUR_ASU (* terminal = "out_2" *) "OUR measurement data"
	: OxygenUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NUR (* terminal = "out_2" *) "Nitrate Uptake Rate measurement data"
	: NitrateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ NPR (* terminal = "out_2" *) "Nitrate Production Rate measurement data"
	: NitrateProductionRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ AUR (* terminal = "out_2" *) "Ammonium Uptake Rate measurement data"
	: AmmoniumUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ PUR (* terminal = "out_2" *) "Phosphate Uptake Rate measurement data"
	: PhosphateUptakeRate := {: causality <- "COUT" ; group <- "Measurement data" :}; 
	OBJ Kla_ASU (* terminal = "out_2" *) "Kla measurement data"
	: OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Measurement data" :}; 

# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  parameters <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.parameters.msl" 1
 
 
 
 
 


  OBJ DOsat	"DO at saturation"
	: Concentration	:= {: value <- 11 ; group <- "Kinetic" :};
	OBJ Temp_Ref	"Reference temperature of the activated sludge"
	: CelsiusTemperature	:= {: value <- 20 ; group <- "Kinetic" :}; 
	OBJ theta_k_h	"Temperature correction factor for k_h"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_K_X	"Temperature correction factor for K_X"
	: Real	:= {: value <- 0.896 ; group <- "Kinetic" :}; 
	OBJ theta_mu_H	"Temperature correction factor for mu_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_fe	"Temperature correction factor for Q_fe"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_H	"Temperature correction factor for b_H"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PHA	"Temperature correction factor for Q_PHA"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_Q_PP	"Temperature correction factor for Q_PP"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_mu_PAO	"Temperature correction factor for mu_PAO"
	: Real	:= {: value <- 1.041 ; group <- "Kinetic" :}; 
	OBJ theta_b_PAO	"Temperature correction factor for b_PAO"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PP	"Temperature correction factor for b_PP"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_b_PHA	"Temperature correction factor for b_PHA"
	: Real	:= {: value <- 1.072 ; group <- "Kinetic" :}; 
	OBJ theta_mu_AUT	"Temperature correction factor for mu_AUT"
	: Real	:= {: value <- 1.111 ; group <- "Kinetic" :}; 
	OBJ theta_b_AUT	"Temperature correction factor for b_AUT"
	: Real	:= {: value <- 1.116 ; group <- "Kinetic" :}; 
	OBJ i_N_S_I	"Nitrogen content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_N_S_F	"Nitrogen content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.03 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_I	"Nitrogen content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_N_X_S	"Nitrogen content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.04 ; group <- "Composition parameters" :}; 
	OBJ i_N_BM	"Nitrogen content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.07 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_I	"Phosphorus content of inert soluble COD S_I"
	: ConversionFactor	:= {: value <- 0 ; group <- "Composition parameters" :}; 
	OBJ i_P_S_F	"Phosphorus content of soluble substrate S_F"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_I	"Phosphorus content of inert particulate COD X_I"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_X_S	"Phosphorus content of particulate substrate X_S"
	: ConversionFactor	:= {: value <- 0.01 ; group <- "Composition parameters" :}; 
	OBJ i_P_BM	"Phosphorus content of biomass X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.02 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_I	"TSS to X_I ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_X_S	"TSS to X_S ratio"
	: ConversionFactor	:= {: value <- 0.75 ; group <- "Composition parameters" :}; 
	OBJ i_TSS_BM	"TSS to biomass ratio for X_H, X_PAO, X_AUT"
	: ConversionFactor	:= {: value <- 0.9 ; group <- "Composition parameters" :}; 
	OBJ f_S_I	"Fraction of inert COD in particulate substrate"
	: Fraction	:= {: value <- 0 ; group <- "Stoichiometry" :}; 
	OBJ Y_H	"Yield For Heterotrophic Biomass"
	: YieldForHeterotrophicBiomass	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ f_X_I	"Fraction of inert COD generated in biomass lysis"
	: Fraction	:= {: value <- 0.1 ; group <- "Stoichiometry" :}; 
	OBJ Y_PAO	"Yield coeff (biomass/PHA)"
	: Yield	:= {: value <- 0.625 ; group <- "Stoichiometry" :}; 
	OBJ Y_PO	"PP requirement (S_PO4 release) per PHA stored"
	: Yield	:= {: value <- 0.4 ; group <- "Stoichiometry" :}; 
	OBJ Y_PHA	"PHA requirement for PP storage"
	: Yield	:= {: value <- 0.2 ; group <- "Stoichiometry" :}; 
	OBJ Y_AUT	"Yield For Autotrophic Biomass"
	: YieldForAutotrophicBiomass	:= {: value <- 0.24 ; group <- "Stoichiometry" :}; 
	OBJ k_h	"Hydrolysis rate constant"
	: MaxSpecificHydrolysisRate	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Hyd	"Anoxic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ n_fe	"Anaerobic hydrolysis reduction factor"
	: ReductionFactor	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ K_O	"Saturation/inhibition coeff for oxygen"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_NO	"Saturation/inhibition coeff fir nitrate"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_X	"Saturation coeff for particulate COD"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ mu_H	"Maximum growth rate on substrate"
	: MaxGrowthRate	:= {: value <- 6 ; group <- "Kinetic" :}; 
	OBJ Q_fe	"Maximum rate for fermentation"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het	"Reduction factor for denitrification"
	: ReductionFactor	:= {: value <- 0.8 ; group <- "Kinetic" :}; 
	OBJ b_H	"Rate constant for lysis and decay"
	: RateConstant	:= {: value <- 0.4 ; group <- "Kinetic" :}; 
	OBJ n_NO_Het_d	"Anoxic reduction factor for decay of heterotrophs"
	: ReductionFactor	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_F	"Saturation/inhibtion coeff for growth on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_fe	"Saturation coeff for fermentation on S_F"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_A	"Saturation coeff for S_A (acetate)"
	: SaturationCoefficient	:= {: value <- 4 ; group <- "Kinetic" :}; 
	OBJ K_NH	"Saturation coeff for ammonium (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.05 ; group <- "Kinetic" :}; 
	OBJ K_P	"Saturation coeff for phosphorus (nutrient)"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_ALK	"Saturation coeff for alkalinity (HCO3-)"
	: SaturationCoefficient	:= {: value <- 0.1 ; group <- "Kinetic" :}; 
	OBJ Q_PHA	"Rate constant for storage of PHA (base: X_PP)"
	: RateConstant	:= {: value <- 3 ; group <- "Kinetic" :}; 
	OBJ Q_PP	"Rate constant for storage of PP"
	: RateConstant	:= {: value <- 1.5 ; group <- "Kinetic" :}; 
	OBJ mu_PAO	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ n_NO_PAO	"Amount of PAO organisms active under anoxic conditions"
	: ReductionFactor	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ b_PAO	"Rate constant for lysis of X_PAO"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PP	"Rate constant for lysis of X_PP"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ b_PHA	"Rate constant for lysis of X_PHA"
	: RateConstant	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ n_NO_P_d	"Anoxic reduction factor for decay of PAO, PP and PHA"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_PS	"Saturation coeff for phosphorus in PP storage"
	: SaturationCoefficient	:= {: value <- 0.2 ; group <- "Kinetic" :}; 
	OBJ K_PP	"Saturation coeff for poly-phosphate"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ K_MAX	"Maximum ratio of X_PP/X_PAO"
	: SaturationCoefficient	:= {: value <- 0.34 ; group <- "Kinetic" :}; 
	OBJ K_IPP	"Inhibition coeff for X_PP storage"
	: SaturationCoefficient	:= {: value <- 0.02 ; group <- "Kinetic" :}; 
	OBJ K_PHA	"Saturation coeff for PHA"
	: SaturationCoefficient	:= {: value <- 0.01 ; group <- "Kinetic" :}; 
	OBJ mu_AUT	"Maximum growth rate"
	: MaxGrowthRate	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ b_AUT	"Decay rate"
	: DecayCoefficient	:= {: value <- 0.15 ; group <- "Kinetic" :}; 
	OBJ n_NO_AUT_d	"Anoxic reduction factor for decay of autotrophs"
	: ReductionFactor	:= {: value <- 0.33 ; group <- "Kinetic" :}; 
	OBJ K_O_AUT	"Saturation/inhibition coeff of autotrophs for oxygen"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ K_NH_AUT	"Saturation coeff of autotrophs for ammonium"
	: SaturationCoefficient	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ K_ALK_AUT	"Saturation coeff of autotrophs for alkalinity"
	: SaturationCoefficient	:= {: value <- 0.5 ; group <- "Kinetic" :}; 
	OBJ k_PRE	"Rate constant for P precipitation"
	: RateConstant	:= {: value <- 1 ; group <- "Kinetic" :}; 
	OBJ k_RED	"Rate constant for P redissolution"
	: RateConstant	:= {: value <- 0.6 ; group <- "Kinetic" :}; 
	OBJ F_BOD_COD	"Conversion factor BOD/COD"
	: Fraction	:= {: value <- 0.65 ; group <- "Conversion factors" :}; 

# 25 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  state <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.state.msl" 1
 
 
 
 
 


	OBJ S_O_Saturation	"Oxygen saturation concentration"
	: Concentration := {: group <- "Kinetic" :}; 
	OBJ k_h_Temp	"k_h at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ K_X_Temp	"K_X at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_H_Temp	"mu_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_fe_Temp	"Q_fe at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_H_Temp	"b_H at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PHA_Temp	"Q_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ Q_PP_Temp	"Q_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_PAO_Temp	"mu_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PAO_Temp	"b_PAO at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PP_Temp	"b_PP at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_PHA_Temp	"b_PHA at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ mu_AUT_Temp	"mu_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ b_AUT_Temp	"b_AUT at the system temperature"
	: Real := {: group <- "Kinetic" :}; 
	OBJ S_O_MonodTerm	(*  hidden = "1" *) "Monod terms for oxygen"
	: MonodTerm;
	OBJ S_NO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_NO"
	: MonodTerm;
	OBJ S_NH_MonodTerm	(*  hidden = "1" *) "Monod terms for ammonium"
	: MonodTerm;
	OBJ S_PO_MonodTerm	(*  hidden = "1" *) "Monod terms for S_PO"
	: MonodTerm;
	OBJ S_ALK_MonodTerm	(*  hidden = "1" *) "Monod terms for alkalinity"
	: MonodTerm;
	OBJ S_A_MonodTerm	(*  hidden = "1" *) "Monod terms for S_A"
	: MonodTerm;
	OBJ S_F_MonodTerm	(*  hidden = "1" *) "Monod terms for S_F"
	: MonodTerm;
	OBJ X_PHA_MonodTerm	(*  hidden = "1" *) "Monod terms for X_PHA"
	: MonodTerm;
	OBJ X_S_MonodTerm	(*  hidden = "1" *) "Monod terms for X_S"
	: MonodTerm;
	OBJ S_O_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for oxygen"
	: InhibitionTerm;
	OBJ S_NO_InhibitionTerm	(*  hidden = "1" *) "The inhibition term for S_NO"
	: InhibitionTerm;

# 30 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  initial <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.stoichiometry.msl" 1
 
 
 
 
 


	parameters.Stoichiometry[AerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerHydrol][S_PO];
	parameters.Stoichiometry[AerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnHydrol][S_PO];
	parameters.Stoichiometry[AnHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_I] := parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_F] := 1 - parameters.f_S_I;
	parameters.Stoichiometry[AnaerHydrol][S_PO] :=  - (1 - parameters.f_S_I) * parameters.i_P_S_F - parameters.f_S_I * parameters.i_P_S_I + parameters.i_P_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_NH] :=  - (1 - parameters.f_S_I) * parameters.i_N_S_F - parameters.f_S_I * parameters.i_N_S_I + parameters.i_N_X_S;
	parameters.Stoichiometry[AnaerHydrol][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnaerHydrol][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnaerHydrol][S_PO];
	parameters.Stoichiometry[AnaerHydrol][X_S] :=  - 1;
	parameters.Stoichiometry[AnaerHydrol][X_TSS] :=  - parameters.i_TSS_X_S;
	parameters.Stoichiometry[AerGrowthOnSf][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSf][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSf][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AerGrowthOnSf][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSf][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSf][S_PO];
	parameters.Stoichiometry[AerGrowthOnSf][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSf][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_O] := 1 - (1 / parameters.Y_H);
	parameters.Stoichiometry[AerGrowthOnSa][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AerGrowthOnSa][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnSa][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnSa][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnSa][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[AerGrowthOnSa][S_A];
	parameters.Stoichiometry[AerGrowthOnSa][X_H] := 1;
	parameters.Stoichiometry[AerGrowthOnSa][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_F] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] :=  - (( - 1 / parameters.Y_H) * parameters.i_P_S_F + parameters.i_P_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] :=  - (( - 1 / parameters.Y_H) * parameters.i_N_S_F + parameters.i_N_BM);
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSfDenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSfDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_N2] := (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A] :=  - 1 / parameters.Y_H;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] :=  - (1 - parameters.Y_H) / (2.86 * parameters.Y_H);
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_NO] - (1.0 / 64.0) * parameters.Stoichiometry[AnGrowthOnSaDenitrif][S_A];
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_H] := 1;
	parameters.Stoichiometry[AnGrowthOnSaDenitrif][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[Fermentation][S_F] :=  - 1;
	parameters.Stoichiometry[Fermentation][S_A] := 1;
	parameters.Stoichiometry[Fermentation][S_PO] := parameters.i_P_S_F;
	parameters.Stoichiometry[Fermentation][S_NH] := parameters.i_N_S_F;
	parameters.Stoichiometry[Fermentation][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[Fermentation][S_NH] - (1.5 / 31) * parameters.Stoichiometry[Fermentation][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[Fermentation][S_A];
	parameters.Stoichiometry[LysisOfHetero][S_PO] :=  - (parameters.f_X_I * parameters.i_P_X_I + (1 - parameters.f_X_I) * parameters.i_P_X_S - parameters.i_P_BM);
	parameters.Stoichiometry[LysisOfHetero][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfHetero][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfHetero][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfHetero][S_PO];
	parameters.Stoichiometry[LysisOfHetero][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfHetero][X_H] :=  - 1;
	parameters.Stoichiometry[LysisOfHetero][X_TSS] :=  - parameters.i_TSS_BM + parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S;
	parameters.Stoichiometry[StorageOfXPHA][S_A] :=  - 1;
	parameters.Stoichiometry[StorageOfXPHA][S_PO] := parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[StorageOfXPHA][S_PO] - (1.0 / 64.0) * parameters.Stoichiometry[StorageOfXPHA][S_A] - (1.0 / 31.0) * parameters.Stoichiometry[StorageOfXPHA][X_PP];
	parameters.Stoichiometry[StorageOfXPHA][X_PP] :=  - parameters.Y_PO;
	parameters.Stoichiometry[StorageOfXPHA][X_PHA] := 1;
	parameters.Stoichiometry[StorageOfXPHA][X_TSS] :=  - parameters.Y_PO * 3.23 + 0.6;
	parameters.Stoichiometry[AerStorageOfXPP][S_O] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AerStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AerStorageOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[AerStorageOfXPP][X_PP];
	parameters.Stoichiometry[AerStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AerStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AerStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AnStorageOfXPP][S_N2] := parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_NO] :=  - parameters.Y_PHA / 2.86;
	parameters.Stoichiometry[AnStorageOfXPP][S_PO] :=  - 1;
	parameters.Stoichiometry[AnStorageOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[AnStorageOfXPP][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnStorageOfXPP][S_NO] - (1.01 / 31.0) * parameters.Stoichiometry[AnStorageOfXPP][X_PP];
	parameters.Stoichiometry[AnStorageOfXPP][X_PP] := 1;
	parameters.Stoichiometry[AnStorageOfXPP][X_PHA] :=  - parameters.Y_PHA;
	parameters.Stoichiometry[AnStorageOfXPP][X_TSS] := 3.23 - parameters.Y_PHA * 0.6;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_O] := 1 - (1 / parameters.Y_PAO);
	parameters.Stoichiometry[AerGrowthOnXPHA][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AerGrowthOnXPHA][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AerGrowthOnXPHA][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AerGrowthOnXPHA][S_PO];
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PAO] := 1;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AerGrowthOnXPHA][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_N2] := (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO] :=  - (1 - parameters.Y_PAO) / (2.86 * parameters.Y_PAO);
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] :=  - parameters.i_N_BM;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NH] - (1.5 / 31) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_PO] - (1.0 / 14.0) * parameters.Stoichiometry[AnGrowthOnXPHADenitrif][S_NO];
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PAO] := 1;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_PHA] :=  - 1 / parameters.Y_PAO;
	parameters.Stoichiometry[AnGrowthOnXPHADenitrif][X_TSS] := parameters.i_TSS_BM - (1 / parameters.Y_PAO) * 0.6;
	parameters.Stoichiometry[LysisOfXPAO][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfXPAO][S_NH] :=  - (parameters.f_X_I * parameters.i_N_X_I + (1 - parameters.f_X_I) * parameters.i_N_X_S - parameters.i_N_BM);
	parameters.Stoichiometry[LysisOfXPAO][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfXPAO][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPAO][S_PO];
	parameters.Stoichiometry[LysisOfXPAO][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfXPAO][X_PAO] :=  - 1;
	parameters.Stoichiometry[LysisOfXPAO][X_TSS] := parameters.f_X_I * parameters.i_TSS_X_I + (1 - parameters.f_X_I) * parameters.i_TSS_X_S - parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfXPP][S_PO] := 1;
	parameters.Stoichiometry[LysisOfXPP][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[LysisOfXPP][S_PO] - (1.0 / 31.0) * parameters.Stoichiometry[LysisOfXPP][X_PP];
	parameters.Stoichiometry[LysisOfXPP][X_PP] :=  - 1;
	parameters.Stoichiometry[LysisOfXPP][X_TSS] :=  - 3.23;
	parameters.Stoichiometry[LysisOfXPHA][S_A] := 1;
	parameters.Stoichiometry[LysisOfXPHA][S_ALK] :=  - (1.0 / 64.0);
	parameters.Stoichiometry[LysisOfXPHA][X_PHA] :=  - 1;
	parameters.Stoichiometry[LysisOfXPHA][X_TSS] :=  - 0.6;
	parameters.Stoichiometry[GrowthOfAuto][S_O] := (parameters.Y_AUT - 4.57) / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_NO] := 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_PO] :=  - parameters.i_P_BM;
	parameters.Stoichiometry[GrowthOfAuto][S_NH] :=  - parameters.i_N_BM - 1 / parameters.Y_AUT;
	parameters.Stoichiometry[GrowthOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NH] - (1.0 / 14.0) * parameters.Stoichiometry[GrowthOfAuto][S_NO];
	parameters.Stoichiometry[GrowthOfAuto][X_AUT] := 1;
	parameters.Stoichiometry[GrowthOfAuto][X_TSS] := parameters.i_TSS_BM;
	parameters.Stoichiometry[LysisOfAuto][S_PO] := parameters.i_P_BM - parameters.i_P_X_I * parameters.f_X_I - parameters.i_P_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_NH] := parameters.i_N_BM - parameters.i_N_X_I * parameters.f_X_I - parameters.i_N_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[LysisOfAuto][S_ALK] := (1.0 / 14.0) * parameters.Stoichiometry[LysisOfAuto][S_NH] - (1.5 / 31) * parameters.Stoichiometry[LysisOfAuto][S_PO];
	parameters.Stoichiometry[LysisOfAuto][X_I] := parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_S] := 1 - parameters.f_X_I;
	parameters.Stoichiometry[LysisOfAuto][X_AUT] :=  - 1;
	parameters.Stoichiometry[LysisOfAuto][X_TSS] :=  - parameters.i_TSS_BM + parameters.i_TSS_X_I * parameters.f_X_I + parameters.i_TSS_X_S * (1 - parameters.f_X_I);
	parameters.Stoichiometry[Precipitation][S_PO] :=  - 1;
	parameters.Stoichiometry[Precipitation][S_ALK] :=  - parameters.Stoichiometry[Precipitation][S_PO] * (1.5 / 31);
	parameters.Stoichiometry[Precipitation][X_TSS] := 1.42;
	parameters.Stoichiometry[Precipitation][X_MEOH] :=  - 3.45;
	parameters.Stoichiometry[Precipitation][X_MEP] := 4.87;
	parameters.Stoichiometry[Redissolution][S_PO] := 1;
	parameters.Stoichiometry[Redissolution][S_ALK] :=  - (1.5 / 31) * parameters.Stoichiometry[Redissolution][S_PO];
	parameters.Stoichiometry[Redissolution][X_TSS] :=  - 1.42;
	parameters.Stoichiometry[Redissolution][X_MEOH] := 3.45;
	parameters.Stoichiometry[Redissolution][X_MEP] :=  - 4.87;
	parameters.Stoichiometry[Aeration][S_O] := 1;

# 35 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };

  equations <-
  {
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.kinetics.msl" 1
 
 
 
 
 


	state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
	state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
	state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
	state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
	state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
	state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);
	state.S_O_MonodTerm = state.C[S_O] / (parameters.K_O + state.C[S_O]);
	state.S_NO_MonodTerm = state.C[S_NO] / (parameters.K_NO + state.C[S_NO]);
	state.S_NH_MonodTerm = state.C[S_NH] / (parameters.K_NH + state.C[S_NH]);
	state.S_PO_MonodTerm = state.C[S_PO] / (parameters.K_P + state.C[S_PO]);
	state.S_ALK_MonodTerm = state.C[S_ALK] / (parameters.K_ALK + state.C[S_ALK]);
	state.S_A_MonodTerm = state.C[S_A] / (parameters.K_A + state.C[S_A]);
	state.S_F_MonodTerm = state.C[S_F] / (parameters.K_F + state.C[S_F]);
	state.X_PHA_MonodTerm = (state.C[X_PHA] / state.C[X_PAO]) / (parameters.K_PHA + state.C[X_PHA] / state.C[X_PAO]);
	state.X_S_MonodTerm = (state.C[X_S] / state.C[X_H]) / (state.K_X_Temp + state.C[X_S] / state.C[X_H]);
	state.S_O_InhibitionTerm = parameters.K_O / (parameters.K_O + state.C[S_O]);
	state.S_NO_InhibitionTerm = parameters.K_NO / (parameters.K_NO + state.C[S_NO]);

	state.Kinetics[AerHydrol] = state.k_h_Temp * state.S_O_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnHydrol] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm * state.S_NO_MonodTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AnaerHydrol] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * state.X_S_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSf] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AerGrowthOnSa] = state.mu_H_Temp * state.S_O_MonodTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSfDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_F_MonodTerm * (state.C[S_F] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[AnGrowthOnSaDenitrif] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm * state.S_A_MonodTerm * (state.C[S_A] / (state.C[S_F] + state.C[S_A])) * state.S_NH_MonodTerm * state.S_NO_MonodTerm * state.S_PO_MonodTerm * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[Fermentation] = state.Q_fe_Temp * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm * (state.C[S_F] / (parameters.K_fe + state.C[S_F])) * state.S_ALK_MonodTerm * state.C[X_H];
	state.Kinetics[LysisOfHetero] = state.b_H_Temp * (state.S_O_MonodTerm + parameters.n_NO_Het_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_H];
	state.Kinetics[StorageOfXPHA] = state.Q_PHA_Temp * state.S_A_MonodTerm * state.S_ALK_MonodTerm * (state.C[X_PP]) / (parameters.K_PP + state.C[X_PP] / state.C[X_PAO]) * state.S_O_InhibitionTerm * state.S_NO_InhibitionTerm;
	state.Kinetics[AerStorageOfXPP] = state.Q_PP_Temp * state.S_O_MonodTerm * state.C[S_PO] / (state.C[S_PO] + parameters.K_PS) * state.S_ALK_MonodTerm * state.X_PHA_MonodTerm * (parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) / (parameters.K_IPP + parameters.K_MAX - state.C[X_PP] / state.C[X_PAO]) * state.C[X_PAO];
	state.Kinetics[AnStorageOfXPP] = state.Kinetics[AerStorageOfXPP] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[AerGrowthOnXPHA] = state.mu_PAO_Temp * state.S_O_MonodTerm * state.S_NH_MonodTerm * state.S_ALK_MonodTerm * state.S_PO_MonodTerm * state.X_PHA_MonodTerm * state.C[X_PAO];
	state.Kinetics[AnGrowthOnXPHADenitrif] = state.Kinetics[AerGrowthOnXPHA] * parameters.n_NO_PAO * (parameters.K_O / state.C[S_O]) * state.S_NO_MonodTerm;
	state.Kinetics[LysisOfXPAO] = state.b_PAO_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PAO] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPP] = state.b_PP_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PP] * state.S_ALK_MonodTerm;
	state.Kinetics[LysisOfXPHA] = state.b_PHA_Temp * (state.S_O_MonodTerm + parameters.n_NO_P_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_PHA] * state.S_ALK_MonodTerm;
	state.Kinetics[GrowthOfAuto] = state.mu_AUT_Temp * state.C[S_O] / (state.C[S_O] + parameters.K_O_AUT) * state.C[S_NH] / (state.C[S_NH] + parameters.K_NH_AUT) * state.S_PO_MonodTerm * state.C[S_ALK] / (state.C[S_ALK] + parameters.K_ALK_AUT) * state.C[X_AUT];
	state.Kinetics[LysisOfAuto] = state.b_AUT_Temp * (state.S_O_MonodTerm + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm * state.S_NO_MonodTerm) * state.C[X_AUT];
	state.Kinetics[Precipitation] = parameters.k_PRE * state.C[S_PO] * state.C[X_MEOH];
	state.Kinetics[Redissolution] = parameters.k_RED * state.C[X_MEP] * (state.C[S_ALK] / (parameters.K_ALK_AUT + state.C[S_ALK]));
	state.Kinetics[Aeration]  = state.Kla_Actual * (state.S_O_Saturation - state.C[S_O]);

# 40 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempModel.sensors.msl" 1
 
 
 
 
 


	interface.DO = state.C[S_O];
	interface.NH4 = state.C[S_NH];
	interface.NO3 = state.C[S_NO];
	interface.TSS = state.C[X_TSS];
	interface.OnlineCOD = (state.C[S_A] + state.C[S_F] + state.C[S_I] + state.C[X_H] + state.C[X_AUT] + state.C[X_S] + state.C[X_I] + state.C[X_PAO] + state.C[X_PHA]);
	interface.OfflineBOD = parameters.F_BOD_COD * (state.C[S_A] + state.C[S_F] + state.C[X_S] + state.C[X_PHA] + (1 - parameters.f_X_I) * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTN = (state.C[S_NO] + state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OfflineTKN = (state.C[S_NH] + parameters.i_N_S_I * state.C[S_I] + parameters.i_N_S_F * state.C[S_F] + parameters.i_N_X_I * state.C[X_I] + parameters.i_N_X_S * state.C[X_S] + parameters.i_N_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.OnlineTP = (state.C[S_PO] + state.C[X_PP] + 0.205 * state.C[X_MEP] + parameters.i_P_S_I * state.C[S_I] + parameters.i_P_S_F * state.C[S_F] + parameters.i_P_X_I * state.C[X_I] + parameters.i_P_X_S * state.C[X_S] + parameters.i_P_BM * (state.C[X_H] + state.C[X_AUT] + state.C[X_PAO]));
	interface.PO4 = state.C[S_PO];
	interface.V_ASU = state.V;
	interface.OUR_ASU =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_O] / state.V) + parameters.Stoichiometry[Aeration][S_O] * state.Kinetics[Aeration];
	interface.NUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NO] / state.V) + parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.NPR =           IF(state.V==0)           THEN 0           ELSE parameters.Stoichiometry[GrowthOfAuto][S_NO] * state.Kinetics[GrowthOfAuto];
	interface.AUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_NH] / state.V);
	interface.PUR =           IF(state.V==0)           THEN 0           ELSE - (state.ConversionTermPerComponent[S_PO] / state.V);
	interface.Kla_ASU = state.Kla_Actual;

# 41 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.body.msl" 2

  };


# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.body.msl" 2


















# 101 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 2

   :};

 CLASS AtomicConversionBiofilmBulk EXTENDS AtomicConversionBiofilm WITH
   {:
    
   
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.layer.body.msl" 1
 




















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.layer.body.msl" 1
 















 
 



   interface <-
   {
 
   };

   parameters <-
   {
 
   };

   state <-
   {
   
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.layer.state.msl" 1
 
















 















  OBJ S_O_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for oxygen" : MonodTerm[NrOfLayers;];
  OBJ S_NO_MonodTerm_Biofilm  (*  hidden = "1" *) "Monod terms for S_NO" : MonodTerm[NrOfLayers;];
  OBJ S_NH_MonodTerm_Biofilm  (*  hidden = "1" *) "Monod terms for ammonium" : MonodTerm[NrOfLayers;];
  OBJ S_PO_MonodTerm_Biofilm  (*  hidden = "1" *) "Monod terms for S_PO" : MonodTerm[NrOfLayers;];
  OBJ S_ALK_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for alkalinity" : MonodTerm[NrOfLayers;];
  OBJ S_A_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for S_A" : MonodTerm[NrOfLayers;];
  OBJ S_F_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for S_F" : MonodTerm[NrOfLayers;];
  OBJ X_PHA_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for X_PHA" : MonodTerm[NrOfLayers;];
  OBJ X_S_MonodTerm_Biofilm (*  hidden = "1" *) "Monod terms for X_S" : MonodTerm[NrOfLayers;];
  OBJ S_O_InhibitionTerm_Biofilm  (*  hidden = "1" *) "The inhibition term for oxygen" : InhibitionTerm[NrOfLayers;];
  OBJ S_NO_InhibitionTerm_Biofilm (*  hidden = "1" *) "The inhibition term for S_NO" : InhibitionTerm[NrOfLayers;];

# 34 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.layer.body.msl" 2

   };

   initial <-
   {
 
   };

   equations <-
   {
   
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.layer.kinetics.msl" 1
 














 

    state.S_O_Saturation = 14.65 - 0.41 * state.Temp_Actual + 0.00799 * state.Temp_Actual * state.Temp_Actual - 0.0000778 * state.Temp_Actual * state.Temp_Actual * state.Temp_Actual;
  state.k_h_Temp = parameters.k_h * pow(parameters.theta_k_h,state.Temp_Actual - parameters.Temp_Ref);
  state.K_X_Temp = parameters.K_X * pow(parameters.theta_K_X,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_H_Temp = parameters.mu_H * pow(parameters.theta_mu_H,state.Temp_Actual - parameters.Temp_Ref);
  state.Q_fe_Temp = parameters.Q_fe * pow(parameters.theta_Q_fe,state.Temp_Actual - parameters.Temp_Ref);
  state.b_H_Temp = parameters.b_H * pow(parameters.theta_b_H,state.Temp_Actual - parameters.Temp_Ref);
  state.Q_PHA_Temp = parameters.Q_PHA * pow(parameters.theta_Q_PHA,state.Temp_Actual - parameters.Temp_Ref);
  state.Q_PP_Temp = parameters.Q_PP * pow(parameters.theta_Q_PP,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_PAO_Temp = parameters.mu_PAO * pow(parameters.theta_mu_PAO,state.Temp_Actual - parameters.Temp_Ref);
  state.b_PAO_Temp = parameters.b_PAO * pow(parameters.theta_b_PAO,state.Temp_Actual - parameters.Temp_Ref);
  state.b_PP_Temp = parameters.b_PP * pow(parameters.theta_b_PP,state.Temp_Actual - parameters.Temp_Ref);
  state.b_PHA_Temp = parameters.b_PHA * pow(parameters.theta_b_PHA,state.Temp_Actual - parameters.Temp_Ref);
  state.mu_AUT_Temp = parameters.mu_AUT * pow(parameters.theta_mu_AUT,state.Temp_Actual - parameters.Temp_Ref);
  state.b_AUT_Temp = parameters.b_AUT * pow(parameters.theta_b_AUT,state.Temp_Actual - parameters.Temp_Ref);

{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_O_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_O][Layer_Index] / (parameters.K_O + state.C_Biofilm[S_O][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_NO_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_NO][Layer_Index] / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_NH_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_NH][Layer_Index] / (parameters.K_NH + state.C_Biofilm[S_NH][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_PO_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_PO][Layer_Index] / (parameters.K_P + state.C_Biofilm[S_PO][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_ALK_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_ALK][Layer_Index] / (parameters.K_ALK + state.C_Biofilm[S_ALK][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_A_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_A][Layer_Index] / (parameters.K_A + state.C_Biofilm[S_A][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_F_MonodTerm_Biofilm[Layer_Index] = state.C_Biofilm[S_F][Layer_Index] / (parameters.K_F + state.C_Biofilm[S_F][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.X_PHA_MonodTerm_Biofilm[Layer_Index] = (state.C_Biofilm[X_PHA][Layer_Index] / state.C_Biofilm[X_PAO][Layer_Index]) / (parameters.K_PHA + state.C_Biofilm[X_PHA][Layer_Index] / state.C_Biofilm[X_PAO][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.X_S_MonodTerm_Biofilm[Layer_Index] = (state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_H][Layer_Index]) / (state.K_X_Temp + state.C_Biofilm[X_S][Layer_Index] / state.C_Biofilm[X_H][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_O_InhibitionTerm_Biofilm[Layer_Index] = parameters.K_O / (parameters.K_O + state.C_Biofilm[S_O][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.S_NO_InhibitionTerm_Biofilm[Layer_Index] = parameters.K_NO / (parameters.K_NO + state.C_Biofilm[S_NO][Layer_Index]);
  };

{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerHydrol][Layer_Index] = state.k_h_Temp * state.S_O_MonodTerm_Biofilm[Layer_Index] * state.X_S_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnHydrol][Layer_Index] = state.k_h_Temp * parameters.n_NO_Hyd * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index] * state.X_S_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnaerHydrol][Layer_Index] = state.k_h_Temp * parameters.n_fe * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_InhibitionTerm_Biofilm[Layer_Index] * state.X_S_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthOnSf][Layer_Index] = state.mu_H_Temp * state.S_O_MonodTerm_Biofilm[Layer_Index] * state.S_F_MonodTerm_Biofilm[Layer_Index] * (state.C_Biofilm[S_F][Layer_Index] / (state.C_Biofilm[S_F][Layer_Index] + state.C_Biofilm[S_A][Layer_Index])) * state.S_NH_MonodTerm_Biofilm[Layer_Index] * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthOnSa][Layer_Index] = state.mu_H_Temp * state.S_O_MonodTerm_Biofilm[Layer_Index] * state.S_A_MonodTerm_Biofilm[Layer_Index] * (state.C_Biofilm[S_A][Layer_Index] / (state.C_Biofilm[S_F][Layer_Index] + state.C_Biofilm[S_A][Layer_Index])) * state.S_NH_MonodTerm_Biofilm[Layer_Index] * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnGrowthOnSfDenitrif][Layer_Index] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_F_MonodTerm_Biofilm[Layer_Index] * (state.C_Biofilm[S_F][Layer_Index] / (state.C_Biofilm[S_F][Layer_Index] + state.C_Biofilm[S_A][Layer_Index])) * state.S_NH_MonodTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index] * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnGrowthOnSaDenitrif][Layer_Index] = state.mu_H_Temp * parameters.n_NO_Het * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_A_MonodTerm_Biofilm[Layer_Index] * (state.C_Biofilm[S_A][Layer_Index] / (state.C_Biofilm[S_F][Layer_Index] + state.C_Biofilm[S_A][Layer_Index])) * state.S_NH_MonodTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index] * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[Fermentation][Layer_Index] = state.Q_fe_Temp * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_InhibitionTerm_Biofilm[Layer_Index] * (state.C_Biofilm[S_F][Layer_Index] / (parameters.K_fe + state.C_Biofilm[S_F][Layer_Index])) * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[LysisOfHetero][Layer_Index] = state.b_H_Temp * (state.S_O_MonodTerm_Biofilm[Layer_Index] + parameters.n_NO_Het_d * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index]) * state.C_Biofilm[X_H][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[StorageOfXPHA][Layer_Index] = state.Q_PHA_Temp * state.S_A_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * (state.C_Biofilm[X_PP][Layer_Index]) / (parameters.K_PP + state.C_Biofilm[X_PP][Layer_Index] / state.C_Biofilm[X_PAO][Layer_Index]);
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerStorageOfXPP][Layer_Index] = state.Q_PP_Temp * state.S_O_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[S_PO][Layer_Index] / (state.C_Biofilm[S_PO][Layer_Index] + parameters.K_PS) * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.X_PHA_MonodTerm_Biofilm[Layer_Index] * (parameters.K_MAX - state.C_Biofilm[X_PP][Layer_Index] / state.C_Biofilm[X_PAO][Layer_Index]) / (parameters.K_IPP + parameters.K_MAX - state.C_Biofilm[X_PP][Layer_Index] / state.C_Biofilm[X_PAO][Layer_Index]) * state.C_Biofilm[X_PAO][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AerGrowthOnXPHA][Layer_Index] = state.mu_PAO_Temp * state.S_O_MonodTerm_Biofilm[Layer_Index] * state.S_NH_MonodTerm_Biofilm[Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index] * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.X_PHA_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[X_PAO][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[LysisOfXPAO][Layer_Index] = state.b_PAO_Temp * (state.S_O_MonodTerm_Biofilm[Layer_Index] + parameters.n_NO_P_d * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index]) * state.C_Biofilm[X_PAO][Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[LysisOfXPP][Layer_Index] = state.b_PP_Temp * (state.S_O_MonodTerm_Biofilm[Layer_Index] + parameters.n_NO_P_d * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index]) * state.C_Biofilm[X_PP][Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[LysisOfXPHA][Layer_Index] = state.b_PHA_Temp * (state.S_O_MonodTerm_Biofilm[Layer_Index] + parameters.n_NO_P_d * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index]) * state.C_Biofilm[X_PHA][Layer_Index] * state.S_ALK_MonodTerm_Biofilm[Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[GrowthOfAuto][Layer_Index] = state.mu_AUT_Temp * state.C_Biofilm[S_O][Layer_Index] / (state.C_Biofilm[S_O][Layer_Index] + parameters.K_O_AUT) * state.C_Biofilm[S_NH][Layer_Index] / (state.C_Biofilm[S_NH][Layer_Index] + parameters.K_NH_AUT) * state.S_PO_MonodTerm_Biofilm[Layer_Index] * state.C_Biofilm[S_ALK][Layer_Index] / (state.C_Biofilm[S_ALK][Layer_Index] + parameters.K_ALK_AUT) * state.C_Biofilm[X_AUT][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[LysisOfAuto][Layer_Index] = state.b_AUT_Temp * (state.S_O_MonodTerm_Biofilm[Layer_Index] + parameters.n_NO_AUT_d * state.S_O_InhibitionTerm_Biofilm[Layer_Index] * state.S_NO_MonodTerm_Biofilm[Layer_Index]) * state.C_Biofilm[X_AUT][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[Precipitation][Layer_Index] = parameters.k_PRE * state.C_Biofilm[S_PO][Layer_Index] * state.C_Biofilm[X_MEOH][Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[Redissolution][Layer_Index] = parameters.k_RED * state.C_Biofilm[X_MEP][Layer_Index] * (state.C_Biofilm[S_ALK][Layer_Index] / (parameters.K_ALK_AUT + state.C_Biofilm[S_ALK][Layer_Index]));
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnStorageOfXPP][Layer_Index] = state.Kinetics_Biofilm[AerStorageOfXPP][Layer_Index] * parameters.n_NO_PAO * (parameters.K_O / state.C_Biofilm[S_O][Layer_Index]) * state.S_NO_MonodTerm_Biofilm[Layer_Index];
  };
{FOREACH Layer_Index IN {1 .. NrOfLayers}:
  state.Kinetics_Biofilm[AnGrowthOnXPHADenitrif][Layer_Index] = state.Kinetics_Biofilm[AerGrowthOnXPHA][Layer_Index] * parameters.n_NO_PAO * (parameters.K_O / state.C_Biofilm[S_O][Layer_Index]) * state.S_NO_MonodTerm_Biofilm[Layer_Index];
  };


# 44 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASM2dModTempConversionModel.layer.body.msl" 2

 
   };



# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.VolumeASMConversionModel.layer.body.msl" 2










# 107 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 2

   
   terminal <-  
   {
   };
   
   :};


 CLASS BaseBiofilm1D EXTENDS AtomicConversionBiofilmBulk WITH
 {:
 interface <-  
 {
 OBJ Kla (* terminal = "in_2"; manip = "1" *) "Gas transfer coefficient for oxygen" : 
   OxygenTransferCoefficient := {: causality <- "CIN" ; value <- 750 ; group <- "Operational" :}; 
 OBJ Temp (* terminal = "in_2"; manip = "1" *)  "Temperature of the activated sludge"
  : CelsiusTemperature  := {: causality <- "CIN" ; value <- 15 ; group <- "Operational" :}; 
   OBJ AerationEnergy (* terminal = "out_2" *)"Aeration energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
 }; 
 parameters <- 
 {  
  
  
  
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.BiofilmsDiffusivity.msl" 1
 















 OBJ D_x "Diffusivity coefficient for biomass" : Diffusivity := {: value <- 1e-10 ; group <- "Transport" :};
 OBJ D_i "Diffusivity coefficient" : Diffusivity[NrOfComponents;] 
 
 






 
 
   :=[{: value <- 1.0e-10 ; group <- "Transport":},{: value <- 1.0e-4 ;group <- "Transport":} , {: value <- 2.0e-4 ;group <- "Transport":}, {: value <- 2.0e-4 ;group <- "Transport":},
   {: value <- 2.2e-4 ;group <- "Transport":} ,{: value <- 2.0e-4 ;group <- "Transport":} , {: value <- 2.0e-4 ;group <- "Transport":} ,
   {: value <- 1.7e-4 ;group <- "Transport":} ,{: value <- 2.0e-4 ;group <- "Transport":} , {: value <- 1.4e-4 ;group <- "Transport":} ,
   {: value <- 2.2e-4 ;group <- "Transport":} ,{: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":} ,
   {: value <- 0 ;group <- "Transport":} , {: value <- 0 ;group <- "Transport":}, {: value <- 0 ;group <- "Transport":}; ] 
 
 
 






 
 







 ;
# 131 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 2

 OBJ dcmin (* hidden = "1" *) "Min concentration gradient that results in diffusion": Concentration := {: value <- 1E-6 ; group <- "System" :};
  
  
 OBJ d_ini "Initial biofilm thickness" : Length := {: value <- 0.0002 ; group <- "System" :};
 OBJ d_max "Maximum biofilm thickness" : Length := {: value <- 0.0005 ; group <- "Dimension" :};
 OBJ d_min (* hidden = "0" *) "Min biofilm thickness" : Length := {: value <- 5e-7 ; group <- "Dimension" :};
 OBJ A (* fixed = "1" *) "Total biofilm surface area" : Area := {: value <- 400; group <- "Dimension" :};
 OBJ eta "Porosity of the biofilm" : Ratio := {:value <- 1.0 ; group <- "Transport" :};
 OBJ deltao "Boundary layer" : Length := {:value <- 1E-5 ; group <- "Transport" :};
 OBJ rho "Biofilm density" : Density := {:value <- 40000 ;group <- "System" :};
 OBJ rho_layer (* hidden = "1" *) "Biofilm density of a layer": Density[NrOfLayers;] := {: group <- "System" :}; 
  
 OBJ k_At "Coefficient for attachment of particulates" : RateConstant:= {:value <- 0.1 ;group <- "Transport" :}; 
 OBJ k_detach "Factor of proportionality for the detachment controller": Real := {: value <- 1E5 ; group <- "System" :};
  
  
 OBJ V_R (* fixed = "1" *) "volume of the reactor" : Volume := {: value <- 1.0 ; group <- "Dimension" :};
 OBJ L "Length of the reactor" : Length := {:value <- 1.0 ; group <- "Dimension" :};
 OBJ H "Height of the reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
 OBJ W "Width of reactor" : Length := {:value <- 1.0 ;group <- "Dimension" :};
  
  
 OBJ fc_real (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (true)" : Ratio := {: group <- "Dimension" :} ;
 OBJ fc (* hidden = "1" *) "Portion of the reactor volume occupied by the solid support for the biofilm (apparent)" : Ratio := {: value<- 0.5; group <- "Dimension" :} ;
 OBJ area_sp (* hidden = "1" *) "Specific surface area" : SpecificAreaVolume := {: value<- 80; group <- "System" :};
 OBJ Vc_real (* hidden = "1"; fixed = "1" *) "(true) volume of the carrier" : Volume := {: value <- 0.5 ; group <- "Dimension" :} ;
 OBJ Vc (* hidden = "1"; fixed = "1" *) "(apparent) volume of the carrier" : Volume := {: value <- 1 ; group <- "Dimension" :} ;

 
  OBJ OTR_Energy  "Oxygen transfer rate per energy input" : TransferRateEnergy := {: value <- 1800 ; group <- "Aeration" :}; 
    OBJ Period "Period over which the costs are calculated" : Time := {: value <- 1 ; group <- "Miscellaneous":};
 };
 
 state <-
 {    
 OBJ S_Sat (* hidden ="1" *) "Saturation concentration" : Concentration[NrOfComponents;];
  
 OBJ InFluxPerComponent (* hidden = "1" *) "Fluxes of all components through the process unit" : MassFluxVector; 
 OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : MassFluxVector;
 OBJ Q_In "Influent flow rate" : FlowRate:= {: group <- "Operational" :};
  
 OBJ Total_Mass "Total mass of the biofilm ": Mass:= {: group <- "Mass" :};
 OBJ Mass_Layer "Mass of each component per layer" : Mass[NrOfLayers;] := {: group <- "Mass" :};  
 
 OBJ M "Mass of each component in the bulk liquid": MassVector   
 






 
   :=[{: value <- 4500 :}, {: value <- 10 :}, {: value <- 10 :}, {: value <- 1 :},
   {: value <- 10 :}, {: value <- 5 :}, {: value <- 5 :} ,
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 10 :} ,
   {: value <- 10 :}, 
   {: value <- 10 :}, {: value <- 10 :}, {: value <- 100 :},
   {: value <- 100 :}, {: value <- 10 :}, {: value <- 10 :},
   {: value <- 100 :}, {: value <- 300 :}, {: value <- 1 :},
   {: value <- 1 :}, {: value <- 1 :}; ]
 
 






 







 ;
  
 OBJ V_biofilm "Volume of the biofilm" : Volume:= {: group <- "Operational" :};
 OBJ V_layer "Volume of each biofilm layer" : VolumeVector := {: group <- "System" :}; 
  
  
 OBJ Detach_Term (* hidden = "1" *) "Detachment of each biofilm component": MassFluxVector := {: group <- "Transport" :};
 OBJ Reaction_Term_Biofilm (* hidden = "1" *) "Reaction term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Term_Biofilm (* hidden = "1" *) "Diffustion term in the biofilm matrix" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_In (* hidden = "1" *) "Diffustion between layer 1 and bulk liquid" : Rate[NrOfComponents;];
 OBJ Diffusion_Through_Up (* hidden = "1" *) "Upward diffustion in layers 2 to ButOne" : Rate[NrOfComponents;][NrOfLayers;];
 OBJ Diffusion_Through_Down (* hidden = "1" *) "Downward diffustion in layers 2 to Last" : Rate[NrOfComponents;][NrOfLayers;];
  
  
 OBJ u_Dt "Velocity of biofilm growth" : TakacsVelocityVector := {: group <- "System" :};
 OBJ d "Thickness of the biofilm" : Length:= {: group <- "Operational" :};
 OBJ d_layer "Thickness of each layer": LengthVector := {: group <- "System" :};  
 OBJ d_layer_calc (* hidden = "1" *) "Thickness of each layer" : LengthVector := {: group <- "System" :};
 OBJ d_test (* hidden = "1" *) "Thickness of the biofilm" : Length;
 OBJ delta (* hidden = "1" *) "Boundary layer for each component" : Length[NrOfComponents;]:= {: group <- "Transport" :};
 
    OBJ Integ_AE (* hidden = "1" *)"Integral aeration energy" : ElectricalEnergy ;
 };
 
 initial <-
 {
  
 };

 equations <-
 {
  
 state.Q_In = 0.000001 * interface.Inflow[IndexOfSolvent] ;
 
 { FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
      SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}:
      In_Terminal[Comp_Index] ; };
  
  
  
 





 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.Mass_Layer[Layer_Index] = (SUMOVER Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents}:
      state.M_Biofilm[Comp_Index][Layer_Index]) - state.M_Biofilm[X_TSS][Layer_Index] ; };
 
 {state.Total_Mass = SUMOVER Layer_Index IN {1 .. NrOfLayers}: state.Mass_Layer[Layer_Index] ;};
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer_calc[Layer_Index] =
          state.Mass_Layer[Layer_Index]/(parameters.A * parameters.rho_layer[Layer_Index]) ; };
  
  
  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers}:
      state.d_layer[Layer_Index] =
        IF (state.d_layer_calc[Layer_Index] >= (parameters.d_min/NrOfLayers))
           THEN state.d_layer_calc[Layer_Index]
           ELSE parameters.d_min/NrOfLayers ; };
  
  
  
 state.d = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.d_layer[Layer_Index] ;
  
  
  
  
  
  
 state.V = (parameters.V_R - parameters.Vc_real) - state.V_biofilm ;
 
 {FOREACH Layer_Index IN {1 .. NrOfLayers}: state.V_layer[Layer_Index] = parameters.A * state.d_layer[Layer_Index] ; };
 
 {state.V_biofilm = SUMOVER Layer_Index IN {1 .. NrOfLayers} : state.V_layer[Layer_Index] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}: state.delta[Comp_Index] = parameters.deltao ;};
  
  
 state.Kla_Actual = interface.Kla ;
 
      state.S_Sat[S_O] = state.S_O_Saturation;
 
  
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.ConversionTermPerComponent[Comp_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics[Reaction_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) * state.V ; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] =
      SUMOVER Reaction_Index IN {1 .. NrOfReactions} :
      (state.Kinetics_Biofilm[Reaction_Index][Layer_Index] * parameters.Stoichiometry[Reaction_Index][Comp_Index]) ; }; };
  
 {FOREACH Comp_Index IN {IndexOfSolvent .. NrOfComponents}:
      state.FluxPerComponent[Comp_Index] =
      (SUMOVER In_Terminal IN {SelectByType(interface,InWWTPTerminal)}: In_Terminal[Comp_Index])+
      (SUMOVER Out_Terminal IN {SelectByType(interface,OutWWTPTerminal)}: Out_Terminal[Comp_Index]);};
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_In[Comp_Index][1] =
          IF (fabs(state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
           ELSE 0.0 ;  };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayersButOne} :
      state.Diffusion_Through_Down[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
           ELSE 0.0 ; }; };
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayers} :
      state.Diffusion_Through_Up[Comp_Index][Layer_Index] =
          IF (fabs(state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) > parameters.dcmin)
           THEN parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
           ELSE 0.0 ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][1] =
        state.Diffusion_In[Comp_Index][1] - state.Diffusion_Through_Down[Comp_Index][1] ; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      state.Diffusion_Term_Biofilm[Comp_Index][Layer_Index] =
        state.Diffusion_Through_Up[Comp_Index][Layer_Index] - state.Diffusion_Through_Down[Comp_Index][Layer_Index] ; }; };
 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.Diffusion_Term_Biofilm[Comp_Index][NrOfLayers] = state.Diffusion_Through_Up[Comp_Index][NrOfLayers] ; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      state.C[Comp_Index] = IF (state.V > 0.0)
      THEN state.M[Comp_Index] / state.V
      ELSE 0.0 ;};
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      state.C_Biofilm[Comp_Index][Layer_Index] =
      IF (state.V_layer[Layer_Index] > 0.0)
      THEN state.M_Biofilm[Comp_Index][Layer_Index] / state.V_layer[Layer_Index]
      ELSE 0.0 ; }; };
  
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      state.Detach_Term[Comp_Index] =
      SUMOVER Layer_Index IN {1 .. NrOfLayers} :
      (state.u_Dt[Layer_Index] * parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]) ; };
 
 
  
 DERIV(state.M[IndexOfSolvent], [independent.t]) = 0.0 ; 
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent}:
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
 
      - parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      ; };  
{FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV(state.M[Comp_Index], [independent.t]) =
      state.InFluxPerComponent[Comp_Index] - state.Q_In * state.C[Comp_Index]
      + state.ConversionTermPerComponent[Comp_Index]
      - parameters.k_At * state.V * state.C[Comp_Index]
      + state.Detach_Term[Comp_Index] ; };  
  
 {FOREACH Layer_Index IN {1 .. NrOfLayers} :
      DERIV (state.M_Biofilm[IndexOfSolvent][Layer_Index], [independent.t])=0.0 ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
        DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
 
      + parameters.D_i[Comp_Index] * (state.C[Comp_Index] - state.C_Biofilm[Comp_Index][1] ) * parameters.A / state.delta[Comp_Index]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index] [1] - state.C_Biofilm[Comp_Index] [2]) * parameters.A / state.d_layer[1]
      ; };
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][1], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][1] * state.V_layer[1]
      + parameters.k_At * state.V * state.C[Comp_Index]
      - state.u_Dt[1] * parameters.A * state.C_Biofilm[Comp_Index][1]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][1] - state.C_Biofilm[Comp_Index][2]) * parameters.A / state.d_layer[1] ; }; 
  
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
          state.Reaction_Term_Biofilm [Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1]
      - parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      ; }; };
 
 {FOREACH Layer_Index IN {2 .. NrOfLayersButOne} :
      {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][Layer_Index], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][Layer_Index] * state.V_layer[Layer_Index]
      - state.u_Dt[Layer_Index]* parameters.A * state.C_Biofilm[Comp_Index][Layer_Index]
      - parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index] - state.C_Biofilm[Comp_Index][Layer_Index + 1]) * parameters.A / state.d_layer[Layer_Index]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][Layer_Index - 1] - state.C_Biofilm[Comp_Index][Layer_Index]) * parameters.A / state.d_layer[Layer_Index - 1] ; }; };
  
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. IndexOfLastSolubleComponent} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
 
      + parameters.D_i[Comp_Index] * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne]
      ;};
  
 {FOREACH Comp_Index IN {IndexOfFirstParticulateComponent .. NrOfComponents} :
      DERIV (state.M_Biofilm[Comp_Index][NrOfLayers], [independent.t]) =
      state.Reaction_Term_Biofilm[Comp_Index][NrOfLayers] * state.V_layer[NrOfLayers]
      - state.u_Dt[NrOfLayers]* parameters.A * state.C_Biofilm[Comp_Index][NrOfLayers]
      + parameters.D_x * (state.C_Biofilm[Comp_Index][NrOfLayersButOne] - state.C_Biofilm[Comp_Index][NrOfLayers]) * parameters.A / state.d_layer[NrOfLayersButOne] ; };
  
  
 interface.Outflow[IndexOfSolvent] = - interface.Inflow[IndexOfSolvent] ;
 {FOREACH Comp_Index IN {IndexOfFirstSolubleComponent .. NrOfComponents} :
      interface.Outflow[Comp_Index] = - state.Q_In * state.C[Comp_Index] ; };

    state.Temp_Actual = interface.Temp;

 
  DERIV(state.Integ_AE,[independent.t])= state.Kla_Actual * state.V ;
  interface.AerationEnergy = state.S_O_Saturation / (parameters.Period * parameters.OTR_Energy) * state.Integ_AE ;
 }; 
 
:};

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\biofilm/wwtp.base.biofilms.ifas1D.msl" 1
 


















CLASS IFAS1D (* icon = "ifas"; is_default = "true" *)
 "A model for an Integrated Fixed film Activated Sludge unit, based on the biofilm model by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for an Integrated Fixed film Activated Sludge unit. Detachment when d>dmax and proportional to (d-dmax)^2";
    interface <-
    {
   OBJ MixingEnergy (* terminal = "out_2" *)"Mixing energy" : ElectricalEnergy := {: causality <- "COUT"; group <- "Energy" :};
    };
    parameters <- 
    {  
       OBJ f_solid "Fraction of the solid support to the total volume of the reactor" : Ratio := {:value <- 0.05 ; group <- "Dimension" :} ;
     OBJ A_Sp_C "(carrier) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
 
  OBJ ME_unit "Energy requirement per unit of volume for mixing in a AS tank" : Real := {: value <- 0.005; group <- "Mixing energy":};
  OBJ Kla_Min "Lowest kLa value that ensures adequate mixing" : OxygenTransferCoefficient :={: value <- 20.0; group <- "Mixing energy":};
    OBJ Mixing_When_Aerated "Mixing activity during aeration" : Real := {: value <- 0 ; group <- "Mixing energy":};
    };
    
      state <-
    {
 
    OBJ Integ_ME (* hidden = "1" *)"Integral mixing energy" : ElectricalEnergy ;
  OBJ ME_Instant (* hidden = "1" *)"Instantaneous mixing energy" : Real:= {: group <- "Mixing":};
    };
     
    initial <-
    {
      
     parameters.fc = parameters.f_solid ;
     parameters.fc_real = parameters.f_solid ;
     parameters.area_sp = parameters.A_Sp_C ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.Vc ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / 0.000001 ;
    };
 
    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; 
       };

 
  state.ME_Instant = IF ((state.Kla_Actual < parameters.Kla_Min) || (state.Kla_Actual == 0))
            THEN parameters.ME_unit * state.V
          ELSE 
            IF (parameters.Mixing_When_Aerated)
            THEN parameters.ME_unit * state.V
            ELSE 0;   

  DERIV(state.Integ_ME,[independent.t])= state.ME_Instant;
  interface.MixingEnergy = state.Integ_ME ;
          
    }; 

 :};


# 446 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\biofilm/wwtp.base.biofilms.tricklingfilter1D.msl" 1
 


















CLASS TricklingFilter1D (* icon = "trickling_filter"; is_default = "true" *)
 "A model for a 1D-biofilm by Van Hulle and Vanrolleghem"
 EXTENDS BaseBiofilm1D WITH
 {:
    
    comments <- "A model for a trickling filter. Detachment when d>dmax and proportional to (d-dmax)^2";
    
    parameters <- 
    {  
       OBJ f_void "Void space of the media" : Ratio := {:value <- 0.5 ; group <- "Dimension" :} ;
     OBJ A_Sp_R "(reactor) Specific surface area" : SpecificAreaVolume := {:value <- 400 ; group <- "System" :};
    };
 
    initial <-
    {
     parameters.fc = 1.0 ;   
     parameters.fc_real = 1.0 - parameters.f_void ;
     parameters.area_sp = parameters.A_Sp_R ;
      
      
     parameters.V_R = parameters.L * parameters.W * parameters.H ;
     parameters.Vc_real = parameters.fc_real * parameters.V_R ;
     parameters.Vc = parameters.fc * parameters.V_R ;
      
     parameters.A = parameters.area_sp * parameters.fc * parameters.V_R ;
      
      
     {FOREACH Layer_Index IN {1 .. NrOfLayers}:
          parameters.rho_layer[Layer_Index]=parameters.eta*parameters.rho ; };
      
     state.M[IndexOfSolvent] = ((parameters.V_R - parameters.Vc_real) - (parameters.A*parameters.d_ini)) / 0.000001 ;
    };
 
    equations <-
    {
     
    {FOREACH Layer_Index IN {1 .. NrOfLayers} : state.u_Dt[Layer_Index] =
           IF ( state.d_layer_calc[Layer_Index] <= (parameters.d_max/NrOfLayers) )
            THEN 0.0
          ELSE parameters.k_detach * pow(( state.d_layer_calc[Layer_Index] - (parameters.d_max/NrOfLayers) ),2) ; };
    }; 

 :};



# 447 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.biofilms.msl" 2





# 53 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.internal_membrane.msl" 1
 


















# 516 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.internal_membrane.msl"



# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.ADM1.msl" 1
 















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.definitionsADM1.msl" 1
 


















 
 

 


 CLASS CarbonContentOfAminoAcids
   "carbon content of amino acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfAcetate
   "carbon content of acetate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfBiomass
   "carbon content of biomass"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfButyrate
   "carbon content of butyrate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfMethane
   "carbon content of methane"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfLCFattyAcids
   "carbon content of long chain fatty acids"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfPropionate
   "carbon content of propionate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfSolubleInertCOD
   "carbon content of soluble inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfValerate
   "carbon content of valerate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfComplexParticulateCOD
   "carbon content of complex particulate COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS CarbonContentOfParticulateInertCOD
   "carbon content of particulate inert COD"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};
CLASS CarbonContentOfLipids
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mol/gCOD";
        :};

CLASS CarbonContentOfSugars
   "carbon content of particulate inert COD"
    SPECIALISES PhysicalQuantityType :=
       {:
        unit     <- "mol/gCOD";
        :};

 

CLASS NitrogenContentOfAminoAcids
   "Nitrogen content of amino acids (mole-N.g COD-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS NitrogenContentOfBiomass
   "Nitrogen content of  biomass (mole-N.g COD-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS NitrogenContentOfSolubleInertCOD
   "nitrogen content of Soluble inert (mole-N.g COD-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};
CLASS NitrogenContentOfParticulateDegradableCOD
   "nitrogen content of particulate degradable COD (mole-N.g COD-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

CLASS NitrogenContentOfParticulateInertCOD
   "nitrogen content of particulate inert COD (mole-N.g COD-1)"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "mol/gCOD";
    :};

 

CLASS pKa
   "A class for pKa"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "pKa";
    interval  <- {: lowerBound <- 0; upperBound <- 14 :};
   :};

CLASS Acidity
   "A class for Acidity"
   SPECIALISES PhysicalQuantityType :=
   {:
    quantity  <- "Acidity";
    unit     <- "M";
   :};

 

CLASS HydrogenInhibitoryConcentrationForFADegradingOrganisms
   "hydrogen inhibitory concentration for FA degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
   
CLASS HydrogenInhibitoryConcentrationForC4DegradingOrganisms
   "hydrogen inhibitory concentration for C4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS InhibitoryHydrogenConcentrationForPropionateDegradingOrganisms
   "inhibitory hydrogen concentration for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InhibitoryFreeAmmoniaConcentrationForAcetateDegradingOrganisms
   "inhibitory free ammonia concentration for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};

 

CLASS KineticConstantForCO2andHCO3AcidBaseReaction
   "kinetic constant for CO2-HCO3 acid-base reaction"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS DecayRateForAminoAcidDegradingOrganisms
   "decay rate for amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForAcetateDegradingOrganisms
   "decay rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForButyrateAndValerateDegradingOrganisms
   "decay rate for butyrate and valerate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForLongChainFattyAcidDegradingOrganisms
   "decay rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForHydrogenDegradingOrganisms
   "decay rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS DecayRateForPropionateDegradingOrganisms
   "decay rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS DecayRateForMonosaccharideDegradingOrganisms
   "decay rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ComplexParticulateDisintegrationFirstOrderConstant
   "complex particulate disintegration first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS CarbohydrateHydrolysisFirstOrderConstant
   "carbohydrate hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS LipidHydrolysisFirstOrderConstant
   "lipid hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS ProteinHydrolysisFirstOrderConstant
   "protein hydrolysis first order rate constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

 

CLASS GasLiquidTransferCoefficientForReactor
   "gas liquid transfer coefficient for reactor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
 

CLASS PhysChemRate 
   "Phiscal or chemical reaction rate"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "KMole.d-1";
   :};
 

CLASS MaximumUptakeRateAminoAcidDegradingOrganisms
   "maximum uptake rate amino acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForAcetateDegradingOrganisms
   "maximum uptake rate for acetate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForC4DegradingOrganisms
   "maximum uptake rate for c4 degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};
CLASS MaximumUptakeRateForLongChainFattyAcidDegradingOrganisms
   "maximum uptake rate for long chain fatty acid degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateFForHydrogenDegradingOrganisms
   "maximum uptake rate for hydrogen degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForPropionateDegradingOrganisms
   "maximum uptake rate for propionate degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS MaximumUptakeRateForMonosaccharideDegradingOrganisms
   "maximum uptake rate for monosaccharide degrading organisms"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "d-1";
   :};

CLASS HalfSaturationConstantForAminoAcidDegradation
   "half saturation constant for amino acid degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForAcetateDegradation
   "half saturation constant for acetate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForButyrateAndValerateDegradation
   "half saturation constant for butyrate and valerate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForLongChainFattyAcidsDegradation
   "half saturation constant for long chain fatty acids degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS HalfSaturationConstantForUptakeOfHydrogen
   "half saturation constant for uptake of hydrogen"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};
CLASS InorganicNitrogenConcentrationAtWhichGrowthCeases
   "inorganic nitrogen concentration at which growth ceases"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "M";
   :};
CLASS HalfSaturationConstantForPropionateDegradation
   "half saturation constant for propionate degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

CLASS HalfSaturationConstantForMonosaccharideDegradation
   "half saturation constant for monosaccharide degradation"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m3";
   :};

 

CLASS BarPressure
   "pressure "
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar";
   :};

CLASS GasLawConstant
   "Gas law constant"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "bar.M-1.K-1";
   :};

CLASS SolidsRetentionTimeInAdditionToHydraulicRetentionTime
   "solids retention time in addition to hydraulic retention time"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "K";
   :};

  

CLASS KgDensity
   "Water Density"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kg/m3";
   :};

CLASS KgCODConcentration
   "Concentration of COD components"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "kgCOD/m";
   :};

CLASS InhibitionFactor
   "Inhibition Factor"
   SPECIALISES PhysicalQuantityType :=
   {:
    unit     <- "_";
   :};

   CLASS ADMMass "A class for (kg, kmol) mass in the scope of ADM1"
   SPECIALISES PhysicalQuantityType := 
   {:
    quantity  <- "Mass";
    unit      <- "kg";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF; :};
   :};

   CLASS ADMConcentration "A class for (kg, kmol) concentration in the scope of ADM1"
   SPECIALISES PhysicalQuantityType :=
   {:
    nature <- "ACROSS";
    quantity <- "Concentration";
    unit <- "kg/m3";
    interval <- {: lowerBound <- 0; upperBound <- PLUS_INF :};
   :};
   
  
 
 

 
TYPE ADM1Components
  "The biological components considered in the ADM1 model"
  = ENUM { H2O_An, S_INN, S_IC, S_ch4, S_h2, S_aa, S_ac, S_bu, S_fa, S_Inert, S_pro, S_su, S_va, X_aa, X_ac, X_c, X_c4, X_ch, X_fa, X_h2, X_Inert, X_li, X_pr, X_pro, X_su, S_an, S_cat};

TYPE ADM1IonComponents
  "The ion components considered in the ADM1 model"
  = ENUM { S_ac_ion, S_bu_ion, S_pro_ion, S_va_ion, S_hco3_ion, S_nh3};

TYPE ADM1GasVesselComponents
  "The gaseous components considered in the ADM1 model in the gas phase"
  = ENUM { S_ch4_gas, S_co2_gas, S_h2_gas};
  
TYPE ADM1GasComponentsInliquid
    "The gaseous components considered in the ADM1 model dissolved in the liquid phase"
  = ENUM { S_ch4_liq, S_IC_liq, S_h2_liq};

  
  
  
  
  
  
 
 TYPE ADM1Reactions
  "The anaerobic reactions between biological components considered in the ADM1 model"
  = ENUM {decay_aa, decay_ac, decay_c4, decay_fa, decay_h2, decay_pro, decay_su,
  	dis, hyd_ch, hyd_li, hyd_pr,
	uptake_aa, uptake_ac, uptake_bu, uptake_fa, uptake_h2, uptake_pro, uptake_su, uptake_va, };

TYPE ADM1IonReactions
  "The equilibrium reactions between biological components considered in the ADM1 model"
  = ENUM {dissociation_va, dissociation_bu, dissociation_pro, dissociation_ac, hco3_co2, ammonia_production, };

TYPE ADM1GasTransfer
  "The anaerobic gas transfer considered in the ADM1 model"
  = ENUM {transfer_ch4, transfer_co2, transfer_h2, };

 
 
 

 
 
 
 

 

 OBJ NrOfADM1GasComponents "The number of anaerobic components considered in the gas"
  : Integer := Cardinality(ADM1GasVesselComponents);

OBJ NrOfADM1GasComponentsInliquid "The number of gaseous anaerobic components dissolved in the liquid"
  : Integer := Cardinality(ADM1GasComponentsInliquid);

 OBJ NrOfADM1Components "The number of anaerobic components considered in the ADM1 model"
  : Integer := Cardinality(ADM1Components);

OBJ NrOfADM1IonComponents "The number of anaerobic ion components considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonComponents);
  
 
 OBJ NrOfADM1Reactions "The number of anaerobic reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1Reactions);

OBJ NrOfADM1IonReactions "The number of anaerobic ion reactions considered in the ADM1 model"
  : Integer := Cardinality(ADM1IonReactions);

OBJ NrOfADM1GasTransfer "The number of anaerobic gas transfers considered in the ADM1 model"
  : Integer := Cardinality(ADM1GasTransfer);

CLASS ADM1GasOutFromTheADVessel "The variables which are passed between WWTP model building blocks here in concentrations"
  = PhysicalQuantityType[NrOfADM1GasComponents;];

CLASS ADM1MassVector "The mass of components in the reactor"
  = ADMMass[NrOfADM1Components;];		  

CLASS ADM1GasMassVector "The mass of gasses in the reactor"
  = ADMMass[NrOfADM1GasComponents;];		  
  
CLASS ADM1ConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1Components;];		  

CLASS ADM1IonConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1IonComponents;];		  

CLASS ADM1GasConcVector "The variables which are passed between WWTP model building blocks here in General concentrations"
  = ADMConcentration[NrOfADM1GasComponents;];		  

CLASS ADM1ConcTerminal "The variables which are passed between WWTP model building blocks here in General concentrations"
  = Concentration[NrOfADM1Components;];		  


CLASS InADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS OutADM1ConcTerminal SPECIALISES ADM1ConcTerminal;  
CLASS ADM1MassFluxVector = PhysicalQuantityType[NrOfADM1Components;];
CLASS ADM1GasMassFluxVector = PhysicalQuantityType[NrOfADM1GasComponents;];
CLASS ADM1IonConcentrationVector = PhysicalQuantityType[NrOfADM1IonComponents;];

 


# 17 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.ADM1.msl" 1
 


















# 749 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.ADM1.msl"



# 18 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.ADM1.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.transformers.ADM1.msl" 1
 


















# 795 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.transformers.ADM1.msl"


# 19 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.ADM1.msl" 2

# 56 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion_units.msl" 1
 


















# 276 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\anaerobic_digestion_unit/wwtp.base.anaerobic_digestion_units.msl"




 
# 57 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 1
 















 
 
 
 




CLASS DataTreatment "Data Treatment" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A general model for signal treatment";
    interface <-
    {
	 	OBJ u (* terminal = "in_1" *) "Signal input" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ y_M (* terminal = "out_1" *) "Output signal" : Real := {: causality <- "COUT" ; group <- "Measurement data" :};    
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
	state <-
    {
		OBJ signal (* hidden = "1" *) "Dummy variable to store the signal": Real ;
    };
	equations <-
    {
		 
		state.signal = interface.u ;  
    };
  :};

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.response_time.msl" 1
 














 
 
 
 
 




CLASS Response_Time
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding response time to a signal";
    parameters <-
    {
		OBJ T90 "Response time" : Time := {: value <- 0.00694444444444444 ; group <- "System" :};
		OBJ n "Order for the response time (2-8)" : Integer := {: value <- 2 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_response1 (* hidden = "1" *) "variable for 1st order response time output": Real ;
		OBJ signal_response2 (* hidden = "1" *) "variable for 2nd order response time output": Real ;
		OBJ signal_response3 (* hidden = "1" *) "variable for 3rd order response time output": Real ;
		OBJ signal_response4 (* hidden = "1" *) "variable for 4th order response time output": Real ;
		OBJ signal_response5 (* hidden = "1" *) "variable for 5th order response time output": Real ;
		OBJ signal_response6 (* hidden = "1" *) "variable for 6th order response time output": Real ;
		OBJ signal_response7 (* hidden = "1" *) "variable for 7th order response time output": Real ;
		OBJ signal_response8 (* hidden = "1" *) "variable for 8th order response time output": Real ;
		 
 		OBJ Tau "Time constant" : Time := {: value <- 0.00006944444444 ; group <- "System" :};  
    };
    initial <-
    {
		 
		 
		 
		state.Tau = IF (parameters.n==1) THEN parameters.T90/2.3247
			ELSE IF (parameters.n==2) THEN parameters.T90/3.89
				 ELSE IF (parameters.n==3) THEN parameters.T90/5.3336
				 	  ELSE IF (parameters.n==4) THEN parameters.T90/6.6902
					  	   ELSE IF (parameters.n==5) THEN parameters.T90/8.0031
						   		ELSE IF (parameters.n==6) THEN parameters.T90/9.2680
									 ELSE IF (parameters.n==7) THEN parameters.T90/10.5357
									 	  ELSE parameters.T90/11.7724;
		 
		 
		 
    };
    equations <-
    {
		 
		DERIV(state.signal_response1,[independent.t]) = -(1/state.Tau)*(state.signal_response1 - state.signal);
		DERIV(state.signal_response2,[independent.t]) = -(1/state.Tau)*(state.signal_response2 - state.signal_response1);
		DERIV(state.signal_response3,[independent.t]) = -(1/state.Tau)*(state.signal_response3 - state.signal_response2);
		DERIV(state.signal_response4,[independent.t]) = -(1/state.Tau)*(state.signal_response4 - state.signal_response3);
		DERIV(state.signal_response5,[independent.t]) = -(1/state.Tau)*(state.signal_response5 - state.signal_response4);
		DERIV(state.signal_response6,[independent.t]) = -(1/state.Tau)*(state.signal_response6 - state.signal_response5);
		DERIV(state.signal_response7,[independent.t]) = -(1/state.Tau)*(state.signal_response7 - state.signal_response6);
		DERIV(state.signal_response8,[independent.t]) = -(1/state.Tau)*(state.signal_response8 - state.signal_response7);
		
		interface.y_M = IF (parameters.n==1) THEN state.signal_response1
			ELSE IF (parameters.n==2) THEN state.signal_response2
				 ELSE IF (parameters.n==3) THEN state.signal_response3
				 	  ELSE IF (parameters.n==4)	THEN state.signal_response4
					  	   ELSE IF (parameters.n==5) THEN state.signal_response5
						   		ELSE IF (parameters.n==6) THEN state.signal_response6
									 ELSE IF (parameters.n==7) THEN state.signal_response7
									 	  ELSE state.signal_response8;
    };
  :};
  

# 49 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.delay.msl" 1
 














 
 
 
 
 




CLASS Delay
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding delay to a signal";
    parameters <-
    {
		OBJ t_Delay "Delay time" : Time := {: value <- 0 ; group <- "System" :};
    };
    state <-
    {
		OBJ temp (* hidden = "1" *) "dummy variable for initialisation" : Real ;
		OBJ ID (* hidden = "1" *) "dummy variable for buffer ID" : Integer ;
		OBJ Signal_Delay (* hidden = "1" *) "dummy variable for signal that is retrieved from buffer": Real ;
		OBJ Delta_t  "Time to get a value from the buffer" : Time:= {: group <- "System" :};
    };
    initial <-
    {
		 
		state.ID = MSLUBufferCreate(state.Signal_Delay, 0);
    };
    equations <-
    {
		 
		 
		 
		state.temp = MSLUBufferPut(state.ID, independent.t, state.signal);
		state.Delta_t = independent.t - parameters.t_Delay;
		state.Signal_Delay = MSLUBufferGet(state.ID,state.Delta_t);
		interface.y_M = state.Signal_Delay ;   
    };
  :};
  

# 50 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.noise.msl" 1
 















 
 
 
 




CLASS Noise
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal, using random values sampled from a normal distribution";
    parameters <-
    {
		OBJ Percent_YMax "Percentage of the measuring range to define the standard deviation of the noise (%)" : Real := {: value <- 2.5 ; group <- "System" :};
		OBJ Noise_Sample_Time "Noise sampling interval": Time := {: value <- 0.000694444444444 ; group <- "System" :};
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
    };
    state <-
    {
		OBJ signal_noise (* hidden = "1" *) "Dummy variable to store the noisy signal": Real:= {: group <- "System" :};
		OBJ Noise "Random number sampled from Normal Distribution N(0,1)" : Real:= {: group <- "System" :};
		OBJ rand "Random number in the range [0,1[ sampled from Uniform distribution" : Real:= {: group <- "System" :};
		OBJ prev_nst (* hidden = "1" *) "Previous noise sampling time" : Real ;
		OBJ flag_noise (* hidden = "1" *)"Boolean variable related to a timer": Boolean ;
		OBJ Noise_Level "Noise level (Std Dev of the noise signal)" : Real := {: group <- "System" :};
    };
    initial <-
    {
		state.prev_nst = 0;
		 
		state.Noise_Level = parameters.Percent_YMax/100 * parameters.YMax;
    };
    equations <-
    {
		 
		 
		state.flag_noise = IF (independent.t > (previous(state.prev_nst) + parameters.Noise_Sample_Time)) THEN 1
			ELSE 0 ;

		state.rand = IF (state.flag_noise) THEN MSLUGetRandom()
			ELSE IF (independent.t == 0) THEN MSLUGetRandom()
				 ELSE previous(state.rand) ;

		state.prev_nst = IF (state.flag_noise) THEN previous(state.prev_nst) + parameters.Noise_Sample_Time
			ELSE previous(state.prev_nst) ;

		 
		 
		state.Noise = MSLU_normal_cdf_inv(state.rand,0,1);
		
		 
		interface.y_M = state.Noise*state.Noise_Level+state.signal ;
    };
    
  :};
  

# 51 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.noise_file.msl" 1
 














 
 
 
 
 




CLASS Noise_File
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding noise to a signal using an input file";
    interface <-
    {
		OBJ u_file (* terminal = "in_2" *) "Signal input for noise file" : Real := {: causality <- "CIN" ; group <- "Measurement data" :};  
    };
    parameters <-
    {
		OBJ YMax "Maximum measuring range" : Real := {: value <- 10 ; group <- "System" :};
		OBJ Noise_Percent "Noise level (%)" : Real := {: value <- 2.5 ; group <- "System" :};  
    };
    state <-
    {
		OBJ Noise_Level "Noise level" : Real:= {: group <- "System" :};
    };
    initial <-
    {
		state.Noise_Level = parameters.Noise_Percent/100 * parameters.YMax ;
    };
    equations <-
    {
		interface.y_M = interface.u_file*state.Noise_Level + state.signal ; 
    };
  :};
  

# 52 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.sample_and_hold.msl" 1
 














 
 
 
 
 




CLASS Sample_and_Hold
  (* icon = "data_treatment" ; is_default = "true" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for obtaining discrete signal: Zero Order Hold. Sample and Hold (SAH)";
    parameters <-
    {
		OBJ T_interval "Sampling interval": Time := {: value <- 0.00347222222222 ; group <- "System" :};  
    };
    state <-
    {
		OBJ signal_SAH (* hidden = "1" *) "dummy variable for concentration of sample and hold": Real ;
		OBJ prev_SAHst (* hidden = "1" *) "previous SAH sampling time" : Real ;
		OBJ flag_SAH (* hidden = "1" *) "flag for the sampling time": Boolean ;
    };
    initial <-
    {
		state.prev_SAHst = 0;
		state.flag_SAH = 0;
		state.signal_SAH= 0;  
    };
    equations <-
    {
		 
		state.prev_SAHst = IF (independent.t - previous(state.prev_SAHst) <= (parameters.T_interval)) THEN  previous(state.prev_SAHst)
			ELSE  previous(state.prev_SAHst) + parameters.T_interval;   

		state.flag_SAH = IF  (state.prev_SAHst != previous(state.prev_SAHst)) THEN  1
			ELSE  0;    
  
		 
		state.signal_SAH = IF (state.flag_SAH) THEN previous(state.signal)
			ELSE IF (independent.t == 0) THEN previous(state.signal)
				 ELSE previous(state.signal_SAH) ;
      
		 
		interface.y_M = state.signal_SAH ;
    };
  :};
  

# 53 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\data_treatment/wwtp.base.datatreatment.saturation_range.msl" 1
 














 
 
 
 
 




CLASS Saturation_Range
  (* icon = "data_treatment" *)
  "Data Treatment"
  EXTENDS DataTreatment WITH 
  {:
    comments <- "A model for adding saturation to the signal";
    parameters <-
    {
		OBJ uMin "Minimum level for the signal" : Real := {: value <- 0 ; group <- "System" :};
		OBJ uMax "Minimum level for the signal" : Real := {: value <- 10 ; group <- "System" :};
    };
    equations <-
    {
		interface.u = IF (state.signal < parameters.uMin) THEN parameters.uMin
			ELSE IF (state.signal > parameters.uMax) THEN parameters.uMax
				 ELSE state.signal ;
    };
  :};
  

# 54 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.base.data_treatment.msl" 2

  
  


# 60 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.aeration.msl" 1
 


















# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\aeration/wwtp.irvine_carbon_footprint.msl" 1
 














 
 
 




   
   
CLASS Irvine_wCarbon_Footprint
  (* icon = "aerator" ; is_default = "true" *)
  "Irvine aeration model with carbon footprint" SPECIALISES PhysicalDAEModelType :=
  {:
    comments <- "A model that computes the Kla based on airflow rate, aerator design and other parameters";
    interface <-
    {
		OBJ O2_tank (* terminal = "in_1" *) "Actual oxygen concentration in the aeration tank" : Concentration := {: causality <- "CIN" ; group <- "Measurement data" :};
		OBJ Vol_tank (* terminal = "in_1" *) "Volume of the aeration tank" : Volume := {: causality <- "CIN" ; group <- "Measurement data" :};
	  OBJ Q_air (* terminal = "in_1" *) "Air flow rate under Standard Conditions": FlowRate := {: causality <- "CIN" ; group <- "Operational" :};
		OBJ SRT (* terminal = "in_2"; manip = "1"; is_favorite = "1" *) "Sludge age" : Time := {: causality <- "CIN" ; value <- 6.5 ; group <- "Operational" :};   
		OBJ Kla (* terminal = "out_1" *) "Oxygen Transfer Coefficient" : OxygenTransferCoefficient := {: causality <- "COUT" ; group <- "Control action" :};
		OBJ O2_rsat_ave (* terminal = "out_1" *) "Average oxygen saturation f(T_water; Depth) for fine bubble aeration" : Concentration := {: causality <- "COUT" ; group <- "Control action" :};
 






    };
    parameters <- 
    {
		OBJ g (* hidden = "1" *) "Gravity acceleration on earth (m/s2)": Real := {: value <- 9.82 :};
		OBJ T_water "Temperature of the water": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ T_air "Temperature of the air": CelsiusTemperature := {: value <- 15.0 ; group <- "Operational" :};
		OBJ H "Altitude": Length := {: value <- 10 ; group <- "Operational" :};
		OBJ Rho_air "Air density": Concentration := {: value <- 1230 ; group <- "Operational" :};
		OBJ O2_sat20 "Oxygen saturation of water under Standard Conditions and no salts": Concentration := {: value <- 10.50 ; group <- "Operational" :};
		OBJ SOTE "Standard Oxygen Transfer Efficiency (%)": Real := {: value <- 42 ; group <- "Operational"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Rho_sludge "Sludge density": Concentration := {: value <- 988000 ; group <- "Sludge" :};
		OBJ Beta "Empirical factor": Real := {: value <- 0.98 ; group <- "Sludge" :};
		OBJ Phi "Empirical factor": Real := {: value <- 1.024 ; group <- "Sludge" :};

		OBJ P_atm "Atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_st_atm "Standard atmospheric pressure": Pressure := {: value <- 101325; group <- "Local conditions" :};
		OBJ P_water_ref "Vapour pressure": Pressure := {: value <- 2334; group <- "Local conditions" :};
		OBJ O2_air "O2 conc. in the atmosphere (%)": Real := {: value <- 20.85 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ CO2_air "CO2 conc. in the atmosphere (%)": Real := {: value <- 0.03 ; group <- "Local conditions"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};

		OBJ Depth "Depth of the (fine bubble) aerator": Length := {: value <- 6 ; group <- "Tank geometry" :};
		OBJ A_sp "Specific area of the diffusers": Area := {: value <- 2 ; group <- "Tank geometry" :};
		OBJ Nd "Number of diffusers": Real := {: value <- 504 ; group <- "Tank geometry"; interval <- {: lowerBound <- 0; upperBound <- PLUS_INF; :}; :};
		
		OBJ A "Empirical factor": Real := {: value <- 5.717 ; group <- "Aeration model" :};
		OBJ B "Empirical factor": Real := {: value <- 6.815 ; group <- "Aeration model" :};
		OBJ f "Fraction of tank depth (from surface) at which pressure corresponds to the average saturation concentration": Real := {: value <- 0.44 ; group <- "Aeration model" :};
 




		 
		OBJ P_out "Output pressure from the blowers": Pressure := {: value <- 80000; group <- "Power consumption" :};
		OBJ Lambda "Empirical constant for air": Real := {: value <- 1.395 ; group <- "Power consumption" :};
		OBJ Epsilon "Efficiency of the motor": Real := {: value <- 0.58 ; group <- "Power consumption"; interval <- {: lowerBound <- 0; upperBound <- 1; :}; :};
		OBJ fCO2 "CO2 production per unit of energy (kg/kWh)": Real := {: value <- 0.718 ; group <- "Power consumption" :};
		OBJ T_in "Inlet temperature": CelsiusTemperature := {: value <- 20 ; group <- "Power consumption" :};
    };
    independent <- 
    {
		OBJ t "Time" : Time := {: group <- "Time" :}; 
    };
    state <- 
    {
		OBJ P_water "Vapour pressure": Pressure := {: group <- "Local conditions" :};
		OBJ O2_rsat "Oxygen saturation at the water temperature": Concentration := {: group <- "Local conditions" :};
 
		
 

		OBJ Alpha "Empirical factor ": Real := {: group <- "Operational" :};
		
		OBJ AlphaSOTE "Oxygen transfer efficiency for new aerators": Real := {: group <- "Aeration" :};
		OBJ SOTR "Standard Oxygen Transfer Rate": MassFlux := {: group <- "Aeration" :};
		OBJ OTR "Oxygen Transfer Rate (under field conditions)": MassFlux := {: group <- "Aeration" :};
		OBJ OTR_sp "Specific Oxygen Transfer Rate": OxygenUptakeRate := {: group <- "Aeration" :};
		OBJ OTE "Oxygen Transfer Efficiency (under field conditions) (%)": Real := {: group <- "Aeration"; interval <- {: lowerBound <- 0; upperBound <- 100; :}; :};
		OBJ MRi "Mole ratio of oxygen that enters air and off gas (%)": Real := {: group <- "Aeration" :};
		OBJ MRe "Mole ratio of oxygen that leaves aeration tank (%)": Real := {: group <- "Aeration" :};
		OBJ Qn "Normalized air flow": Real := {: group <- "Aeration" :};

		OBJ P_bottom "Pressure at the bottom of the tank": Pressure := {: group <- "Site" :};

		 
		OBJ Load_CO2 "CO2 production": MassFlux := {: group <- "Power consumption" :};
		OBJ Power_blowers "Power of the blowers" : Power := {: group <- "Power consumption" :};
		OBJ k "Power usage per cubic meter of air blown (kW/(m3/s))": Real := {: group <- "Power consumption" :};
		OBJ Emission_CO2 "Overall CO2 emission" : Mass := {: group <- "Power consumption" :} ;
		OBJ Consumption "Overall electrical energy (kWh)" : ElectricalEnergy := {: group <- "Power consumption" :} ;
		OBJ Chi (* hidden = "1" *) "Characteristic number": Real ;
		OBJ lgChi (* hidden = "1" *) "Characteristic number": Real ;
    };
    equations <- 
    {
		 
 
		state.Qn = interface.Q_air / (24*3600*(parameters.A_sp * parameters.Nd * parameters.Depth)) ;
		state.Chi = IF (state.Qn == 0.0) THEN 0.0 ELSE interface.SRT/state.Qn ;
		state.lgChi = IF (state.Chi == 0.0) THEN 0.0 ELSE log10(state.Chi) ;
	
		state.AlphaSOTE = IF (state.Chi == 0.0) THEN 0.0 ELSE (parameters.A * log10(state.Chi) - parameters.B)/100 ;
		state.Alpha = state.AlphaSOTE / parameters.SOTE * 100 ;

		 
		state.MRi = parameters.O2_air/(100 - parameters.O2_air - parameters.CO2_air);
		state.MRe =  state.MRi*(1-state.OTE);
 
		state.OTE = state.AlphaSOTE *
			(parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) / parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));

		 
		state.P_bottom = (parameters.Rho_sludge/1000) * parameters.g * parameters.Depth;
		state.P_water = pow(10, 0.6979 + 0.02618 * parameters.T_air)* 133.33;
		state.O2_rsat = 14.65 - 0.41 * (parameters.T_water) + 0.00799 * pow(parameters.T_water,2) - 0.0000778 * pow(parameters.T_water,3);
 
 
		interface.O2_rsat_ave = parameters.O2_sat20 * (state.P_bottom * parameters.f + parameters.P_atm - state.P_water)/ (parameters.P_st_atm - parameters.P_water_ref);

		 
		state.SOTR =  interface.Q_air * (parameters.Rho_air/1000)  * parameters.SOTE * (parameters.O2_air/10000);
 
		state.OTR = state.Alpha * state.SOTR * (parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) /parameters.O2_sat20 * pow(parameters.Phi,(parameters.T_water-20));
		interface.Kla = 1000 * state.OTR/((parameters.Beta * interface.O2_rsat_ave - interface.O2_tank) * interface.Vol_tank);
		state.OTR_sp = state.OTR /(interface.Vol_tank);
		
		 
		state.k = (parameters.P_st_atm * parameters.Lambda * (parameters.T_in + 273.15)) / (2.73 * 100000 * parameters.Epsilon * (parameters.Lambda - 1)) * (pow((parameters.P_out + parameters.P_st_atm)/parameters.P_st_atm,1-1/parameters.Lambda)-1);
		state.Power_blowers = state.k * interface.Q_air/(24*3600);
		state.Load_CO2 = state.Power_blowers * parameters.fCO2 ;
		DERIV(state.Consumption, [independent.t]) = 24 * state.Power_blowers ;
		DERIV(state.Emission_CO2, [independent.t]) = state.Load_CO2 ;
    };

  :};


# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.aeration.msl" 2

 


# 61 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2

 
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\coupled_models.msl" 1
 



















# 64 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\wwtp.msl" 2


# 18 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 1





# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.quantity.msl" 1



 TYPE HourlyTimeVector = ENUM {H00, H01, H02, H03, H04, H05, H06, H07,
                               H08, H09, H10, H11, H12, H13, H14, H15, 
                               H16, H17, H18, H19, H20, H21, H22, H23};

 TYPE WeeklyTimeVector = ENUM {D1, D2, D3, D4, D5, D6, D7};
 
 TYPE YearlyTimeVector = ENUM {M01, M02, M03, M04, M05, M06, M07, M08, M09,
 	  				   	 	   M10, M11, M12};                        
 
 TYPE TwoHourlyTimeVector = 
       ENUM {T00, T02, T04, T06, T08, T10, T12, T14, T16, T18, T20,T22};

 TYPE KosimData = ENUM {Rain, Evaporation};


  CLASS Rainfall
  "A class for rainfall during Kosim simulations (mm)"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Rainfall depth";
    unit      <- "mm";
    interval  <- {: lowerBound <- MINUS_INF; upperBound <- PLUS_INF:};
  :};    
  
  CLASS Minutes
  "A class for time in minutes"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Time";
    unit      <- "min";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};    

  CLASS RainfallIntensity
  "A class for rainfall intensity during Kosim simulations (mm/d)"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Rainfall Intensity";
    unit      <- "mm/d";
    interval  <- {: lowerBound <- MINUS_INF; upperBound <- PLUS_INF:};
  :};    

CLASS PopDensity 			   	  	 			   			  
  "A class for the density of inhabitants"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Population Density";
    unit      <- "IE/km2";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};    
  
CLASS WaterVolume 			   	  	 			   			  
  "A class for the volume of water per area per year"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Water Volume";
    unit      <- "m3/ha/a";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};    
         
CLASS PollutionMass		   	  	 			   			  
  "A class for the pollution element mass per area per year"
  SPECIALISES PhysicalQuantityType :=
  {:
    quantity  <- "Pollution Mass";
    unit      <- "kg/ha/a";
    interval  <- {: lowerBound <- 0; upperBound <- PLUS_INF:};
  :};    
		                 
 OBJ NrOfTwoHourlyTimeVectorElements : 
      Integer := Cardinality(TwoHourlyTimeVector);

 CLASS TwoHourlyDailyPattern "Daily pattern" =
        Real[NrOfTwoHourlyTimeVectorElements;];


 OBJ NrOfHourlyTimeVectorElements : 
      Integer := Cardinality(HourlyTimeVector);

 CLASS HourlyDailyPattern "Daily pattern" = 
        Real[NrOfHourlyTimeVectorElements;];

 OBJ NrOfMonthlyTimeVectorElements : 
      Integer := Cardinality(YearlyTimeVector);
	  
 CLASS MonthlyYearlyPattern "Monthly pattern" = 
        Real[NrOfMonthlyTimeVectorElements;];

  
 OBJ Time_Index : Integer;
 OBJ Month_Index : Integer;
 OBJ NrOfKosimDataElements : Integer := Cardinality(KosimData);

 CLASS KosimDataVector "Vector containing Kosim data necessary in all bassins" 
        = RainfallIntensity[NrOfKosimDataElements;];

  OBJ Pi
  "Pi" : PhysicalQuantityType :=
   {:
    quantity  <- "PI";
    unit      <- "-";
    value     <- 3.14159;
   :};





 



# 6 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.general.msl" 1




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  


 OBJ NrOfSewComponents
 "  The number of biological components considered in the sewer models "
 : Integer := Cardinality(SewComponents);
  





  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


 CLASS SewTerminal
  
  
  
  
 = MassFlux[NrOfSewComponents;]; 


  
  
  
  
  
  
  
  
  
  
  
  
  


 CLASS InSewTerminal SPECIALISES SewTerminal;  
 CLASS OutSewTerminal SPECIALISES SewTerminal;  

 CLASS SewConcTerminal 
   
   
   
   
  = Concentration[NrOfSewComponents;]; 

 CLASS InSewConcTerminal SPECIALISES SewConcTerminal;  
 CLASS OutSewConcTerminal SPECIALISES SewConcTerminal;  
 
  
  
  
  
 
 CLASS SewTerminalSurfaceFlux
 = ArealFluxHa[NrOfSewComponents;]; 

 TYPE SewerDataTerminalComponents
 "Components in sewer compartment data terminal"
 = ENUM {h_sewer, vh_sewer};

 
 

 OBJ NrOfSewerDataTerminalComponents
 "Components in sewer compartment data terminal"
 : Integer := Cardinality(SewerDataTerminalComponents);

 CLASS SewerDataTerminal
 "Data coming out of a sewer compartmentASU"
 = PhysicalQuantityType[NrOfSewerDataTerminalComponents;];


 
 
 

 
 
 

  
  
  
  

 OBJ s_comp_index "Temporary iteration variable" : Integer;
 OBJ p_comp_index "Temporary iteration variable" : Integer;
 OBJ s_reaction_index "Temporary iteration variable" : Integer;
 OBJ s_in_comp_index "Temporary iteration variable" : Integer;
 OBJ s_out_comp_index "Temporary iteration variable" : Integer;
 OBJ s_terminal "Temporary iteration variable" : SewTerminal;
 OBJ s_in_terminal "Temporary iteration variable" : SewTerminal;
 OBJ s_out_terminal "Temporary iteration variable" : SewTerminal;
 
 
 OBJ NrOfSewReactions
 "The number of reactions between biological components considered in the sewer models"
 : Integer := Cardinality(SewReactions);

 
CLASS SewSpecificVolumeVector = SpecificVolume[NrOfSewComponents;];
CLASS SewConcentrationVector = Concentration[NrOfSewComponents;];
CLASS SewMassVector = Mass[NrOfSewComponents;];
CLASS SewMassFluxVector = MassFlux[NrOfSewComponents;];
 





CLASS SewFractionVector = Real[NrOfSewComponents;];


 

# 7 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.definitions.msl" 1




TYPE SewComponents = ENUM {H2O_sew, NH4_sew, PO4_sew, COD_sol, X_TSS_sew, COD_part,};

TYPE SewReactions = ENUM {
		SewCOD_sol_removal, 
		SewPO4removal, 
		SewNH4removal,
		SewCOD_part_removal,
		};



	OBJ IndexOfFirstSolubleSewComponent
	"The index of the first soluble component in the components vector considered in the KOSIM models"
	: Integer := 2;


	OBJ IndexOfLastSolubleSewComponent
	"The index of the last soluble component in the components vector considered in the KOSIM models"
	: Integer := 4;



	OBJ IndexOfFirstParticulateSewComponent
	"The index of the first particulate component in the components vector considered in the KOSIM models"
	: Integer := 5;


	OBJ IndexOfLastParticulateSewComponent
	"The index of the last particulate component in the components vector considered in the KOSIM models"
	: Integer := 6;
	




# 8 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.base.msl" 1




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  



 


 
 
 

 
 
 


 
 
 


 CLASS SewerAtomicModel
 
   








 SPECIALISES PhysicalDAEModelType :=
 {:
  
  parameters <-
   {

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

     
     
     
     
   




    
     
     
     
     
     
     
     
     
     

   };

  independent <- { OBJ t : Time; };

  state <-
   {
    OBJ SewM (* hidden = "0" *) : SewMassVector := [{:value <-1000000 :}, 
	   {:value <- 30 :}, {:value <- 10 :}, {:value <- 100 :}, 
	   {:value <- 200 :}, {:value <- 150 :};];
    OBJ FluxPerSewComponent (* hidden = "0" *) : SewMassFluxVector;
    OBJ inFluxPerSewComponent (* hidden = "0" *) : SewMassFluxVector;
    OBJ conversionTermPerSewComponent (*hidden = "0" *): SewMassFluxVector;
    OBJ Q_i "Influent flow rate" : FlowRate;

   };

  initial <-
   {
    
   };

  equations <-
   {
     
     

    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      state.FluxPerSewComponent[s_comp_index] =

     
     
     
     
     

    state.inFluxPerSewComponent[s_comp_index]+
    (SUMOVER s_out_terminal IN {SelectByType(interface,OutSewTerminal)}:
    s_out_terminal[s_comp_index]);};

     
     
     
     

    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      DERIV(state.SewM[s_comp_index],[independent.t]) = 
      state.FluxPerSewComponent[s_comp_index]
      + state.conversionTermPerSewComponent[s_comp_index];};

     
     
    
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      state.inFluxPerSewComponent[s_comp_index] =
         SUMOVER s_in_terminal IN {SelectByType(interface,InSewTerminal)}:
            (s_in_terminal[s_comp_index]);
    };

    {state.Q_i = (0.000001 
                  * state.inFluxPerSewComponent[H2O_sew]);
    };

  
  
   

   }; 
 :};

 

 
 
 
 
 
 


CLASS SewerAtomicModelWithoutVolume 
 SPECIALISES PhysicalDAEModelType :=
 {:
  parameters <-
   {
     


   };

  initial <-
   {
    
   };

  independent <- { OBJ t "Time" : Time; };

  state <-
   {
    OBJ inFluxPerSewComponent (* hidden = "0" *) "Vector containing incoming fluxes for all components" : SewMassFluxVector;
    OBJ Q_i "Influent flow rate" : FlowRate ;
   };

   equations <-
   {
     { FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
        state.inFluxPerSewComponent[s_comp_index] =
         SUMOVER In_Terminal IN {SelectByType(interface,InSewTerminal)}:
         (In_Terminal[s_comp_index]);
     };

     {state.Q_i = (0.000001
                  * state.inFluxPerSewComponent[H2O_sew]);
     };

   };
 :};


 
 
 


 CLASS SewerAtomicModelWithVolume EXTENDS SewerAtomicModel WITH
 {:
   interface <-
   {
		};


   parameters <-
    {    
    };

   state <-

   {
         OBJ WaterLevel "Water level inside the tank" : Length ;

      OBJ V : Volume;
      OBJ SewC : SewConcentrationVector ;
      OBJ Q_Out "Effluent flow rate" : FlowRate;	  
    };

   equations <-
    {
    };

 
 

 :};
  
CLASS KosimTank_runoff
  (* class = "pipe"; category = "" *)
  "A buffertank with linear outflow equation" 
  
  
  EXTENDS SewerAtomicModelWithVolume WITH
  {:
   interface <-
    {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
        InSewTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
        OutSewTerminal := {: causality <- "COUT" :};
    };
    initial <-
    {
    };
   parameters <-
   {
     OBJ k "reservoir constant" : Time := {:value <- 0.005787 ; group <- "Hydraulic":};
 	   OBJ m "exponent (1 corresponds to linearity)" : Real := {:value <- 1 ; group <- "Hydraulic" :};
 	   OBJ k_fact "factor for sensitivity analysis" : Real := {:value <- 1 ; group <- "Hydraulic" :};
     OBJ Vmin (*hidden = "0" *) "Minimum volume of the tank, to avoid problems with to low numbers" : Volume := {: value <- 1 ; group <- "Hydraulic":};
   };
 
   state <-
    {
    };
 
   equations <-
    {
    state.V = 0.000001*state.SewM[H2O_sew];
    state.Q_Out =  IF (state.V < parameters.Vmin)
                   THEN 0
                   ELSE pow(state.V/(parameters.k*parameters.k_fact),1/parameters.m);
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
      state.SewC[s_comp_index] = state.SewM[s_comp_index]/state.V;};
    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
       interface.Outflow[s_comp_index] =
        - state.SewC[s_comp_index] * state.Q_Out ;};
 
    };
  :};
			 
 CLASS SewRetentionVolume
 (* class = ""; category = "" *)
 "Retention volume of the system"
 EXTENDS SewerAtomicModelWithVolume WITH
 {:
  
  interface <-
   {
     OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
       InSewTerminal := {: causality <- "CIN" :};
      OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : 
         OutSewTerminal := {: causality <- "COUT" :};
    OBJ Outflow2 (* terminal = "out_2" *) "Outflow2" : 
         OutSewTerminal := {: causality <- "COUT" :};
   };

  parameters <-
   {
     OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 10 :};
     OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ D_Max "Maximum depth of the tank" : Length := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ Cd "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Real := {: group <- "Tank characteristics"; value <- 0.85 :};
	 OBJ B "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Length := {: group <- "Tank characteristics"; value <- 20 :};
	 OBJ Surf "Surface of the tank" : Area := {: group <- "Tank characteristics" :};
   };
   
   initial <-
   {
     parameters.Surf = parameters.V_Max / parameters.D_Max;
   };

  state <-
   {
  
	 OBJ Q_over "Overflow Rate" : FlowRate;
	 OBJ Du "Height above weir crest" : Length;
   };

  equations <-
   {
   
    state.Du = (state.V-parameters.V_Max) / parameters.Surf;
   
    interface.Outflow1[H2O_sew] = - state.Q_Out / 0.000001 ; 
	interface.Outflow2[H2O_sew] = - state.Q_over / 0.000001 ;
    state.V = state.SewM[H2O_sew] *0.000001;
					
	state.Q_over = IF (state.V <= parameters.V_Max)
				   THEN 0
				   ELSE parameters.Cd * pow(9.81,0.5) * parameters.B * pow(state.Du,1.5) * 3600 * 24;

    {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
     		  state.SewC[s_comp_index] = IF (state.V == 0)
			   			       		   	 THEN 0 
							  			 ELSE state.SewM[s_comp_index] / state.V ;};
										    	 
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow1[s_comp_index] = 
      		- state.SewC[s_comp_index] * state.Q_Out;};
	  
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow2[s_comp_index] = 
	  		- state.SewC[s_comp_index] * state.Q_over ;};
			
	    
   };
   
 :};
			 
CLASS SewRetentionVolume_P
 (* class = "retention_basin"; category = "" *)
 "Retention volume of the system, pumped outflow + overflow"
 EXTENDS SewRetentionVolume WITH
 {:

  parameters <-
   {
     OBJ Q_Pump "Maximum effluent flow rate" : FlowRate := {: group <- "Tank characteristics" :};
	 OBJ f_on "Fraction of volume above which Qout=Qpump" : Fraction := {: group <- "Tank characteristics"; value <- 0.01 :};
	 OBJ energy_cost "Energy cost, in EUR/kWh" : Real := {: value <- 0.12 ; group <- "Power consumption" :};
	 OBJ energy_pumpingvol "Energy for pumping, in kWh/m3" : Real := {: value <- 0.09 ; group <- "Power consumption" :};
   };

  state <-
   {
	 OBJ Q_Out_int "Integral of Q_Out" : Volume;
	 OBJ energy_pumping "Energy consumption for pumping, integral" : ElectricalEnergy := {: group <- "Power consumption" :};
	 OBJ cost_pumping "Cost for pumping in EUR, integral" : Real := {: group <- "Power consumption" :};
   };

  equations <-
   {
    state.Q_Out = IF (state.V < parameters.V_Min) 
                THEN 0
                ELSE  
                  IF ((state.Q_i > parameters.Q_Pump) || (state.V >= parameters.V_Max * parameters.f_on))
                  THEN parameters.Q_Pump
                  ELSE state.Q_i ;    
			
	    DERIV(state.Q_Out_int,[independent.t])= state.Q_Out;
		state.energy_pumping = state.Q_Out_int * parameters.energy_pumpingvol;
		state.cost_pumping = state.energy_pumping * parameters.energy_cost;
		
   };
	 
	 :};
	 
CLASS SewRetentionVolume_FF
 (* class = "retention_basin"; category = "" *)
 "Retention volume of the system, free flow outflow"
 EXTENDS SewRetentionVolume WITH
 {:

  parameters <-
   {
	 OBJ PipeDiameter "diameter of the connected (circular) pipe downstream" : Length :=
  	  {: value <- 0.6 ; group <- "Tank characteristics" :};
     OBJ c_o "throttle coefficient (1=total cross-section)" : Real := {: value <- 1 ; group <- "Tank characteristics" :};
	 OBJ Q_max "Max outflow" : FlowRate := {: group <- "Tank characteristics" :};
   };

  state <-
   {
	 OBJ Q_Out_help (*hidden = "1" *) "Actual effluent flow rate" : FlowRate ;
	 
   };

  equations <-
   { 
	state.WaterLevel = state.V / parameters.Surf;
    state.Q_Out_help = IF (state.V < parameters.V_Min) 
                       THEN 0
                       ELSE IF (state.WaterLevel >= parameters.PipeDiameter)
					        THEN sqrt(2 * state.WaterLevel * 9.81) * 86400 * 0.785 *
					  	         parameters.PipeDiameter * parameters.PipeDiameter	* parameters.c_o
					        ELSE sqrt(2 * state.WaterLevel * 9.81) * 86400  * 0.785 *
					  	         parameters.PipeDiameter * state.WaterLevel * parameters.c_o;    
						  
	state.Q_Out = IF (state.Q_Out_help < parameters.Q_max) 
                  THEN state.Q_Out_help
                  ELSE parameters.Q_max;	    
   };
   
 :};
			 
CLASS  TwoTankCascade_runoff
 (* class = "pipe" *)
 SPECIALISES CoupledModelType :=
 {:
  interface <-
  {
   OBJ Inflow1 (* terminal = "in_1" *) "Inflow1" : InSewTerminal := {:causality <- CIN:},
   OBJ Outflow1 (* terminal = "out_1" *) "Outflow1" : OutSewTerminal := {:causality <- COUT:},
  };
 
  parameters <-
  {
  OBJ k "linear reservoir constant" : Time := {: value <- 0.005787; group <- "" :};
  OBJ m "exponent (1 corresponds to linearity)" : Real := {:value <- 1; group <- "":};
   
  };
 
  sub_models <-
  {
   OBJ Tank1 : KosimTank_runoff,
   OBJ Tank2 : KosimTank_runoff,
  };
 
  coupling <-
  {
   
  sub_models.Tank1.parameters.k.value := parameters.k.value,
  sub_models.Tank2.parameters.k.value := parameters.k.value,
  sub_models.Tank1.parameters.m.value := parameters.m.value,
  sub_models.Tank2.parameters.m.value := parameters.m.value,
   
   connect(interface.Inflow1, sub_models.Tank1.interface.Inflow),
   connect(sub_models.Tank1.interface.Outflow, sub_models.Tank2.interface.Inflow),
   connect(sub_models.Tank2.interface.Outflow, interface.Outflow1),
  };
 :};
			 
  CLASS  ThreeTankCascade_runoff
 (* class = "pipe" *)
 EXTENDS TwoTankCascade_runoff WITH
 {:
 
  interface <-
  {
   OBJ Outflow2 (* terminal = "out_1" *) "Outflow1" : OutSewTerminal := {:causality <- COUT:},
  };
 
  sub_models <-
  {
   OBJ Tank3 : KosimTank_runoff,
  };
 
  coupling <-
  {
   sub_models.Tank1.parameters.k.value := parameters.k.value,
   sub_models.Tank2.parameters.k.value := parameters.k.value,
   sub_models.Tank3.parameters.k.value := parameters.k.value,
   sub_models.Tank1.parameters.m.value := parameters.m.value,
   sub_models.Tank2.parameters.m.value := parameters.m.value,
   sub_models.Tank3.parameters.m.value := parameters.m.value,
   connect(sub_models.Tank2.interface.Outflow, sub_models.Tank3.interface.Inflow),
   connect(sub_models.Tank3.interface.Outflow, interface.Outflow2),
  };
 :};

CLASS LoopBreaker_sew
(* icon = "loop_breaker" *)
"An Explicit Implicit Algebraic Loop Breaker using previous"

SPECIALISES PhysicalDAEModelType :=
{:
  comments <- "A model for a loopbreaker with previous functions";
  interface <-
  {
   OBJ Inflow (* terminal = "in_1" *) "Inflow" :
        InSewTerminal := {: causality <- "CIN" ; group <- "Influent" :};
   OBJ Outflow (* terminal = "out_1" *) "Outflow" :
        OutSewTerminal := {: causality <- "COUT" ; group <- "Effluent" :};
  };

  independent <- 
  { 
   OBJ t "Time" : Time := {: group <- "Time" :}; 
  };

 parameters <-
 {
   
 };

 state <-
 {
  OBJ InFluxPerSewComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : SewMassFluxVector;
 };

 initial <-
 {
   { FOREACH s_comp_index IN {IndexOfSolvent .. NrOfSewComponents}:
      state.InFluxPerSewComponent[s_comp_index] = 0;
        
   };
 };

 equations <-
 {
   { FOREACH s_comp_index IN {IndexOfSolvent .. NrOfSewComponents}:
      state.InFluxPerSewComponent[s_comp_index] =
       SUMOVER In_Terminal IN {SelectByType(interface,InSewTerminal)}:
       (In_Terminal[s_comp_index]);
   };

  { FOREACH s_comp_index IN {IndexOfSolvent .. NrOfSewComponents}:
     interface.Outflow[s_comp_index] =
       - previous(state.InFluxPerSewComponent[s_comp_index]);
  };

 };

:};
   


 




# 9 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.sensors.msl" 1
 
 
 
 
 





CLASS SewSensor
  (* class = "" *)
  "sensor"
  SPECIALISES
  PhysicalDAEModelType :=
  {:
    interface <-
    {
      OBJ Inflow (* terminal = "in_1" *) "Inflow" : 
         InSewTerminal := {: causality <- "CIN" :};
      OBJ Outflow (* terminal = "out_1" *) "Outflow" : 
         OutSewTerminal := {: causality <- "COUT" :};
    };

    parameters <-
    {
   


    };

    independent <- 
    {
      OBJ t "Time": Time ;
    };

    state <-
    {
      OBJ InFluxPerSewComponent (* hidden = "0" *) "Vector containing incoming fluxes for all the components" : SewMassFluxVector;
      OBJ Q_In "Influent flow rate" : FlowRate ;
    };

  initial <-
   {
    
   };

    equations <-
    {
      {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
        state.InFluxPerSewComponent[s_comp_index] =
        SUMOVER s_in_terminal IN
        {SelectByType(interface,InSewTerminal)}:
        (s_in_terminal[s_comp_index]) ;};

      {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
        interface.Outflow[s_comp_index] =
        - state.InFluxPerSewComponent[s_comp_index] ;}; 

      {state.Q_In = 0.000001 * state.InFluxPerSewComponent[H2O_sew] ;};

    };
 :};
  
  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_sensors/sewer.sensors.flow.msl" 1
CLASS SewFlow

  (* icon = "Sensor" *)
  "sensor"
  EXTENDS SewSensor WITH 
  {:
    comments <- "A model for a sensor measuring the flow rate";

    interface <-
    {
      OBJ y_M (* terminal = "out_2" *) "Sensor measured output" :
         Real := {: causality <- "COUT"  :};
    };

    equations <-
    {
      {interface.y_M = state.Q_In ;};
    };
 :};
 
# 65 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.sensors.msl" 2

  
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_sensors/sewer.sensors.multi.msl" 1
CLASS ArrayBODCODN_Sew
 
   (* icon = "Sensor" *)
   "sensor"
   EXTENDS SewSensor WITH 
   {:
     comments <- "A model for a sensor measuring BOD, COD, TN, (TP), NH4 and NO3";
 
 	interface <-
     {
 	 OBJ Q (* terminal = "out_2" *)"measurement" :FlowRate:= {: causality <- "COUT" ; group <- "Measurement data" :};
	  OBJ COD (* terminal = "out_2" *) "COD" : ChemOxDemand := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ BOD5 (* terminal = "out_2" *) "BOD5" : BiolOxDemand := {: causality <- "COUT" ; group <- "Measurement data" :};
    OBJ TSS (* terminal = "out_2" *) "TSS" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
	  OBJ NH4 (* terminal = "out_2" *) "NH4" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
	  OBJ PO4 (* terminal = "out_2" *) "PO4" : Concentration := {: causality <- "COUT" ; group <- "Measurement data" :};
     };
 
 parameters <-
   {
    OBJ F_TSS_X_COD "Conversion factor TSS/COD particulate" : Real := {: value <- 0.75 ; group <- "Conversion factors" :};
    OBJ F_BOD5_S_COD "Conversion factor BOD5/COD soluble": Fraction := {: value <- 0.25 ; group <- "Conversion factors" :};
     };
 
 state <-
   {
   
   };
   
     equations <-
   {
    interface.Q = state.Q_In;
     
    interface.COD = IF (state.Q_In == 0)
    			   THEN 0
 			   ELSE
    			   (interface.Inflow[COD_sol] + interface.Inflow[COD_part]) / state.Q_In; 
 
    interface.BOD5 = parameters.F_BOD5_S_COD * interface.Inflow[COD_sol];
    interface.TSS  = parameters.F_TSS_X_COD * interface.Inflow[COD_part];
    
    interface.NH4  = IF (state.Q_In == 0)
    			   THEN 0
 			   ELSE
 			   interface.Inflow[NH4_sew] / state.Q_In;
			   
    interface.PO4  = IF (state.Q_In == 0)
    			   THEN 0
 			   ELSE
 			   interface.Inflow[PO4_sew] / state.Q_In;

   };
  :};  
# 66 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.sensors.msl" 2

# 10 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.tanks.msl" 1
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_tanks/sewer.tanks.pipe_tank.msl" 1
 CLASS Pipe_Tank
 (* icon = "Tank" *)
 "Retention volume of the system, free flow outflow + overflow, possibility to limit max flow"
 EXTENDS SewerAtomicModelWithVolume WITH
 {:
  
  interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {: causality <- "CIN" :};  
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ Overflow (* terminal = "out_2" *) "Overflow" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ Valveflow (* terminal = "out_2" *) "Flow from valve" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ FillingDegree (* terminal = "out_3" *) "Filling Degree" : Real := {: causality <- "COUT" :};
	  OBJ Q_out (* terminal = "out_3" *) "Outflow" : FlowRate := {: causality <- "COUT" :};
	  OBJ FillingDegreeIn (* terminal = "in_2" *) "Filling degree from downstream tank" : Real := {: causality <- "CIN" :};
	  OBJ Q_max (* terminal = "in_2"; manip = "1" *) "Max outflow if FD_In < FD_th (default)" : FlowRate := {: causality <- "CIN" :};
	  OBJ Q_pump (* terminal = "in_2"; manip = "1" *) "Pumped outflow, valid if pump=1" : FlowRate := {: causality <- "CIN" :};
	  OBJ Q_valve (* terminal = "in_2"; manip = "1" *) "Outflow from valve" : FlowRate := {: causality <- "CIN" :};
	   
   };

  parameters <-
   {
   OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 10 :};
   OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ Cd "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Real := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ B "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Length := {: group <- "Tank characteristics"; value <- 20 :};	 
	 OBJ PipeHeight "Final height of the pipe" : Length := {: value <- 0.6 ; group <- "Tank characteristics" :};
   OBJ c_o "throttle coefficient (1=total cross-section)" : Real := {: value <- 1 ; group <- "Control" :};
	 OBJ Q_max_lim "Max outflow if FD_In > FD_th" : FlowRate := {: group <- "Control" :};
	 OBJ pump "Pump active = 1, not active = 0" : Real := {: group <- "Control" :};
	 OBJ FD_th "Filling degree threshold for downstream tank (fraction 0 to 1, set it to >1 for never limiting)" : 
	 	 Real := {: value <- 2 ; group <- "Control" :};
   OBJ FD_th_int "Filling degree threshold for this tank (fraction 0 to 1, set it to >1 for never limiting)" : 
	 	 Real := {: value <- 0.8 ; group <- "Control" :};
	 OBJ f_on "Fraction of volume above which Qout=Qpump" : Fraction := {: group <- "Control"; value <- 0.05 :};
   };
   
  state <-
   {
  
	 OBJ Q_Out_help (*hidden = "0" *) "Actual effluent flow rate" : FlowRate ;
	 OBJ Q_pump_help (*hidden = "0" *) "Pumped effluent flow rate" : FlowRate ;
	 OBJ Q_over "Overflow Rate" : FlowRate;
	 OBJ Du "Height above weir crest" : Length;
	 OBJ Q_max_actual "Q_max actual (if no pumping)" : FlowRate;
	 OBJ FillingDegreeTank "Filling degree" : Real;
	  
   };

   
  equations <-
   {
   
  state.Du = (state.V - parameters.V_Max) / (parameters.V_Max / parameters.PipeHeight);
	state.FillingDegreeTank = state.V / parameters.V_Max;
	interface.FillingDegree = state.FillingDegreeTank;
   
  interface.Outflow[H2O_sew] = - state.Q_Out / 0.000001 ; 
	interface.Overflow[H2O_sew] = - state.Q_over / 0.000001 ;
	interface.Valveflow[H2O_sew] = - interface.Q_valve / 0.000001 ;
	interface.Q_out = state.Q_Out ;
  state.V = state.SewM[H2O_sew] * 0.000001;
	
	state.Q_max_actual = IF ((interface.FillingDegreeIn < parameters.FD_th) || (state.FillingDegreeTank > parameters.FD_th_int))
					   				  THEN interface.Q_max
						 				  ELSE parameters.Q_max_lim;

  state.Q_Out_help = IF (state.V < parameters.V_Min) 
                     THEN 0
                     ELSE sqrt(2 * parameters.PipeHeight * interface.FillingDegree * 9.81) * 86400 * 0.785 *
					  	         parameters.PipeHeight * parameters.PipeHeight * interface.FillingDegree * parameters.c_o;    
	
	state.Q_pump_help = IF (state.V < parameters.V_Min) 
                	  	THEN 0
                		  ELSE IF ((state.Q_i > interface.Q_pump) || (state.V >= parameters.V_Max * parameters.f_on))
                  			   THEN interface.Q_pump
                  			   ELSE state.Q_Out_help ;
				  
	state.Q_Out = IF (parameters.pump == 1)
				  		  THEN state.Q_pump_help
				 			 ELSE IF (state.Q_Out_help < state.Q_max_actual) 
                  	 THEN state.Q_Out_help
                 	  ELSE state.Q_max_actual;
					
	state.Q_over = IF (state.V <= parameters.V_Max)
				  		   THEN 0
				  			 ELSE parameters.Cd * pow(9.81,0.5) * parameters.B * pow(state.Du,1.5) * 3600 * 24;

   {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
     		  state.SewC[s_comp_index] = IF (state.V == 0)
			   			       		   	 		  THEN 0 
							  			 							 ELSE state.SewM[s_comp_index] / state.V ;};
										    	 
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow[s_comp_index] = 
      		- state.SewC[s_comp_index] * state.Q_Out;};
	  
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Overflow[s_comp_index] = 
	  		- state.SewC[s_comp_index] * state.Q_over ;};
			
	{FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Valveflow[s_comp_index] = 
	  		- state.SewC[s_comp_index] * interface.Q_valve ;};
			
	   
	    
   };
   
 :};
	 
	  CLASS Pipe_Tank_pump_curve
 (* icon = "Tank" *)
 "Retention volume of the system, free flow outflow + overflow, pumped outflow with series of pumps"
 EXTENDS SewerAtomicModelWithVolume WITH
 {:
  
  interface <-
   {
    OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {: causality <- "CIN" :};  
    OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutSewTerminal := {: causality <- "COUT" :};
    OBJ Overflow (* terminal = "out_2" *) "Overflow" : OutSewTerminal := {: causality <- "COUT" :};
     
    OBJ FillingDegree (* terminal = "out_3" *) "Filling Degree" : Real := {: causality <- "COUT" :};
	  OBJ Q_out (* terminal = "out_3" *) "Outflow" : FlowRate := {: causality <- "COUT" :};
	  OBJ FillingDegreeIn (* terminal = "in_2" *) "Filling degree from downstream tank" : Real := {: causality <- "CIN" :};
	  OBJ Q_max (* terminal = "in_2"; manip = "1" *) "Max outflow if FD_In < FD_th (default)" : FlowRate := {: causality <- "CIN" :};
	   
	   
	   
   };

  parameters <-
   {
   OBJ V_Max "Maximum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 10 :};
   OBJ V_Min "Minimum volume of the tank" : Volume := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ Cd "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Real := {: group <- "Tank characteristics"; value <- 1 :};
	 OBJ B "Overflow = Cd*(g^1/2)*B*(Du^3/2)" : Length := {: group <- "Tank characteristics"; value <- 20 :};	 
	 OBJ PipeHeight "Final height of the pipe" : Length := {: value <- 0.6 ; group <- "Tank characteristics" :};
   OBJ c_o "throttle coefficient (1=total cross-section)" : Real := {: value <- 1 ; group <- "Control" :};
	 OBJ Q_max_lim "Max outflow if FD_In > FD_th" : FlowRate := {: group <- "Control" :};
	 OBJ Q_pump1 "Q of pump 1" : FlowRate := {: group <- "Control" :};
	 OBJ Q_pump2 "Q of pump 2" : FlowRate := {: group <- "Control" :};
	 OBJ Q_pump3 "Q of pump 3" : FlowRate := {: group <- "Control" :};
	 OBJ Q_pump4 "Q of pump 4" : FlowRate := {: group <- "Control" :};
	  
	 OBJ FD_th "Filling degree threshold for downstream tank (fraction 0 to 1, set it to >1 for never limiting)" : 
	 	 Real := {: value <- 2 ; group <- "Control" :};
   OBJ FD_th_int "Filling degree threshold for this tank (fraction 0 to 1, set it to >1 for never limiting)" : 
	 	 Real := {: value <- 0.8 ; group <- "Control" :};
	 OBJ f_on1 "Fraction of volume above which Qout=Qpump1" : Fraction := {: group <- "Control"; value <- 0.05 :};
	 OBJ f_on2 "Fraction of volume above which Qout=Qpump2" : Fraction := {: group <- "Control"; value <- 0.05 :};
	 OBJ f_on3 "Fraction of volume above which Qout=Qpump3" : Fraction := {: group <- "Control"; value <- 0.05 :};
	 OBJ f_on4 "Fraction of volume above which Qout=Qpump4" : Fraction := {: group <- "Control"; value <- 0.05 :};
   };
   
  state <-
   {
  
	 OBJ Q_Out_help (*hidden = "0" *) "Actual effluent flow rate" : FlowRate ;
	  
	 OBJ Q_over "Overflow Rate" : FlowRate;
	 OBJ Du "Height above weir crest" : Length;
	 OBJ Q_max_actual "Q_max actual" : FlowRate;
	 OBJ FillingDegreeTank "Filling degree" : Real;
	  
   };

   
  equations <-
   {
   
  state.Du = (state.V - parameters.V_Max) / (parameters.V_Max / parameters.PipeHeight);
	state.FillingDegreeTank = state.V / parameters.V_Max;
	interface.FillingDegree = state.FillingDegreeTank;
   
  interface.Outflow[H2O_sew] = - state.Q_Out / 0.000001 ; 
	interface.Overflow[H2O_sew] = - state.Q_over / 0.000001 ;
	 
	interface.Q_out = state.Q_Out ;
  state.V = state.SewM[H2O_sew] * 0.000001;
	
	state.Q_max_actual = IF ((interface.FillingDegreeIn < parameters.FD_th) || (state.FillingDegreeTank > parameters.FD_th_int))
					   				  THEN interface.Q_max
						 				  ELSE parameters.Q_max_lim;

  state.Q_Out_help = IF (state.V < parameters.V_Min) 
                     THEN 0
                     ELSE IF (interface.FillingDegree <= parameters.f_on1)
													THEN sqrt(2 * parameters.PipeHeight * interface.FillingDegree * 9.81) * 86400 * 0.785 *
					  	         				parameters.PipeHeight * parameters.PipeHeight * interface.FillingDegree * parameters.c_o
													ELSE IF (interface.FillingDegree <= parameters.f_on2)
															 THEN parameters.Q_pump1
															 ELSE IF (interface.FillingDegree <= parameters.f_on3)
															 		 THEN parameters.Q_pump2
																		ELSE IF (interface.FillingDegree <= parameters.f_on4)
															 					THEN parameters.Q_pump2 + (interface.FillingDegree - parameters.f_on3) * (parameters.Q_pump3 - parameters.Q_pump2) / (parameters.f_on4 - parameters.f_on3)
																				 ELSE IF (interface.FillingDegree <= 1)
															 							 THEN parameters.Q_pump3 + (interface.FillingDegree - parameters.f_on4) * (parameters.Q_pump4 - parameters.Q_pump3) / (1 - parameters.f_on4)
																				 		 ELSE parameters.Q_pump4;    
	
	 




				  
	state.Q_Out = IF (state.Q_Out_help < state.Q_max_actual) 
                THEN state.Q_Out_help
                ELSE state.Q_max_actual;
					
	state.Q_over = IF (state.V <= parameters.V_Max)
				  		   THEN 0
				  			 ELSE parameters.Cd * pow(9.81,0.5) * parameters.B * pow(state.Du,1.5) * 3600 * 24;

   {FOREACH s_comp_index IN {1 .. NrOfSewComponents}:
     		  state.SewC[s_comp_index] = IF (state.V == 0)
			   			       		   	 		  THEN 0 
							  			 							 ELSE state.SewM[s_comp_index] / state.V ;};
										    	 
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Outflow[s_comp_index] = 
      		- state.SewC[s_comp_index] * state.Q_Out;};
	  
	 {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
      interface.Overflow[s_comp_index] = 
	  		- state.SewC[s_comp_index] * state.Q_over ;};
			
 


			
	   
	    
   };
   
 :};
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.tanks.msl" 2

# 11 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.generators.msl" 1
CLASS SewGenerator
 (* class = ""; category = "" *)
  


 "A generator model"
 SPECIALISES PhysicalDAEModelType :=
 {:
  interface <-
  {
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutSewTerminal := {: causality <- "COUT" :};
  };

  parameters <-
  {
   OBJ Mean_S "Vector containing the mean concentration in DWF" :
       SewConcentrationVector := [{:value <-1000000 :}, 
	   {:value <- 30 :}, {:value <- 10 :}, {:value <- 100 :}, 
	   {:value <- 200 :}, {:value <-150 :};];
  
  };

  independent <-
  {
   OBJ t "Time": Time ;
  };

  state <-
  {
  OBJ PollutionHelp (* hidden = "1" *) "Help variable for pollution" : 
  	  FlowRate;
  OBJ FlowHelp (* hidden = "1" *) "Help variable for flow" : 
  	  FlowRate;
  OBJ Q_out (* hidden = "0" *)"" : FlowRate;
  };
  
  initial <-
  {
   
  };
  
  equations <-
  {
   interface.Outflow[H2O_sew] = - state.FlowHelp / 0.000001;
   				  
   {FOREACH s_comp_index IN {2 .. NrOfSewComponents}:
   	interface.Outflow[s_comp_index] = - parameters.Mean_S[s_comp_index] * 
									state.PollutionHelp;};			
 
    state.Q_out = state.FlowHelp; 			 
  };
 :};
 
CLASS DryWeatherFlow
 (* class = "generator"; category = "" *)
 "A dry weather flow generator for subcatchments in Kosim"
 EXTENDS SewGenerator WITH
 {:
  parameters <-
  {
   OBJ TotalArea " Area of the subcatchment m2" : 
        Area := {: value <- 100000:};
   OBJ PopulationDensity "Population density" : 
        PopDensity := {: value <- 1500:};
   OBJ WastewaterPerIE "Wastewater produced per inhabitant per day" :
       FlowRate := {: value <- 0.15 :};
   OBJ Qdwf_max "Maximum dry weather flow": FlowRate;
   OBJ Qdwf_peak (* hidden = "0" *) "Peak dry weather flow relative to average": Real ;  
   OBJ Q_ind "Flow from industry, constant": FlowRate;
   OBJ Infiltration "Water infiltration flow (l/s/ha)" : Real 
   	   :={:value <- 0.11:};
   OBJ startday "Week day at the start of the year, Saturday = 1": Integer :={:value <- 1:};
   OBJ we_factor "Factor for more or less water on week-ends": Real :={:value <- 0.7:};
   OBJ we_pollution "Factor for more or less pollution on week-ends": Real :={:value <- 0.5:};
   OBJ tourist_start "Day of the year": Integer :={:value <- 162:};
   OBJ tourist_end "Day of the year": Integer :={:value <- 300:};
   OBJ tourist_water "Factor for more or less water used in touristic season":Real :={:value <- 1:};
   OBJ tourist_pollution "Factor for more or less pollution in touristic season":Real :={:value <- 1.1:};
   OBJ FlowPatternNumber "Daily dwf pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" :
   	   Integer :={:value <- 1:};
   OBJ PollutionPatternNumber "Daily dw pollution pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" :
   	   Integer :={:value <- 1:};
   OBJ FlowPattern (* hidden = "1" *) "Flow pattern according to the daily mean value" : 
        HourlyDailyPattern; 
   OBJ InfiltrationPatternNumber "Seasonal infiltration pattern depending on catchment surface: 1=custom, else=constant" :
   	   Integer :={:value <- 1:};
   OBJ InfiltrationPattern (* hidden = "1" *) "Seasonal infiltration pattern" : 
        MonthlyYearlyPattern; 
   OBJ InfiltrationCustom (* hidden = "1" *) "custom pattern" : 
   	    MonthlyYearlyPattern  
          := [{: value <- 1.21:},{: value <- 1.27 :},{: value <- 1.25 :},
              {: value <- 1.04 :},{: value <- 0.95 :},{: value <- 0.79 :},
              {: value <- 0.87 :},{: value <- 0.63 :},{: value <- 0.61 :},
              {: value <- 0.76 :},{: value <- 0.86 :},{: value <- 1.08 :};];
   OBJ InfiltrationConstant (* hidden = "1" *) "" : 
   	    MonthlyYearlyPattern  
          := [{: value <- 1:},{: value <- 1 :},{: value <- 1 :},
              {: value <- 1 :},{: value <- 1 :},{: value <- 1:},
              {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
              {: value <- 1:},{: value <- 1 :},{: value <- 1 :};];
   OBJ ATV0to5thIE (* hidden = "1" *) "0 to 5000 inhabitants" : 
        HourlyDailyPattern  
          := [{: value <- 0.1:},{: value <- 0.1 :},{: value <- 0.1 :},
              {: value <- 0.1 :},{: value <- 0.6 :},{: value <- 1.6 :},
              {: value <- 1.9 :},{: value <- 1.3 :},{: value <- 1.1 :},
              {: value <- 0.8 :},{: value <- 1.0 :},{: value <- 1.9 :},
              {: value <- 3.0 :},{: value <- 2.5 :},{: value <- 1.6 :},
              {: value <- 0.8 :},{: value <- 0.7 :},{: value <- 1.3 :},
              {: value <- 1.8 :},{: value <- 1.5 :},{: value <- 0.4 :},
              {: value <- 0.1 :},{: value <- 0.1 :},{: value <- 0.1:};];
   OBJ ATV5to10thIE (* hidden = "1" *) "5000-10000 inhabitants" : 
        HourlyDailyPattern  
          := [{: value <- 0.1:},{: value <- 0.1 :},{: value <- 0.1 :},
              {: value <- 0.2 :},{: value <- 0.4 :},{: value <- 1.1 :},
              {: value <- 1.2 :},{: value <- 1.1 :},{: value <- 0.9 :},
              {: value <- 0.7 :},{: value <- 1.1 :},{: value <- 1.7 :},
              {: value <- 2.4 :},{: value <- 2.2 :},{: value <- 1.7 :},
              {: value <- 1.4 :},{: value <- 1.4 :},{: value <- 1.6 :},
              {: value <- 1.6 :},{: value <- 1.3 :},{: value <- 0.9 :},
              {: value <- 0.5 :},{: value <- 0.3 :},{: value <- 0.2:};];
   OBJ ATV10to50thIE (* hidden = "1" *) "10000-50000 inhabitants" : 
        HourlyDailyPattern  
          := [{: value <- 0.2:},{: value <- 0.2 :},{: value <- 0.2 :},
              {: value <- 0.3 :},{: value <- 0.6 :},{: value <- 0.9 :},
			  {: value <- 1.1 :},{: value <- 1.3 :},{: value <- 1.3 :},
              {: value <- 1.4 :},{: value <- 1.6 :},{: value <- 1.8 :},
              {: value <- 2.0 :},{: value <- 1.8 :},{: value <- 1.4 :},
              {: value <- 1.2 :},{: value <- 1.1 :},{: value <- 1.1 :},
              {: value <- 1.1 :},{: value <- 1.2 :},{: value <- 1.0 :},
              {: value <- 0.7 :},{: value <- 0.3 :},{: value <- 0.2:};];
   OBJ SIDEN (* hidden = "1" *) "Typical for Bleesbruck WWTP" : 
        HourlyDailyPattern  
          := [{: value <- 0.3:},{: value <- 0.3:},{: value <- 0.3 :},{: value <- 0.35 :},
              {: value <- 0.4 :},{: value <- 0.7 :},{: value <- 1.5 :},
			  {: value <- 1.7 :},{: value <- 1.3 :},{: value <- 1.1 :},
              {: value <- 0.8 :},{: value <- 1 :},{: value <- 1.5 :},
              {: value <- 1.9 :},{: value <- 1.8 :},{: value <- 1.5 :},
              {: value <- 0.8 :},{: value <- 0.7 :},{: value <- 1.5 :},
              {: value <- 1.8 :},{: value <- 1.5 :},{: value <- 0.5 :},
              {: value <- 0.4 :},{: value <- 0.35 :};];
   OBJ Commercial8_18 (* hidden = "1" *) "Commercial wastewater pattern" : 
        HourlyDailyPattern  
          := [{: value <- 0:},{: value <- 0 :},{: value <- 0 :},
              {: value <- 0 :},{: value <- 0 :},{: value <- 0 :},
			  {: value <- 0 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 0 :},
              {: value <- 0 :},{: value <- 0 :},{: value <- 0 :},
              {: value <- 0 :},{: value <- 0 :},{: value <- 0:};];
      OBJ CustomFlow (* hidden = "1" *) "Flow pattern defined by user" : 
        HourlyDailyPattern 
		:= [{: value <- 1.0:},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0:};];
  OBJ PollutionPattern (* hidden = "0" *) "Daily pollution pattern depending on population" : 
        HourlyDailyPattern; 
  OBJ Stoff0to5thIE (* hidden = "1" *) "Pollution pattern 0 to 5000 inhabitants" :
        HourlyDailyPattern
          := [{: value <- 0.01:},{: value <- 0.01 :},{: value <- 0.01 :},
              {: value <- 0.02 :},{: value <- 0.12 :},{: value <- 0.45 :},
              {: value <- 0.68 :},{: value <- 0.69 :},{: value <- 0.79 :},
              {: value <- 0.83 :},{: value <- 1.31 :},{: value <- 2.77 :},
              {: value <- 4.2 :},{: value <- 3.7 :},{: value <- 2.4 :},
              {: value <- 1.17 :},{: value <- 0.75 :},{: value <- 1.19 :},
              {: value <- 1.5 :},{: value <- 1.11 :},{: value <- 0.26 :},
              {: value <- 0.06 :},{: value <- 0.01 :},{:value <-0.01:};];; 
   OBJ Stoff5to10thIE (* hidden = "1" *) "Pollution pattern 5000 to 10000 inhabitants" :
        HourlyDailyPattern
          := [{: value <- 0.01:},{: value <- 0.01 :},{: value <- 0.05 :},
              {: value <- 0.06 :},{: value <- 0.1 :},{: value <- 0.32 :},
              {: value <- 0.44 :},{: value <- 0.58 :},{: value <- 0.65 :},
              {: value <- 0.72 :},{: value <- 1.41 :},{: value <- 2.42 :},
              {: value <- 3.28 :},{: value <- 3.18 :},{: value <- 2.48 :},
              {: value <- 2.0 :},{: value <- 1.47 :},{: value <- 1.44 :},
              {: value <- 1.3 :},{: value <- 0.95 :},{: value <- 0.59 :},
              {: value <- 0.3 :},{: value <- 0.16 :},{:value <- 0.1:};];; 
   OBJ Stoff10to50thIE (* hidden = "1" *) "Pollution 10000 to 50000 inhabitants" :
        HourlyDailyPattern
          := [{: value <- 0.14:},{: value <- 0.12 :},{: value <- 0.11 :},
              {: value <- 0.11 :},{: value <- 0.17 :},{: value <- 0.3 :},
              {: value <- 0.43 :},{: value <- 0.72 :},{: value <- 0.96 :},
              {: value <- 1.46 :},{: value <- 2.08 :},{: value <- 2.6 :},
              {: value <- 2.77 :},{: value <- 2.65 :},{: value <- 2.09 :},
              {: value <- 1.76 :},{: value <- 1.2 :},{: value <- 1.03 :},
              {: value <- 0.94 :},{: value <- 0.91 :},{: value <- 0.69 :},
              {: value <- 0.44 :},{: value <- 0.19 :},{:value <-0.13:};];; 
  OBJ CustomPollution (* hidden = "1" *) "Pollution pattern defined by user" : 
        HourlyDailyPattern 
		:= [{: value <- 1.0:},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0 :},
              {: value <- 1.0 :},{: value <- 1.0 :},{: value <- 1.0:};];
  OBJ SIDENPollution (* hidden = "1" *) "Pollution pattern defined by user" : 
        HourlyDailyPattern 
		:= [{: value <- 0.45:},{: value <- 0.5 :},{: value <- 0.45 :},
              {: value <- 0.6 :},{: value <- 0.8 :},{: value <- 1.1 :},
              {: value <- 1.2 :},{: value <- 1.2 :},{: value <- 1.1 :},
              {: value <- 1.05 :},{: value <- 1.1 :},{: value <- 1.3 :},
              {: value <- 1.5 :},{: value <- 1.6 :},{: value <- 1.5 :},
              {: value <- 1.4 :},{: value <- 1.3 :},{: value <- 1.3 :},
              {: value <- 1.3 :},{: value <- 1.1 :},{: value <- 0.7 :},
              {: value <- 0.5 :},{: value <- 0.45 :},{: value <- 0.4:};];
  OBJ PollutionCommercial8_18 (* hidden = "1" *) "Commercial wastewater polution pattern" : 
        HourlyDailyPattern  
          := [{: value <- 0:},{: value <- 0 :},{: value <- 0 :},
              {: value <- 0 :},{: value <- 0 :},{: value <- 0 :},
			  {: value <- 0 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 2.4 :},
              {: value <- 2.4 :},{: value <- 2.4 :},{: value <- 0 :},
              {: value <- 0 :},{: value <-  0:},{: value <- 0 :},
              {: value <- 0 :},{: value <- 0 :},{: value <- 0:};];
      OBJ AverageTotal (* hidden = "0" *) "Average volume produced" : FlowRate;
    };

  initial <-
  {

parameters.Qdwf_peak = MSLUGetMax(ref(parameters.FlowPattern[1]), NrOfHourlyTimeVectorElements);  
parameters.Qdwf_max = parameters.Qdwf_peak * parameters.TotalArea * parameters.PopulationDensity * parameters.WastewaterPerIE;
  
  {FOREACH Month_Index IN {1 .. 12}:
  parameters.InfiltrationPattern[Month_Index] = 
  	IF (parameters.InfiltrationPatternNumber == 1)
	THEN parameters.InfiltrationCustom[Month_Index]
	ELSE parameters.InfiltrationConstant[Month_Index];};
  {FOREACH Time_Index IN {1 .. 24}:
  parameters.FlowPattern[Time_Index] = 
  	IF (parameters.FlowPatternNumber == 1)
	THEN parameters.ATV0to5thIE[Time_Index]
	ELSE IF (parameters.FlowPatternNumber == 2)
  		 THEN parameters.ATV5to10thIE[Time_Index]
  		 ELSE IF (parameters.FlowPatternNumber == 3)
  		 	  THEN parameters.ATV10to50thIE[Time_Index]
			  ELSE IF (parameters.FlowPatternNumber == 4)
  		 	  	   THEN parameters.Commercial8_18[Time_Index]
			  	   ELSE IF (parameters.FlowPatternNumber == 5)
  		 	  	   		THEN parameters.SIDEN[Time_Index]
			  	   		ELSE parameters.CustomFlow[Time_Index];};
  {FOREACH Time_Index IN {1 .. 24}:
  parameters.PollutionPattern[Time_Index] = 
  	IF (parameters.PollutionPatternNumber == 1)
	THEN parameters.Stoff0to5thIE[Time_Index]
	ELSE IF (parameters.PollutionPatternNumber == 2)
  		 THEN parameters.Stoff5to10thIE[Time_Index]
  		 ELSE IF (parameters.PollutionPatternNumber == 3)
  		 	  THEN parameters.Stoff10to50thIE[Time_Index]
  		 	  ELSE IF (parameters.PollutionPatternNumber == 4)
  		 	  	   THEN parameters.PollutionCommercial8_18[Time_Index]
  		 	  	   ELSE IF (parameters.PollutionPatternNumber == 5)
  		 	  	   		THEN parameters.SIDENPollution[Time_Index]
  		 	  	   		ELSE parameters.CustomPollution[Time_Index];};
  
  parameters.AverageTotal = parameters.TotalArea * parameters.PopulationDensity *
                 	   	   	 parameters.WastewaterPerIE / 1000000;  
  };
  
  state <- 
  {
  OBJ DayOfTheYear (* hidden = "0" *)"" : Real;
  OBJ Month "" : Integer;
  OBJ Next_Month (* hidden = "0" *)"" : Integer;
  OBJ Daytime(* hidden = "0" *) "Calculates hour of the day" : Real;
  OBJ Help_Time (* hidden = "0" *)"Time of the day expressed in days" : Real;
  OBJ weight (* hidden = "0" *)"Interpolates between two timestep" : Fraction;
  OBJ Timestep (* hidden = "0" *)"Hour of the day" : Integer;
  OBJ Next_Timestep (* hidden = "0" *)"The next hour of the day" : Integer;
  OBJ Help (* hidden = "0" *)"Water" : Real;
  OBJ TotalInfiltration "Infiltration" : FlowRate;
  OBJ MonthWeight(* hidden = "0" *) "Interpolates between two timestep" : Fraction;
  OBJ weekday "Day of the week, Saturday = 1" : Integer;
  };
 
   equations <-
   { 
   state.DayOfTheYear = ceil(independent.t) - floor(floor(independent.t)/365)*365;
   state.Month = ceil(state.DayOfTheYear/30.5);
   state.MonthWeight = fmod(state.DayOfTheYear-1,30)/30;
   state.Next_Month = IF (state.Month >= 12)  
   				  	   	 THEN 1
   				  		 ELSE state.Month + 1;
   state.TotalInfiltration = 
   (parameters.InfiltrationPattern[state.Month]*(1-state.MonthWeight)
   						  + parameters.InfiltrationPattern[state.Next_Month]
						  *(state.MonthWeight))*(parameters.Infiltration/10000/1000*86400)
					  *parameters.TotalArea;
   						  					    
   state.Help_Time = independent.t - floor(independent.t);
   state.Daytime = state.Help_Time*24; 
   state.weight = fmod(state.Daytime,1);
   state.Timestep = floor(state.Daytime) + 1;
   state.Next_Timestep = IF (state.Timestep >= 24)
   				  	   	 THEN 1
   				  		 ELSE state.Timestep + 1;
   state.weekday = fmod(state.DayOfTheYear,7);
   state.FlowHelp = IF ((state.DayOfTheYear < parameters.tourist_start)||(state.DayOfTheYear > parameters.tourist_end))
   				  	THEN IF ((state.weekday == parameters.startday) || (state.weekday == parameters.startday+1))
   				    	 THEN  parameters.we_factor*(parameters.FlowPattern[state.Timestep] * (1-state.weight) 
   						 + parameters.FlowPattern[state.Next_Timestep] *
						 state.weight) * parameters.AverageTotal + state.TotalInfiltration + parameters.Q_ind
						 ELSE (parameters.FlowPattern[state.Timestep] * (1-state.weight) 
   						 + parameters.FlowPattern[state.Next_Timestep] *
						 state.weight) * parameters.AverageTotal + state.TotalInfiltration + parameters.Q_ind
					ELSE IF ((state.weekday == parameters.startday) || (state.weekday == parameters.startday+1))
   				    	 THEN parameters.tourist_water * parameters.we_factor*(parameters.FlowPattern[state.Timestep] * (1-state.weight) 
   						 + parameters.FlowPattern[state.Next_Timestep] *
						 state.weight) * parameters.AverageTotal + state.TotalInfiltration + parameters.Q_ind
						 ELSE parameters.tourist_water*(parameters.FlowPattern[state.Timestep] * (1-state.weight) 
   						 + parameters.FlowPattern[state.Next_Timestep] *
						 state.weight) * parameters.AverageTotal + state.TotalInfiltration + parameters.Q_ind;
   state.PollutionHelp =  IF ((state.DayOfTheYear < parameters.tourist_start)||(state.DayOfTheYear > parameters.tourist_end))
   					   	  THEN IF ((state.weekday == parameters.startday) || (state.weekday == parameters.startday+1))
   				       	  	   THEN parameters.we_pollution*(parameters.PollutionPattern[state.Timestep] * (1 - state.weight)  
                    	  	   + parameters.PollutionPattern[state.Next_Timestep] *
                    	  	   state.weight) * (parameters.AverageTotal)
						  	   ELSE (parameters.PollutionPattern[state.Timestep] * (1 - state.weight)  
                    	  	   + parameters.PollutionPattern[state.Next_Timestep] *
                    	  	   state.weight) * (parameters.AverageTotal)
						  ELSE IF ((state.weekday == parameters.startday) || (state.weekday == parameters.startday+1))
   				       	  	   THEN parameters.tourist_pollution * parameters.we_pollution*(parameters.PollutionPattern[state.Timestep] * (1 - state.weight)  
                    	  	   + parameters.PollutionPattern[state.Next_Timestep] *
                    	  	   state.weight) * (parameters.AverageTotal)
						  	   ELSE parameters.tourist_pollution * (parameters.PollutionPattern[state.Timestep] * (1 - state.weight)  
                    	  	   + parameters.PollutionPattern[state.Next_Timestep] *
                    	  	   state.weight) * (parameters.AverageTotal);
  };
:};


CLASS InfiltrationFlow
 (* class = "generator"; category = "" *)
 "A dry weather flow generator for subcatchments in Kosim"
 EXTENDS SewGenerator WITH
 {:
  parameters <-
  {
   OBJ TotalArea " Area of the subcatchment m2" : 
        Area := {: value <- 100000:};
   OBJ Infiltration "Water infiltration flow (l/s/ha)" : Real 
   	   :={:value <- 0.11:};
   OBJ startday "Week day at the start of the year, Saturday = 2": Integer :={:value <- 2:};
   OBJ tourist_start "Day of the year": Integer :={:value <- 162:};
   OBJ tourist_end "Day of the year": Integer :={:value <- 300:};
   OBJ tourist_water "Factor for more or less water used in touristic season":Real :={:value <- 1:};
   OBJ tourist_pollution "Factor for more or less pollution in touristic season":Real :={:value <- 1.1:};
   OBJ InfiltrationPatternNumber "Seasonal infiltration pattern depending on catchment surface" :
   	   Integer :={:value <- 1:};
   OBJ InfiltrationPattern (* hidden = "0" *) "Seasonal infiltration pattern" : 
        MonthlyYearlyPattern; 
   OBJ InfiltrationBB (* hidden = "1" *) "Bleesbruck" : 
   	    MonthlyYearlyPattern  
          := [{: value <- 1.21:},{: value <- 1.27 :},{: value <- 1.25 :},
              {: value <- 1.04 :},{: value <- 0.95 :},{: value <- 0.79 :},
              {: value <- 0.87 :},{: value <- 0.63 :},{: value <- 0.61 :},
              {: value <- 0.76 :},{: value <- 0.86 :},{: value <- 1.08 :};];
   OBJ InfiltrationConstant (* hidden = "1" *) "" : 
   	    MonthlyYearlyPattern  
          := [{: value <- 1:},{: value <- 1 :},{: value <- 1 :},
              {: value <- 1 :},{: value <- 1 :},{: value <- 1:},
              {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
              {: value <- 1:},{: value <- 1 :},{: value <- 1 :};];  
    };

  initial <-
  {

  {FOREACH Month_Index IN {1 .. 12}:
  parameters.InfiltrationPattern[Month_Index] = 
  	IF (parameters.InfiltrationPatternNumber == 1)
	THEN parameters.InfiltrationBB[Month_Index]
	ELSE parameters.InfiltrationConstant[Month_Index];}; 
  };
  
  state <- 
  {
  OBJ DayOfTheYear (* hidden = "0" *)"" : Real;
  OBJ Month "" : Integer;
  OBJ Next_Month (* hidden = "0" *)"" : Integer;
  OBJ TotalInfiltration "Infiltration" : FlowRate;
  OBJ MonthWeight(* hidden = "0" *) "Interpolates between two timestep" : Fraction;
  };
 
   equations <-
   { 
   state.DayOfTheYear = ceil(independent.t);
   state.Month = ceil(state.DayOfTheYear/30);
   state.MonthWeight = fmod(state.DayOfTheYear-1,30)/30;
   state.Next_Month = IF (state.Month >= 12)  
   				  	   	 THEN 1
   				  		 ELSE state.Month + 1;
   state.TotalInfiltration = 
   (parameters.InfiltrationPattern[state.Month]*(1-state.MonthWeight)
   						  + parameters.InfiltrationPattern[state.Next_Month]
						  *(state.MonthWeight))*(parameters.Infiltration/10000/1000*86400)
					  *parameters.TotalArea;
   						  					    
   state.FlowHelp = state.TotalInfiltration;
   state.PollutionHelp = 0;
   };
:};


 




































CLASS Evaporation_calculator 
 (* class = "generator"; category = "" *)
 "A dry weather evaporation generator for use within Kosim"

 SPECIALISES PhysicalDAEModelType :=
 {:
  interface <-
  {
  OBJ  Evaporation (* terminal = "out_1" *) "Evaporation outflow" :
     Real := {:causality <- "COUT":};
  };
 
  parameters <- 
  {
   OBJ EvaporationPattern (* hidden = "1" *) "Pattern of daily evaporation": 
       HourlyDailyPattern
          := [{: value <- 0.20:},{: value <- 0.20 :},{: value <- 0.20 :},
              {: value <- 0.20 :},{: value <- 0.25 :},{: value <- 0.35 :},
              {: value <- 0.55 :},{: value <- 0.65 :},{: value <- 0.75 :},
              {: value <- 1.00 :},{: value <- 1.50 :},{: value <- 1.85 :},
              {: value <- 1.95 :},{: value <- 2.00 :},{: value <- 2.00 :},
              {: value <- 1.95 :},{: value <- 1.85 :},{: value <- 1.60 :},
              {: value <- 1.35 :},{: value <- 1.05 :},{: value <- 0.85 :},
              {: value <- 0.75 :},{: value <- 0.50 :},{: value <-0.35:};];
   OBJ StartDay "Day of the year when the simulation starts" : Integer := {: value <- 1:};
    
    
    
   OBJ YearlyEvaporation "Average yearly potential evaporation (mm/year)d" :
        Real := {: value <- 657:};   
   OBJ Pival (* hidden = "1" *) : Pi;
  };

  independent <- 
  {
   OBJ t : Time;
  };

  state <- 
  { 
   OBJ MeanEvaporation "Mean evaporation per day" : RainfallIntensity;  
   OBJ DayOfTheYear "Day of the year 01 jan = 01" : Integer;
   OBJ DayOfTheYearHelp (* hidden = "1" *) "Helpvariable" : Integer;
   OBJ CurrentDate  "Date at the current simulation time" : Date;
   OBJ Timestep "Hour of the day" : Integer;
   OBJ Month "Month of the year" : Integer;
  };

  initial <- 
  {
    
  };

  equations <- 
  {
   state.DayOfTheYearHelp = independent.t + parameters.StartDay;
   state.DayOfTheYear = (state.DayOfTheYearHelp - fmod(state.DayOfTheYearHelp,1)) 
   					  - floor((state.DayOfTheYearHelp - fmod(state.DayOfTheYearHelp,1)-1)/365)*365;
   state.MeanEvaporation = (7.0 / 9.0 * sin(2 * parameters.Pival /365 * 
                           (state.DayOfTheYear - 91)) + 1) 
                           * parameters.YearlyEvaporation
                           / 365;
   state.Timestep = floor(fmod(independent.t,1)*24)+1;  
   interface.Evaporation = 
   						 IF (independent.t > 0) 
						 THEN state.MeanEvaporation * 
						 parameters.EvaporationPattern[state.Timestep]
						 ELSE 0;
						  };
:};
								
CLASS KosimInputTransformer
 (* class = "two_combiner"; category = "" *)
  




 SPECIALISES PhysicalDAEModelType :=
 {:
  interface <-
  {
   OBJ Rain (* terminal = "in_1" *) "Input from the rain influent file" :
     Real := {:causality <- "CIN":}; 
   OBJ Evaporation (* terminal = "in_2" *) "Evaporation on current date" :
     Real := {:causality <- "CIN":};
   OBJ Out_1 (*terminal = "out_1" *) "Output to the runoff calculators" :
     KosimDataVector := {:causality <- "COUT":};
  };

  parameters <- 
  {
   OBJ InfluentTimestep "Time Unit of the rain influent file (mins)" : Minutes
   	   					:= {:value <- 60:};
   OBJ NrOfMinPerDay (* hidden = "1" *) 
        "Currently number of minutes per day" : 
        Real := {:value <- 1440:};
  };

  independent <- 
  {
   OBJ t : Time;
  };
 
  state <-
  {
  };

  equations <-
  {
    
   interface.Out_1[Rain] = interface.Rain / parameters.InfluentTimestep 
   						   * parameters.NrOfMinPerDay;
   interface.Out_1[Evaporation] = interface.Evaporation; 
  };
  :};

CLASS Runoffcalculator
 (* class = "transformer"; category = "" *)
 "A run off calculator for basins in KOSIM"

 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-

  {
    OBJ In_1 (* terminal = "in_1" *) "Data for KOSIM bassin" : 
      KosimDataVector := {: causality <- "CIN" :};
	OBJ accumul (* terminal = "in_1" *) "Data for pollutants accumulation in kg/ha/d" : 
      SewTerminalSurfaceFlux := {: causality <- "CIN" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutSewTerminal := {: causality <- "COUT" :};    
  };

  parameters <-

  {
   OBJ TotalArea " Area of the subcatchment in m2" : Area := {: value <- 100000:};
   OBJ PerviousFraction "Percent of the catchment that is pervious" :
        Fraction := {: value <- 0.8:};
     



    

   OBJ InitialRunoffImp "The initial runoff coefficient Psi_o, impervious" : 
        Fraction := {: value <- 0.25:};
   OBJ MaxRunoffImp "The maximum runoff coefficient Psi_e, impervious" : 
        Fraction := {: value <- 1.0:};
   OBJ MaxWettingLosses " Wetting losses in mm" : 
        Rainfall := {:value <- 0.5:};
   OBJ MaxDepressionStorageImp 
        "Maximum Depression storage for impervious areas" : 
        Rainfall := {:value <- 1.8:};
    
   OBJ ConcImp 
       "Pollutant concentrations coming from the impervious areas, only valid if the accumulation/washoff process is deactivated" : 
        SewConcentrationVector := [{: value <- 1000000 :},
			{: value <- 0.001 :},{: value <- 0.001 :},{: value <- 0.001 :},
			{: value <- 0.001 :},{: value <- 0.001 :};];
 
    
   
   OBJ InitialRunoffPer "The initial runoff coefficient Psi_o, pervious" : 
        Fraction := {: value <- 0.0:};
   OBJ MaxRunoffPer "The maximum runoff coefficient Psi_e, pervious" : 
        Fraction := {: value <- 0.3:};
   OBJ MaxInfiltration "Initial infiltration capacity (mm/d)" : 
       RainfallIntensity := {:value <- 1440:};  
   OBJ MinInfiltration "Minimum infiltration capacity (mm/d)" : 
        RainfallIntensity := {:value <- 69:};
   OBJ MaxWetIntLosses "Wetting and Interception losses for pervious areas (mm)" : 
        Rainfall := {:value <- 5:};
   OBJ ReducingFactor (* hidden = "1" *) "Reduction of the interception max depending on season" : 
   	    MonthlyYearlyPattern := [{: value <- 0.1 :},{: value <- 0.1 :},{: value <- 0.3 :},
              {: value <- 0.7 :},{: value <- 1 :},{: value <- 1 :},
              {: value <- 1 :},{: value <- 1 :},{: value <- 1 :},
              {: value <- 0.7 :},{: value <- 0.3 :},{: value <- 0.1 :};];
   OBJ k "Degeneration rate of infiltration capacity during wet phase" :
       Rate := {:value <- 72:}; 
   OBJ k_D "Regeneration constant of infiltration capacity during dry phase" : 
        Rate := {:value <- 0.432:};
   OBJ MaxDepressionStoragePer "Depression storage for pervious areas (mm)": 
       Rainfall := {:value <- 3.5:};
   OBJ DailyEvaporation "Mean evaporation per day in the year (mm)" : 
   	   RainfallIntensity := {:value <- 1.8:};     
    
  
   
  
   OBJ OptionAccuWash "Surface accumulation and washoff, activated if = 1" : 
   	  Integer := {:value <- 1:}; 
   OBJ OptionAccuWashIn "Input for surface accumulation and washoff, parameters if = 1, interface if = 0" : 
   	  Integer := {:value <- 1:}; 
   OBJ accu "Accumulation rate of KOSIM-WEST components (kg/ha/day)" : 
   	  Real[NrOfSewComponents;] := [{: value <- 0 :},
			{: value <- 0 :},{: value <- 0 :},{: value <- 0 :},
			{: value <- 0 :},{: value <- 0 :};];
   OBJ Ke "Washoff rate (1/mm)" : 
   	   Real := {:value <- 0.18:}; 
	};
	
  independent <-
  {
   OBJ t : Time;
  };

  state <- 
  {
   OBJ WettingLosses "Current wetting losses on impervious surface" : Rainfall := {:value <- 1:};
   OBJ WettLossChange (*hidden="1"*) "Rate Wetting Loss Change" : RainfallIntensity;
   OBJ WettingLossesPer "Current wetting losses on pervious surface" : Rainfall := {:value <- 1:};
   OBJ WettLossPerChange (*hidden="1"*) "Rate Wetting Loss Change" : RainfallIntensity;
   OBJ DepressionStorageImp "Current depression storage" : Rainfall;
   OBJ FillingDepressionImp 
        "Filling degree of the depression storage impervious (lying between 0 and 1)" : 
        Fraction := {:value <- 1:};
   OBJ FillingChangeRateImp (* hidden = "1" *)
       " Rate of change of depression storage filling degree impervious" :
        Rate;
   OBJ NetRainfallImp
       "Rainfall after substraction of wetting losses on impervious areas" : 
       RainfallIntensity;
   OBJ NetRainfallChangeImp "" : Ratio;
   OBJ NetRainHelp 
       "Rainfall after substraction of wetting and interception losses on pervious areas" : 
       RainfallIntensity;  
   OBJ NetRainfallPer 
       "Rainfall after infiltration" : 
       RainfallIntensity;  
   OBJ RunoffImp : RainfallIntensity;
   OBJ RunoffPer : RainfallIntensity; 
   OBJ QImp "Flow coming from the impervious areas" : FlowRate; 
   OBJ QPer "Flow coming from the pervious areas " : FlowRate; 
   OBJ FillingDepressionPer 
        "Filling degree of the depression storage pervious (lying between 0 and 1)" : 
        Fraction := {:value <- 1:};
   OBJ FillingChangeRatePer 
       " Rate of change of depression storage filling degree pervious " :
        Rate;
   OBJ InfiltrationCapacity  
       " Infiltration capacity on pervious areas" :
       Rate := {:value <- 1:}; 
   OBJ InfiltrationCapacityChange (* hidden = "1" *)	"":    Real;   
   OBJ Rainsum "" : Real;
   OBJ Delta_t "" : Real;
   OBJ Day (* hidden = "1" *) "" : Time;
   OBJ Month (* hidden = "1" *) "" : Integer;
   OBJ Ma "Accumulated matter at the surface" : SewMassVector := [{: value <- 1000000 :},
			{: value <- 2000 :},{: value <- 500 :},{: value <- 2000 :},
			{: value <- 10000 :},{: value <- 20000 :};];
   OBJ MaChange (* hidden = "1" *) "" : Real[NrOfSewComponents;];
    };

 
 
	
  initial <-
  { 
   



 
 
   
    
  };

   equations <-
   {
   
 
    
    
   state.Day = floor(independent.t);
   state.Month = ceil(state.Day/30.5);
    
   state.WettLossChange =  
         IF (interface.In_1[Rain] > 0)
         THEN
             IF (state.WettingLosses >= parameters.MaxWettingLosses ) 
             THEN 0
             ELSE interface.In_1[Rain]
         ELSE 
            IF (state.WettingLosses > 0)
            THEN - interface.In_1[Evaporation]
            ELSE 0;
			
  DERIV(state.WettingLosses,[independent.t]) = state.WettLossChange;
  
   
   state.NetRainfallImp = 
        IF (interface.In_1[Rain] > 0)
        THEN interface.In_1[Rain] - state.WettLossChange 
        ELSE 0;

   
   state.FillingChangeRateImp =
        IF (state.NetRainfallImp > 0)
        THEN  state.NetRainfallImp * (1 - state.FillingDepressionImp)
        ELSE - (interface.In_1[Evaporation] * 
                state.FillingDepressionImp);      
   DERIV(state.FillingDepressionImp,[independent.t]) = 
        state.FillingChangeRateImp;

   
   state.RunoffImp = 
   		  IF (state.NetRainfallImp > 0)
		  THEN 
		  	   parameters.MaxRunoffImp * (state.NetRainfallImp -  
	      	   parameters.MaxDepressionStorageImp * state.FillingChangeRateImp)
          ELSE 0;
	
	 
   state.QImp = state.RunoffImp * 
                parameters.TotalArea * 
                (1 - parameters.PerviousFraction) / 1000;

     
	 { FOREACH s_comp_index IN {IndexOfFirstSolubleSewComponent ..
      IndexOfLastParticulateSewComponent}: 
   DERIV (state.Ma[s_comp_index],[independent.t])= state.MaChange[s_comp_index];};
   
   
    { FOREACH s_comp_index IN {IndexOfFirstSolubleSewComponent ..
      IndexOfLastParticulateSewComponent}:
   state.MaChange[s_comp_index] = 
   			 

 
			 	  IF (parameters.OptionAccuWashIn == 1)
				  THEN parameters.accu[s_comp_index] * ( parameters.TotalArea / 10000 ) * 1000  
			 	  * (1-parameters.PerviousFraction) -parameters.Ke * interface.In_1[Rain] * state.Ma[s_comp_index]
				  ELSE interface.accumul[s_comp_index] * ( parameters.TotalArea / 10000 ) * 1000  
			 	  * (1-parameters.PerviousFraction) -parameters.Ke * interface.In_1[Rain] * state.Ma[s_comp_index]; 
				   
				  };
 
 

    
  state.WettLossPerChange = 		
         IF (interface.In_1[Rain] > 0)									  
         THEN IF (state.WettingLossesPer >= parameters.ReducingFactor[state.Month]* 
			 							    parameters.MaxWetIntLosses ) 
              THEN 0
              ELSE interface.In_1[Rain]
         ELSE IF (state.WettingLossesPer > 0)
              THEN - interface.In_1[Evaporation]
           	  ELSE 0;
 
   
  DERIV(state.WettingLossesPer,[independent.t]) = state.WettLossPerChange;
  state.NetRainHelp = 
        IF (interface.In_1[Rain] > 0)
        THEN interface.In_1[Rain] - state.WettLossPerChange
        ELSE 0;
		
   
  
  













	
	DERIV(state.InfiltrationCapacity, [independent.t]) = state.InfiltrationCapacityChange;
	
 
 

	state.InfiltrationCapacityChange =
			 (- parameters.k 
            * (state.InfiltrationCapacity - parameters.MinInfiltration))*
			FMin(1,state.NetRainHelp/state.InfiltrationCapacity) + 
			(parameters.k_D *  (interface.In_1[Evaporation] / parameters.DailyEvaporation ) *
			 (parameters.MaxInfiltration - state.InfiltrationCapacity))*
			(1- FMin(1,state.NetRainHelp/state.InfiltrationCapacity));
 
 

    
   state.NetRainfallPer = 
        
       
          IF (state.NetRainHelp > state.InfiltrationCapacity)
          THEN state.NetRainHelp - state.InfiltrationCapacity
          
        ELSE 0;
		
   
  state.FillingChangeRatePer = 
       IF (state.NetRainfallPer > 0)
       THEN  state.NetRainfallPer * ( 1 - state.FillingDepressionPer)
       ELSE - ((interface.In_1[Evaporation] 
	    
	   ) 
	   * state.FillingDepressionPer); 
  DERIV(state.FillingDepressionPer,[independent.t]) = 
      state.FillingChangeRatePer;
  
   
  state.RunoffPer = 
       IF (state.NetRainfallPer > 0)
       THEN parameters.MaxRunoffPer *
            (state.NetRainfallPer - 
            parameters.MaxDepressionStoragePer * state.FillingChangeRatePer)
       ELSE 0;
	    
   
   state.QPer = state.RunoffPer * parameters.TotalArea * 
       parameters.PerviousFraction/1000;    

 

   interface.Outflow[H2O_sew] = - (state.QImp + state.QPer)
       / 0.000001;
	   
    
   {FOREACH s_comp_index IN {IndexOfFirstSolubleSewComponent ..  
   IndexOfLastSolubleSewComponent}:
       interface.Outflow[s_comp_index] = 
         - state.QImp * parameters.ConcImp[s_comp_index];};

  {FOREACH s_comp_index IN {IndexOfFirstParticulateSewComponent ..
   IndexOfLastParticulateSewComponent}:					   	 
       interface.Outflow[s_comp_index] =
	   			IF (parameters.OptionAccuWash == 1)
				THEN IF (interface.In_1[Rain] > 0) 
			 	 	 THEN -parameters.Ke * interface.In_1[Rain] * state.Ma[s_comp_index]
			 		 ELSE 0 
				ELSE - state.QImp * parameters.ConcImp[s_comp_index];
				};
				
  
    
   		 
		 
		 
		
		
  };
:};

CLASS Runoffcalculator_simple
 (* class = "transformer"; category = "" *)
 "A run off calculator for basins"

 SPECIALISES PhysicalDAEModelType :=
 {:

  interface <-

  {
    OBJ In_1 (* terminal = "in_1" *) "Data for KOSIM bassin" : 
      KosimDataVector := {: causality <- "CIN" :};
    OBJ Outflow (* terminal = "out_1" *) "Outflow" :
      OutSewTerminal := {: causality <- "COUT" :};    
  };

  parameters <-

  {
   OBJ TotalArea "Impervious area of the subcatchment in m2" : Area := {: value <- 100000:};
   OBJ TotalArea_fact "Factor for sensitivity analysis" : Real := {: value <- 1:};
   



    

   OBJ MaxRunoffImp "The maximum runoff coefficient Psi_e, impervious" : 
        Fraction := {: value <- 1.0:};
   OBJ MaxDepressionStorageImp 
        "Maximum Depression storage for impervious areas" : 
        Rainfall := {:value <- 1.8:};
   OBJ ConcImp 
       "Pollutant concentrations coming from the impervious areas, only valid if the accumulation/washoff process is deactivated" : 
        SewConcentrationVector := [{: value <- 1000000 :},
			{: value <- 0.001 :},{: value <- 0.001 :},{: value <- 0.001 :},
			{: value <- 0.001 :},{: value <- 0.001 :};];
	};
	
  independent <-
  {
   OBJ t : Time;
  };

  state <- 
  {
   OBJ FillingDepressionImp 
        "Filling degree of the depression storage impervious (lying between 0 and 1)" : 
        Fraction := {:value <- 1:};
   OBJ FillingChangeRateImp (* hidden = "1" *)
       " Rate of change of depression storage filling degree impervious" :
        Rate;
   OBJ RunoffImp : RainfallIntensity;
   OBJ QImp "Flow coming from the impervious areas" : FlowRate; 
   OBJ Day (* hidden = "1" *) "" : Time;
   OBJ Month (* hidden = "1" *) "" : Integer;
    };

   equations <-
   {
   
 
    
    
   state.Day = floor(independent.t);
   state.Month = ceil(state.Day/30.5);

   
	  state.FillingChangeRateImp = IF (interface.In_1[Rain] > 0)
                                 THEN IF (state.FillingDepressionImp < 1)
                                      THEN interface.In_1[Rain] / parameters.MaxDepressionStorageImp  
                                      ELSE 0
                                 ELSE - interface.In_1[Evaporation] * state.FillingDepressionImp / parameters.MaxDepressionStorageImp;   
                                 
    DERIV(state.FillingDepressionImp,[independent.t]) = state.FillingChangeRateImp;

   
    state.RunoffImp = IF ((interface.In_1[Rain] > 0) && (state.FillingDepressionImp >= 1))
		                  THEN parameters.MaxRunoffImp * interface.In_1[Rain]
                      ELSE 0;
	
	 
   state.QImp = IF (state.RunoffImp > 0)
		  THEN 
		  	   state.RunoffImp * parameters.TotalArea * parameters.TotalArea_fact / 1000
          ELSE 0;
   
   interface.Outflow[H2O_sew] = - state.QImp / 0.000001;
	   
    
   {FOREACH s_comp_index IN {IndexOfFirstSolubleSewComponent ..  
   IndexOfLastSolubleSewComponent}:
       interface.Outflow[s_comp_index] = 
         - state.QImp * parameters.ConcImp[s_comp_index];};

  {FOREACH s_comp_index IN {IndexOfFirstParticulateSewComponent ..
   IndexOfLastParticulateSewComponent}:					   	 
       interface.Outflow[s_comp_index] = - state.QImp * parameters.ConcImp[s_comp_index];
				};
		
  };
:};

# 12 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.catchments.msl" 1
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_catchments/sewer.catchments.combined_noretention.msl" 1
CLASS Catchment_Model_Combined_noretention (* icon = "Catchment" *) 
	  SPECIALISES CoupledModelType :=
{:
comments <- "Simpler catchment model without retention";

interface <-
{
 OBJ Rainfall (* terminal = "in_2" *) "Rainfall" : Real := {:causality <- CIN:},
 OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {:causality <- CIN:},
 OBJ Outflow (* terminal = "out_1" *) "Outflow from dry weather + wet weather" : OutSewTerminal := {:causality <- COUT:},
};

parameters <-
{
 OBJ YearlyEvaporation "Average yearly potential evaporation (mm/year)d" : Real := {: value <- 657; group <- "Runoff" :};
 OBJ k "linear reservoir constant" : Time := {: value <- 0.0138888888888889; group <- "Runoff" :};
 OBJ k_fact "factor for sensitivity analysis" : Real := {:value <- 1 ; group <- "Runoff" :};
 OBJ m "exponent (1 corresponds to linearity)" : Real := {: value <- 1; group <- "Runoff" :};
 OBJ InfluentTimestep "Time Unit of the rain influent file (mins)" : Minutes := {: value <- 60; group <- "Simulation" :};
 OBJ PopulationDensity "Population density" : PopDensity := {: value <- 1500; group <- "DWF" :};
 OBJ WastewaterPerIE "Wastewater produced per inhabitant per day" : FlowRate := {: value <- 0.19; group <- "DWF" :};
 OBJ Infiltration "Water infiltration flow (l/s/ha)" : Real := {: value <- 0; group <- "Runoff" :};
 OBJ start_day "Week day at the start of the year, Saturday = 1" : Integer := {: value <- 1; group <- "Simulation" :};
 OBJ we_factor "Factor for more or less water on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ we_pollution "Factor for more or less pollution on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_start "Day of the year" : Integer := {: value <- 162; group <- "DWF" :};
 OBJ tourist_end "Day of the year" : Integer := {: value <- 300; group <- "DWF" :};
 OBJ tourist_water "Factor for more or less water used in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_pollution "Factor for more or less pollution in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ FlowPatternNumber "Daily DW pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ PollutionPatternNumber "Daily DW pollution pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ InfiltrationPatternNumber "Seasonal infiltration pattern depending on catchment surface: 1=custom, else=constant" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ MaxRunoffImp "The maximum runoff coefficient Psi_e, impervious" : Fraction := {: value <- 1; group <- "Runoff" :};
 OBJ MaxDepressionStorageImp "Maximum Depression storage for impervious areas (mm)" : Rainfall := {: value <- 2; group <- "Runoff" :};
 OBJ TotalArea " Area of the subcatchment" : Area := {: value <- 10000; group <- "Catchment" :};
 OBJ TotalArea_fact "Factor for sensitivity analysis" : Real := {: value <- 1; group <- "Catchment" :};
  

 OBJ Q_ind "Flow from industry, constant": FlowRate := {: value <- 0; group <- "DWF" :};
 OBJ StartDay "Day of the year when the simulation starts" : Integer := {: value <- 1; group <- "Runoff":};
};

sub_models <-
{
 OBJ evaporation : Evaporation_calculator;
 OBJ runoff_conc : KosimTank_runoff;
 OBJ comb : KosimInputTransformer;
 OBJ comb2 : SewThreeCombiner;
 OBJ dwf : DryWeatherFlow;
 OBJ runoff : Runoffcalculator_simple;
};

coupling <-
{
  
 sub_models.evaporation.parameters.StartDay.value := parameters.StartDay.value,
 sub_models.evaporation.parameters.YearlyEvaporation.value := parameters.YearlyEvaporation.value,
 sub_models.runoff_conc.parameters.k.value := parameters.k.value,
 sub_models.runoff_conc.parameters.k_fact.value := parameters.k_fact.value,
 sub_models.runoff_conc.parameters.m.value := parameters.m.value,
 sub_models.comb.parameters.InfluentTimestep.value := parameters.InfluentTimestep.value,
 sub_models.dwf.parameters.PopulationDensity.value := parameters.PopulationDensity.value,
 sub_models.dwf.parameters.WastewaterPerIE.value := parameters.WastewaterPerIE.value,
 sub_models.dwf.parameters.Infiltration.value := parameters.Infiltration.value,
 sub_models.dwf.parameters.startday.value := parameters.start_day.value,
 sub_models.dwf.parameters.we_factor.value := parameters.we_factor.value,
 sub_models.dwf.parameters.we_pollution.value := parameters.we_pollution.value,
 sub_models.dwf.parameters.tourist_start.value := parameters.tourist_start.value,
 sub_models.dwf.parameters.tourist_end.value := parameters.tourist_end.value,
 sub_models.dwf.parameters.tourist_water.value := parameters.tourist_water.value,
 sub_models.dwf.parameters.tourist_pollution.value := parameters.tourist_pollution.value,
 sub_models.dwf.parameters.FlowPatternNumber.value := parameters.FlowPatternNumber.value,
 sub_models.dwf.parameters.PollutionPatternNumber.value := parameters.PollutionPatternNumber.value,
 sub_models.dwf.parameters.InfiltrationPatternNumber.value := parameters.InfiltrationPatternNumber.value,
 sub_models.dwf.parameters.Q_ind.value := parameters.Q_ind.value,
  





 sub_models.runoff.parameters.MaxRunoffImp.value := parameters.MaxRunoffImp.value,
 sub_models.runoff.parameters.MaxDepressionStorageImp.value := parameters.MaxDepressionStorageImp.value,
 sub_models.dwf.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.runoff.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.runoff.parameters.TotalArea_fact.value := parameters.TotalArea_fact.value,
 
  
 connect(interface.Rainfall, sub_models.comb.interface.Rain),
 connect(sub_models.evaporation.interface.Evaporation, sub_models.comb.interface.Evaporation),
 connect(sub_models.comb.interface.Out_1, sub_models.runoff.interface.In_1),
 connect(sub_models.runoff.interface.Outflow, sub_models.runoff_conc.interface.Inflow),
 connect(interface.Inflow, sub_models.comb2.interface.Inflow3),
 connect(sub_models.runoff_conc.interface.Outflow, sub_models.comb2.interface.Inflow1),
 connect(sub_models.dwf.interface.Outflow, sub_models.comb2.interface.Inflow2),
 connect(sub_models.comb2.interface.Outflow, interface.Outflow),
};

:};
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.catchments.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_catchments/sewer.catchments.combined_simple.msl" 1
CLASS Catchment_Model_Combined_simple (* icon = "Catchment" *) 
	  SPECIALISES CoupledModelType :=
{:
comments <- "Simpler catchment model with pumped buffer tank";

interface <-
{
 OBJ Rainfall (* terminal = "in_2" *) "Rainfall" : Real := {:causality <- CIN:},
 OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {:causality <- CIN:},
 OBJ Outflow (* terminal = "out_1" *) "Outflow from dry weather + wet weather" : OutSewTerminal := {:causality <- COUT:},
 OBJ Overflow (* terminal = "out_1" *) "Overflow exceeding pumping capacity" : OutSewTerminal := {:causality <- COUT:},
};

parameters <-
{
 OBJ YearlyEvaporation "Average yearly potential evaporation (mm/year)d" : Real := {: value <- 657; group <- "Runoff" :};
 OBJ k "linear reservoir constant" : Time := {: value <- 0.0138888888888889; group <- "Runoff" :};
 OBJ k_fact "factor for sensitivity analysis" : Real := {:value <- 1 ; group <- "Runoff" :};
 OBJ m "exponent (1 corresponds to linearity)" : Real := {: value <- 1; group <- "Runoff" :};
 OBJ InfluentTimestep "Time Unit of the rain influent file (mins)" : Minutes := {: value <- 60; group <- "Simulation" :};
 OBJ PopulationDensity "Population density" : PopDensity := {: value <- 1500; group <- "DWF" :};
 OBJ WastewaterPerIE "Wastewater produced per inhabitant per day" : FlowRate := {: value <- 0.19; group <- "DWF" :};
 OBJ Infiltration "Water infiltration flow (l/s/ha)" : Real := {: value <- 0; group <- "Runoff" :};
 OBJ start_day "Week day at the start of the year, Saturday = 1" : Integer := {: value <- 1; group <- "Simulation" :};
 OBJ we_factor "Factor for more or less water on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ we_pollution "Factor for more or less pollution on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_start "Day of the year" : Integer := {: value <- 162; group <- "DWF" :};
 OBJ tourist_end "Day of the year" : Integer := {: value <- 300; group <- "DWF" :};
 OBJ tourist_water "Factor for more or less water used in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_pollution "Factor for more or less pollution in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ FlowPatternNumber "Daily DW pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ PollutionPatternNumber "Daily DW pollution pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ InfiltrationPatternNumber "Seasonal infiltration pattern depending on catchment surface: 1=custom, else=constant" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ MaxRunoffImp "The maximum runoff coefficient Psi_e, impervious" : Fraction := {: value <- 1; group <- "Runoff" :};
 OBJ MaxDepressionStorageImp "Maximum Depression storage for impervious areas (mm)" : Rainfall := {: value <- 2; group <- "Runoff" :};
 OBJ TotalArea " Area of the subcatchment" : Area := {: value <- 10000; group <- "Catchment" :};
 OBJ TotalArea_fact "Factor for sensitivity analysis" : Real := {: value <- 1; group <- "Catchment" :};
  

 OBJ Q_Pump "Pumping capacity" : FlowRate := {: group <- "Pump" :};
 OBJ V_Max "Retention volume of the system" : Volume := {: group <- "Retention"; value <- 10 :};
 OBJ Q_ind "Flow from industry, constant": FlowRate := {: value <- 0; group <- "DWF" :};
 OBJ StartDay "Day of the year when the simulation starts" : Integer := {: value <- 1; group <- "Runoff":};
};

sub_models <-
{
 OBJ evaporation : Evaporation_calculator;
 OBJ runoff_conc : KosimTank_runoff;
 OBJ comb : KosimInputTransformer;
 OBJ comb2 : SewThreeCombiner;
 OBJ dwf : DryWeatherFlow;
 OBJ runoff : Runoffcalculator_simple;
 OBJ retention : SewRetentionVolume_P;
};

coupling <-
{
  
 sub_models.evaporation.parameters.StartDay.value := parameters.StartDay.value,
 sub_models.evaporation.parameters.YearlyEvaporation.value := parameters.YearlyEvaporation.value,
 sub_models.runoff_conc.parameters.k.value := parameters.k.value,
 sub_models.runoff_conc.parameters.k_fact.value := parameters.k_fact.value,
 sub_models.runoff_conc.parameters.m.value := parameters.m.value,
 sub_models.comb.parameters.InfluentTimestep.value := parameters.InfluentTimestep.value,
 sub_models.dwf.parameters.PopulationDensity.value := parameters.PopulationDensity.value,
 sub_models.dwf.parameters.WastewaterPerIE.value := parameters.WastewaterPerIE.value,
 sub_models.dwf.parameters.Infiltration.value := parameters.Infiltration.value,
 sub_models.dwf.parameters.startday.value := parameters.start_day.value,
 sub_models.dwf.parameters.we_factor.value := parameters.we_factor.value,
 sub_models.dwf.parameters.we_pollution.value := parameters.we_pollution.value,
 sub_models.dwf.parameters.tourist_start.value := parameters.tourist_start.value,
 sub_models.dwf.parameters.tourist_end.value := parameters.tourist_end.value,
 sub_models.dwf.parameters.tourist_water.value := parameters.tourist_water.value,
 sub_models.dwf.parameters.tourist_pollution.value := parameters.tourist_pollution.value,
 sub_models.dwf.parameters.FlowPatternNumber.value := parameters.FlowPatternNumber.value,
 sub_models.dwf.parameters.PollutionPatternNumber.value := parameters.PollutionPatternNumber.value,
 sub_models.dwf.parameters.InfiltrationPatternNumber.value := parameters.InfiltrationPatternNumber.value,
 sub_models.dwf.parameters.Q_ind.value := parameters.Q_ind.value,
  





 sub_models.runoff.parameters.MaxRunoffImp.value := parameters.MaxRunoffImp.value,
 sub_models.runoff.parameters.MaxDepressionStorageImp.value := parameters.MaxDepressionStorageImp.value,
 sub_models.dwf.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.runoff.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.runoff.parameters.TotalArea_fact.value := parameters.TotalArea_fact.value,
 sub_models.retention.parameters.Q_Pump.value := parameters.Q_Pump.value,
 sub_models.retention.parameters.V_Max.value := parameters.V_Max.value,
 
  
 connect(interface.Rainfall, sub_models.comb.interface.Rain),
 connect(sub_models.evaporation.interface.Evaporation, sub_models.comb.interface.Evaporation),
 connect(sub_models.comb.interface.Out_1, sub_models.runoff.interface.In_1),
 connect(sub_models.runoff.interface.Outflow, sub_models.runoff_conc.interface.Inflow),
 connect(interface.Inflow, sub_models.comb2.interface.Inflow3),
 connect(sub_models.runoff_conc.interface.Outflow, sub_models.comb2.interface.Inflow1),
 connect(sub_models.dwf.interface.Outflow, sub_models.comb2.interface.Inflow2),
 connect(sub_models.comb2.interface.Outflow, sub_models.retention.interface.Inflow), 
 connect(sub_models.retention.interface.Outflow1, interface.Outflow),
 connect(sub_models.retention.interface.Outflow2, interface.Overflow),
};

:};
# 2 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.catchments.msl" 2

# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer_catchments/sewer.catchments.combined_simple2.msl" 1
CLASS Catchment_Model_Combined_simple2 (* icon = "Catchment" *) 
	  SPECIALISES CoupledModelType :=
{:
comments <- "Simpler catchment model with free flow buffer tank";

interface <-
{
 OBJ Rainfall (* terminal = "in_2" *) "Rainfall" : Real := {:causality <- CIN:},
 OBJ Inflow (* terminal = "in_1" *) "Inflow" : InSewTerminal := {:causality <- CIN:},
 OBJ Outflow (* terminal = "out_1" *) "Outflow from dry weather + wet weather" : OutSewTerminal := {:causality <- COUT:},
 OBJ Overflow (* terminal = "out_1" *) "Overflow exceeding pumping capacity" : OutSewTerminal := {:causality <- COUT:},
};

parameters <-
{
 OBJ YearlyEvaporation "Average yearly potential evaporation (mm/year)d" : Real := {: value <- 657; group <- "Runoff" :};
 OBJ k "linear reservoir constant" : Time := {: value <- 0.0138888888888889; group <- "Runoff" :};
 OBJ m "exponent (1 corresponds to linearity)" : Real := {: value <- 1; group <- "Runoff" :};
 OBJ InfluentTimestep "Time Unit of the rain influent file (mins)" : Minutes := {: value <- 60; group <- "Simulation" :};
 OBJ PopulationDensity "Population density" : PopDensity := {: value <- 1500; group <- "DWF" :};
 OBJ WastewaterPerIE "Wastewater produced per inhabitant per day" : FlowRate := {: value <- 0.19; group <- "DWF" :};
 OBJ Infiltration "Water infiltration flow (l/s/ha)" : Real := {: value <- 0; group <- "Runoff" :};
 OBJ start_day "Week day at the start of the year, Saturday = 1" : Integer := {: value <- 1; group <- "Simulation" :};
 OBJ we_factor "Factor for more or less water on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ we_pollution "Factor for more or less pollution on week-ends" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_start "Day of the year" : Integer := {: value <- 162; group <- "DWF" :};
 OBJ tourist_end "Day of the year" : Integer := {: value <- 300; group <- "DWF" :};
 OBJ tourist_water "Factor for more or less water used in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ tourist_pollution "Factor for more or less pollution in touristic season" : Real := {: value <- 1; group <- "DWF" :};
 OBJ FlowPatternNumber "Daily DW pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ PollutionPatternNumber "Daily DW pollution pattern depending on population: 1=0-5kPE, 2=5k-10kPE, 3=10k-50kPE" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ InfiltrationPatternNumber "Seasonal infiltration pattern depending on catchment surface: 1=custom, else=constant" : Integer := {: value <- 1; group <- "DWF" :};
 OBJ MaxRunoffImp "The maximum runoff coefficient Psi_e, impervious" : Fraction := {: value <- 1; group <- "Runoff" :};
 OBJ MaxDepressionStorageImp "Maximum Depression storage for impervious areas (mm)" : Rainfall := {: value <- 2; group <- "Runoff" :};
 OBJ TotalArea " Area of the subcatchment" : Area := {: value <- 10000; group <- "Catchment" :};
  

 OBJ V_Max "Retention volume of the system" : Volume := {: group <- "Retention"; value <- 10 :};
 OBJ Q_ind "Flow from industry, constant": FlowRate := {: value <- 0; group <- "DWF" :};
 OBJ StartDay "Day of the year when the simulation starts" : Integer := {: value <- 1; group <- "Runoff":};
 OBJ PipeDiameter "diameter of the connected (circular) pipe downstream" : Length := {: value <- 0.6 ; group <- "Retention" :};
 OBJ D_Max "Maximum depth of the tank" : Length := {: group <- "Tank characteristics"; value <- 1; group <- "Retention" :};
 OBJ Q_max "Max outflow" : FlowRate := {: group <- "Tank characteristics"; group <- "Retention" :};
};

sub_models <-
{
 OBJ evaporation : Evaporation_calculator;
 OBJ runoff_conc : KosimTank_runoff;
 OBJ comb : KosimInputTransformer;
 OBJ comb2 : SewThreeCombiner;
 OBJ dwf : DryWeatherFlow;
 OBJ runoff : Runoffcalculator_simple;
 OBJ retention : SewRetentionVolume_FF;
};

coupling <-
{
  
 sub_models.evaporation.parameters.StartDay.value := parameters.StartDay.value,
 sub_models.evaporation.parameters.YearlyEvaporation.value := parameters.YearlyEvaporation.value,
 sub_models.runoff_conc.parameters.k.value := parameters.k.value,
 sub_models.runoff_conc.parameters.m.value := parameters.m.value,
 sub_models.comb.parameters.InfluentTimestep.value := parameters.InfluentTimestep.value,
 sub_models.dwf.parameters.PopulationDensity.value := parameters.PopulationDensity.value,
 sub_models.dwf.parameters.WastewaterPerIE.value := parameters.WastewaterPerIE.value,
 sub_models.dwf.parameters.Infiltration.value := parameters.Infiltration.value,
 sub_models.dwf.parameters.startday.value := parameters.start_day.value,
 sub_models.dwf.parameters.we_factor.value := parameters.we_factor.value,
 sub_models.dwf.parameters.we_pollution.value := parameters.we_pollution.value,
 sub_models.dwf.parameters.tourist_start.value := parameters.tourist_start.value,
 sub_models.dwf.parameters.tourist_end.value := parameters.tourist_end.value,
 sub_models.dwf.parameters.tourist_water.value := parameters.tourist_water.value,
 sub_models.dwf.parameters.tourist_pollution.value := parameters.tourist_pollution.value,
 sub_models.dwf.parameters.FlowPatternNumber.value := parameters.FlowPatternNumber.value,
 sub_models.dwf.parameters.PollutionPatternNumber.value := parameters.PollutionPatternNumber.value,
 sub_models.dwf.parameters.InfiltrationPatternNumber.value := parameters.InfiltrationPatternNumber.value,
 sub_models.dwf.parameters.Q_ind.value := parameters.Q_ind.value,
  





 sub_models.runoff.parameters.MaxRunoffImp.value := parameters.MaxRunoffImp.value,
 sub_models.runoff.parameters.MaxDepressionStorageImp.value := parameters.MaxDepressionStorageImp.value,
 sub_models.dwf.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.runoff.parameters.TotalArea.value := parameters.TotalArea.value,
 sub_models.retention.parameters.V_Max.value := parameters.V_Max.value,
 sub_models.retention.parameters.PipeDiameter.value := parameters.PipeDiameter.value,
 sub_models.retention.parameters.D_Max.value := parameters.D_Max.value,
 sub_models.retention.parameters.Q_max.value := parameters.Q_max.value,
 
  
 connect(interface.Rainfall, sub_models.comb.interface.Rain),
 connect(sub_models.evaporation.interface.Evaporation, sub_models.comb.interface.Evaporation),
 connect(sub_models.comb.interface.Out_1, sub_models.runoff.interface.In_1),
 connect(sub_models.runoff.interface.Outflow, sub_models.runoff_conc.interface.Inflow),
 connect(interface.Inflow, sub_models.comb2.interface.Inflow3),
 connect(sub_models.runoff_conc.interface.Outflow, sub_models.comb2.interface.Inflow1),
 connect(sub_models.dwf.interface.Outflow, sub_models.comb2.interface.Inflow2),
 connect(sub_models.comb2.interface.Outflow, sub_models.retention.interface.Inflow), 
 connect(sub_models.retention.interface.Outflow1, interface.Outflow),
 connect(sub_models.retention.interface.Outflow2, interface.Overflow),
};

:};
# 3 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.catchments.msl" 2

# 13 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\sewer.msl" 2



# 20 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2


# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.msl" 1
 
 
 
 
 




 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.definitions_Duflow_simple.msl" 1
 
 
 
 
 
 
 




TYPE RivComponents 

  = ENUM  {rH2O, rO2, rBOD1, rBOD2, rNH4, rBOD1p, rBOD2p, rBODs};

OBJ RivNrOfComponents
  "The number of biological components considered in the WWTP models"
  : Integer := Cardinality(RivComponents);
  
   

 CLASS RivTerminal

 = MassFlux[RivNrOfComponents;]; 

 CLASS InRivTerminal SPECIALISES RivTerminal;  
 CLASS OutRivTerminal SPECIALISES RivTerminal;  


 

 CLASS RivConcTerminal 

  = Concentration[RivNrOfComponents;]; 

 CLASS InRivConcTerminal SPECIALISES RivConcTerminal;  
 CLASS OutRivConcTerminal SPECIALISES RivConcTerminal;  
 
  
 OBJ In_RivTerminal "Temporary iteration variable" : RivTerminal;
 OBJ Out_RivTerminal "Temporary iteration variable" : RivTerminal;
 
CLASS RivMassVector = Mass[RivNrOfComponents;];
CLASS RivMassFluxVector = MassFlux[RivNrOfComponents;];
CLASS RivConcentrationVector = Concentration[RivNrOfComponents;];
CLASS RivSpecificVolumeVector = SpecificVolume[RivNrOfComponents;];

 
 
 


# 11 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.msl" 2


 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 1
 
 
 
 
 





 CLASS RivAtomicModel
 "
  A generic atomic WWTP model.
  Only specifies mass balances (mass variation is
  sum of biological mass fluxes (bioflux, with incoming = 
  positive sign, outgoing = negative sign) and a generic 
  conversion term (only declared here. Has to be specified 
  later).
 "
 SPECIALISES PhysicalDAEModelType :=
 {:
  
  
  parameters <-
   {

  


	OBJ T_conv "Time conversion factor from days to second": Real:={:value<- 86400:};

   };

     initial <-
    {
    
    };

  independent <- { OBJ t "Time"  : Time; };

  state <-
   {
    OBJ M "Vector containing masses for all the components" : RivMassVector;
    OBJ FluxPerComponent (* hidden = "1" *) "Vector containing fluxes for all the components, the sum of all incoming and outgoing fluxes" : RivMassFluxVector;
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all the components": RivMassFluxVector;
    OBJ ConversionTermPerComponent (* hidden = "1" *) "Vector containing conversionterms for all the components": RivMassFluxVector;
    OBJ Q_In "Influent flow rate" : FlowRate ;
    OBJ Q_Out "Effluent flow rate" : FlowRate ;

   };

  equations <-
   {

    

   }; 
 :};

 
 
 
 

 CLASS RivAtomicModelWithoutVolume 
 SPECIALISES PhysicalDAEModelType :=
 {:
  parameters <-
   {
    


   };

  initial <-
   {
    
   };

  independent <- 
  { 
    OBJ t "Time"  : Time := {: group <- "Time" :}; 
   };
   
  state <-
   {
    OBJ InFluxPerComponent (* hidden = "1" *) "Vector containing incoming fluxes for all components" : RivMassFluxVector;
    OBJ Q_In "Influent flow rate" : FlowRate := {: group <- "Operational" :};
   };

   equations <-
   {
     { FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
        state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
         (In_RivTerminal[Comp_Index]);
     };

     {state.Q_In = (0.000001
                  * state.InFluxPerComponent[rH2O]);
     };

   };
 :};


 
 
 


 CLASS RivAtomicModelWithVolume EXTENDS RivAtomicModel WITH
 {:

   state <-
    {
      OBJ V "Volume" : Volume;
      OBJ C "Vector containing concentrations for all the components" : RivConcentrationVector; 
    };

   equations <-
    {
      
      
    };

 :};

 
 
 

 CLASS RivAtomicModelWithVariableVolume
 EXTENDS RivAtomicModelWithVolume WITH
 {:

  interface <-
   {
     OBJ Inflow1 (* terminal = "in_1" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" :};
	 OBJ Inflow2 (* terminal = "in_2" *) "Inflow" : 
         InRivTerminal := {: causality <- "CIN" :};
     OBJ Outflow (* terminal = "out_1" *)"Outflow" : 
         OutRivTerminal := {: causality <- "COUT" :};
   };

  parameters <-
   {

   };

  state <-
   {

   };
   
initial <-{};
   
equations <-{};
   :};

 CLASS RivVarVolumeConversionModel EXTENDS RivAtomicModelWithVariableVolume WITH
 {:
 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.VolumeConversionModel_Duflow_simple.body.msl" 1
 
 
 
 
 

 
 

  interface <-
    {
     OBJ T (* terminal = "in_3" *) "Air temperature" : CelsiusTemperature := {: causality <- "CIN" ; group <- "Input" :};
	   OBJ I0 (* terminal = "in_3" *) "Radiation at water surface" : DensityOfHeatFlowRate := {: causality <- "CIN" ; group <- "Input" :};     
     OBJ DO (* terminal = "out_2" *) "DO" : Concentration := {: causality <- "COUT" ; group <- "Measured variable" :};
     OBJ NH4 (* terminal = "out_2" *) "NH4" : Concentration := {: causality <- "COUT" ; group <- "Measured variable" :};
     OBJ Q (* terminal = "out_2" *) "Q" : FlowRate := {: causality <- "COUT" ; group <- "Measured variable" :};
     OBJ kLa (* terminal = "in_3"; manip = "1"; *) "kLa from external aeration (1/d)" : Real := {: causality <- "CIN" :};
	  };

   parameters <-
   {
   };

   state <-
   {
   };
   
   initial <-
  {
  };

   equations <-
   {
   };
    


 

# 164 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 2

 :};

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.Volume_Duflow_simple.msl" 1
 
 
 
 
 

CLASS RivVarVolumeRIVER
 (* icon = "River" *)
 SPECIALISES RivVarVolumeConversionModel :=
 {:
  comments <- "Model for a bulk water unit with a variable volume";
  interface <-{};
  parameters <-{
   
  OBJ slp "Average channel slope along channel length" : Ratio := {:value <- 0.0005; group <- "River characteristics" :};
	OBJ n "Manning's 'n' value for channel" : Real := {:value <- 0.035; group <- "River characteristics" :};
	OBJ W_b "Width of channel at bottom of bank" : Length := {:value <- 10; group <- "River characteristics" :};
	OBJ L "Length of channel" : Length := {:value <- 2000; group <- "River characteristics" :};
	OBJ z "Banks slope" : Real := {:value <- 0.5; group <- "River characteristics" :};	
	OBJ d_min "Minimum depth of water" : Length := {:value <- 0.01; group <- "River characteristics" :};
	OBJ Vol_min "Minimum volume of water" : Volume := {: group <- "River characteristics" :};
	OBJ Vol_init "Initial volume of water as ratio on minimum" : Real := {:value <- 1.5; group <- "River characteristics" :};  
	
	OBJ Q_initial "Initial Flow in m3/s" : Real := {:value <- 5; group <- "River characteristics" :};

   
  
   
  OBJ alpha "Alpha factor for artificial aeration" : Real := {:value <- 0.85:};	
  OBJ pH "pH" : Real := {:value <- 7.5:};	
  OBJ KLmin "Minimum mass transfer constant reaeration": Velocity := {:value <- 0.1; unit <- "m/d":};
	OBJ TKL "Temperature coefficient mass transfer": Real := {:value <- 1.02:};
	OBJ Kd1 "Decay rate BOD1": RateConstant := {:value <- 0.4; unit <- "1/d":};
	OBJ Kd2 "Decay rate BOD2": RateConstant := {:value <- 0.3; unit <- "1/d":};
	OBJ KBODs "Decay rate temporary sediment BOD": RateConstant := {:value <- 0.7; unit <- "1/d":};
	OBJ Vs1 "Sedimentation rate particulate BOD1": Velocity := {:value <- 10; unit <- "m/d":};
	OBJ Vs2 "Sedimentation rate particulate BOD2": Velocity := {:value <- 50; unit <- "m/d":};
	OBJ KO2 "Monod constant O2 on BOD decay": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ TKd "Temperature coefficient DOD decay": Real := {:value <- 1.05:};
	OBJ TKp "Temperature coefficient plant growth/decay": Real := {:value <- 1.03:};
	OBJ Knit "Nitrification rate": RateConstant := {:value <- 0.2; unit <- "1/d":};
	OBJ TKnit "Temperature coefficient nitrification": Real := {:value <- 1.06:};
	OBJ KNO2 "Monod constant O2 on nitrification": Concentration := {:value <- 3.0; unit <- "mg/l":};
	OBJ KSO2 "Monod constant O2 on sediment oxygen demand": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ ProdM "Oxygen production Macrophyte Biomass (gO2/gM)/(W/m2)/day": Real := {:value <- 0.0002:};
	OBJ ResM "Oxygen respiration Macrophyte Biomass (gO2/gM)/day": RateConstant := {:value <- 0.04; unit <- "1/d":};
	OBJ TSOD "Temperature coefficient SOD": Real := {:value <- 1.08:};
	OBJ SBOD1 "Diffuse source BOD1, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SBOD2 "Diffuse source BOD2, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SNH4 "Diffuse source NH4, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SOD "Sediment Oxygen Demand (g/m2/day)" : Real := {:value <- 5.0; group <- "Inputs":};	
	OBJ VKL "Velocity reaeration coefficient": Real := {:value <- 3.2:};

	OBJ MB "Macrophyte biomass" : SurfaceDensity := {:value <- 50; group <- "Inputs":};

	OBJ T_ref "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : CelsiusTemperature := {:value <- 15:};
	OBJ T_par "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : Real := {:value <- 3:};
	 
	};
  state <-{
  OBJ d_initial "Initial Water depth. Serves as a Volume initialization" : Length := {:value <- 1; group <- "River characteristics" :};
   
  OBJ P "Wetted perimeter" : Length:= {: group <- "River characteristics" :};
	OBJ R "Hydraulic radius" : Length:= {: group <- "River characteristics" :};
	OBJ A "Cross-sectional area bulk water tank" : Area:= {: group <- "River characteristics" :};
	OBJ A_man "Cross-sectional area bulk water tank, reduced fr Manning equation, due to d_min" : Area:= {: group <- "River characteristics" :};
	OBJ d "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
	OBJ vel_water "Velocity of water" : Velocity := {: group <- "River characteristics" :};
	OBJ d_help "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
	OBJ vel_water_help "Velocity of water" : Velocity := {: group <- "River characteristics" :};
	OBJ V_help (* hidden="1" *) "Help volume" : Volume:= {: group <- "River characteristics" :};
   
  
   
  OBJ CS "saturation conc Oxygen" : Real ;
  OBJ DO_sat_perc "saturation percentage Oxygen" : Fraction ;
  OBJ UIamm "unionised ammonia" : Concentration ;
  OBJ UIamm_corr "unionised ammonia, corrected for DO" : Concentration ;
  OBJ DO_corr "DO, corrected fro UIamm" : Concentration ;
	OBJ KL20 "mass transfer at 20oC calculated form velocity and depth" : Real ;
	OBJ KLT "" : Real ;
	OBJ PO2M "net oxygen production/consumption Macrophytesn" : Real ;
	OBJ SedO2 "" : Real ;
	OBJ REAR "" : Real ;
	OBJ Nitrif "" : Real ;
	OBJ BODox "" : Real ;
	OBJ SODT "" : Real ;
	OBJ BOD "" : Real ;
	OBJ T_wat "Water temperature" : CelsiusTemperature ;
	
	OBJ KL20_help (* hidden = "1" *) "" : Real ;
	OBJ T_wat_help (* hidden = "1" *) "Water temperature" : CelsiusTemperature ;

	OBJ OTR "Actual oxygen transfer rate" : MassFlux;
  OBJ SOTR "Standard oxygen transfer rate" : MassFlux;
   

   	  };
	  
   initial <-{   
    
    
    
    
    
    
    
    
    
    
    
    
   };
 

  equations <-{
   
  
   
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

    (SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
    In_RivTerminal[Comp_Index])+
    (SUMOVER Out_RivTerminal IN {SelectByType(interface,OutRivTerminal)}:
    Out_RivTerminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
            (In_RivTerminal[Comp_Index]);
    };

    {state.Q_In = (0.000001
                  * state.InFluxPerComponent[rH2O]);
    };
  
   
	state.P = parameters.W_b + 2 * (state.d - parameters.d_min) * sqrt(1 + pow(parameters.z,2)) ;
	state.R = state.A_man / state.P ;
	state.A = state.V / parameters.L ;
	state.A_man = (state.V - parameters.Vol_min) / parameters.L ;
	state.vel_water = state.Q_Out / state.A ;    
	state.d = 
		IF (parameters.z > 0)
		THEN  sqrt(state.A / parameters.z + pow((parameters.W_b / 2 / parameters.z),2)) - (parameters.W_b / 2 / parameters.z)
		ELSE  state.A / parameters.W_b ; 
		
	state.V_help = (SUMOVER Comp_Index IN {1 .. RivNrOfComponents}:
	(0.000001*state.M[Comp_Index]));		
	
	state.V =  IF (state.V_help <= parameters.Vol_min)
			   THEN parameters.Vol_min
			   ELSE state.V_help ;
	 
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
     state.C[Comp_Index] = IF (state.V == 0)
			   THEN 0
			   ELSE state.M[Comp_Index]/state.V;
     };
   
  state.Q_Out = 60 * 60 * 24 * state.A_man * pow(state.R,(2.0/3.0)) * pow(parameters.slp,0.5) / parameters.n ;   

  {FOREACH Comp_Index IN {1 .. rBOD2p}:interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ;};	
  interface.Outflow[rBODs] = 0;

 
  state.OTR = interface.kLa * (state.CS - state.C[rO2]) * state.V;
  state.SOTR = state.OTR * state.CS / (state.CS - state.C[rO2]) / parameters.alpha;
	
	state.T_wat_help = interface.T + (parameters.T_ref - interface.T) / parameters.T_par;
	state.T_wat = IF (state.T_wat_help > 0)
				        THEN state.T_wat_help
				        ELSE 0;

	state.CS = 14.652 - 0.41022 * state.T_wat + 0.007991 * pow(state.T_wat,2.0) - 0.000077774 * pow(state.T_wat,3.0);
	state.KL20_help = parameters.VKL * pow((state.vel_water/3600/24),0.67) * pow(state.d,-0.85);
	state.KL20 = IF (state.KL20_help < parameters.KLmin)
			         THEN parameters.KLmin
				       ELSE state.KL20_help;
	state.KLT = state.KL20 * pow(parameters.TKL,(state.T_wat-20));
	state.PO2M = (parameters.ProdM * interface.I0 - parameters.ResM) * parameters.MB / state.d * pow(parameters.TKp,(state.T_wat-20));
	state.SedO2 = (- parameters.SOD / state.d) * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.REAR = (state.KLT / state.d + interface.kLa) * (state.CS - state.C[rO2]);
	state.Nitrif = -4.57 * parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KNO2);
	state.BODox = (- parameters.Kd1 * (state.C[rBOD1] + state.C[rBOD1p]) - parameters.Kd2 * (state.C[rBOD2] + state.C[rBOD2p])  ) * pow(parameters.TKd,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KO2);
	state.SODT = - state.C[rBODs] * parameters.KBODs * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.BOD = state.C[rBOD1] + state.C[rBOD2] + state.C[rBOD1p] + state.C[rBOD2p];
	
	state.ConversionTermPerComponent[rO2] = (state.REAR + state.PO2M + state.SedO2 + state.BODox + state.Nitrif + state.SODT / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD1] = (- parameters.Kd1 * state.C[rBOD1] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD1 / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD2] = (- parameters.Kd2 * state.C[rBOD2] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD2 / state.d) * state.V;
  state.ConversionTermPerComponent[rBOD1p] = (- parameters.Vs1 / state.d - parameters.Kd1 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD1p] * state.V;
	state.ConversionTermPerComponent[rBOD2p] = (- parameters.Vs2 / state.d - parameters.Kd2 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD2p] * state.V;
	state.ConversionTermPerComponent[rNH4] = (- parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) 
										      * state.C[rO2] / (state.C[rO2] + parameters.KNO2) + parameters.SNH4 / state.d) * state.V;
	state.ConversionTermPerComponent[rBODs] = (parameters.Vs1 * state.C[rBOD1p] + parameters.Vs2 * state.C[rBOD2p] + state.SODT) / state.d * state.V;
	interface.DO = state.C[rO2];
  interface.NH4 = state.C[rNH4];
  interface.Q = state.Q_Out;
  state.DO_sat_perc = state.C[rO2] / state.CS;
  state.UIamm = state.C[rNH4] * 1 / (pow(10,(0.090182 + 2729.92 / (273.15 + state.T_wat) - parameters.pH)) +1);
  state.UIamm_corr = IF (state.C[rO2] >= 5)
										 THEN state.UIamm
										 ELSE state.UIamm * 2;
  state.DO_corr = IF (state.UIamm < 0.02)
									THEN state.C[rO2]
									ELSE IF (state.UIamm <= 0.15)
											 THEN state.C[rO2] - 0.97 * log(state.UIamm) - 3.8
											 ELSE state.C[rO2] - 2;
 
   };
   
 :};
# 167 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.Volume_Muskingum.msl" 1
 
 
 
 
 

CLASS RivVarVolumeRIVER_Muskingum
 (* icon = "River" *)
 SPECIALISES RivVarVolumeConversionModel :=
 {:
  comments <- "Model for a bulk water unit with a variable volume and biochemistry from muskingum approximation for the diffusive term of wave propagation";
  interface <-{};
  parameters <-{
   
	OBJ W_b "Width of channel at bottom of bank" : Length := {: group <- "River characteristics" :};
	OBJ L "Length of channel" : Length := {:value <- 2.657; group <- "River characteristics" :};
	OBJ z "Banks slope" : Real := {:value <- 0.5; group <- "River characteristics" :};	
	
	OBJ x "Muskingum parameter X" : Real := {:value <- 0.2; group <- "Muskingum Parameters" :};	
  OBJ k "Muskingum k" : Real:= {:value <- 2;  group <- "Muskingum Parameters" :};

  OBJ d_min "Minimum depth of water" : Length := {:value <- 0.01; group <- "River characteristics" :};
	OBJ Vol_min "Minimum volume of water" : Volume := {: group <- "River characteristics" :};
	OBJ Vol_init "Initial volume of water as ratio on minimum" : Real := {:value <- 1.5; group <- "River characteristics" :};  
   
  
   
  OBJ alpha "Alpha factor for artificial aeration" : Real := {:value <- 0.85:};	
  OBJ pH "pH" : Real := {:value <- 7.5:};	
  OBJ KLmin "Minimum mass transfer constant reaeration": Velocity := {:value <- 0.1; unit <- "m/d":};
	OBJ TKL "Temperature coefficient mass transfer": Real := {:value <- 1.02:};
	OBJ Kd1 "Decay rate BOD1": RateConstant := {:value <- 0.4; unit <- "1/d":};
	OBJ Kd2 "Decay rate BOD2": RateConstant := {:value <- 0.3; unit <- "1/d":};
	OBJ KBODs "Decay rate temporary sediment BOD": RateConstant := {:value <- 0.7; unit <- "1/d":};
	OBJ Vs1 "Sedimentation rate particulate BOD1": Velocity := {:value <- 10; unit <- "m/d":};
	OBJ Vs2 "Sedimentation rate particulate BOD2": Velocity := {:value <- 50; unit <- "m/d":};
	OBJ KO2 "Monod constant O2 on BOD decay": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ TKd "Temperature coefficient DOD decay": Real := {:value <- 1.05:};
	OBJ TKp "Temperature coefficient plant growth/decay": Real := {:value <- 1.03:};
	OBJ Knit "Nitrification rate": RateConstant := {:value <- 0.2; unit <- "1/d":};
	OBJ TKnit "Temperature coefficient nitrification": Real := {:value <- 1.06:};
	OBJ KNO2 "Monod constant O2 on nitrification": Concentration := {:value <- 3.0; unit <- "mg/l":};
	OBJ KSO2 "Monod constant O2 on sediment oxygen demand": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ ProdM "Oxygen production Macrophyte Biomass (gO2/gM)/(W/m2)/day": Real := {:value <- 0.0002:};
	OBJ ResM "Oxygen respiration Macrophyte Biomass (gO2/gM)/day": RateConstant := {:value <- 0.04; unit <- "1/d":};
	OBJ TSOD "Temperature coefficient SOD": Real := {:value <- 1.08:};
	OBJ SBOD1 "Diffuse source BOD1, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SBOD2 "Diffuse source BOD2, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SNH4 "Diffuse source NH4, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SOD "Sediment Oxygen Demand (g/m2/day)" : Real := {:value <- 5.0; group <- "Inputs":};	
	OBJ VKL "Velocity reaeration coefficient": Real := {:value <- 3.2:};

	OBJ MB "Macrophyte biomass" : SurfaceDensity := {:value <- 50; group <- "Inputs":};

	OBJ T_ref "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : CelsiusTemperature := {:value <- 15:};
	OBJ T_par "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : Real := {:value <- 3:};
	 
	};
  state <-{
   
  OBJ C0 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
  OBJ C1 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
  OBJ C2 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
 
  OBJ Dt "Timestep" : Real:= {: group <- "Muskingum routing" :};
  OBJ Q_help "Timestep" : Real:= {: group <- "Muskingum routing" :};
	OBJ A "Cross-sectional area bulk water tank" : Area:= {: group <- "River characteristics" :};
	OBJ d "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
	OBJ vel_water "Velocity of water" : Velocity := {: group <- "River characteristics" :};
	OBJ V_help (* hidden="0" *) "Help volume" : Volume:= {: group <- "River characteristics" :};
   
  
   
  OBJ CS "saturation conc Oxygen" : Real ;
  OBJ DO_sat_perc "saturation percentage Oxygen" : Fraction ;
  OBJ UIamm "unionised ammonia" : Concentration ;
  OBJ UIamm_corr "unionised ammonia, corrected for DO" : Concentration ;
  OBJ DO_corr "DO, corrected fro UIamm" : Concentration ;
	OBJ KL20 "mass transfer at 20oC calculated form velocity and depth" : Real ;
	OBJ KLT "" : Real ;

	OBJ PO2M "net oxygen production/consumption Macrophytesn" : Real ;
	OBJ SedO2 "" : Real ;
	OBJ REAR "" : Real ;
	OBJ Nitrif "" : Real ;
	OBJ BODox "" : Real ;
	OBJ SODT "" : Real ;
	OBJ BOD "" : Real ;
	OBJ T_wat "Water temperature" : CelsiusTemperature ;
	
	OBJ KL20_help (* hidden = "1" *) "" : Real ;
	OBJ T_wat_help (* hidden = "1" *) "Water temperature" : CelsiusTemperature ;

	OBJ OTR "Actual oxygen transfer rate" : MassFlux;
  OBJ SOTR "Standard oxygen transfer rate" : MassFlux;
   
   	};
	  
   initial <-{   
   parameters.Vol_min = parameters.d_min * (parameters.W_b + parameters.d_min * parameters.z) * parameters.L;
   state.M[1] = parameters.Vol_min / 0.000001 * parameters.Vol_init;
   state.Q_Out = 20;

    };
 
 
  equations <-{
   
   
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

    (SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
    In_RivTerminal[Comp_Index])+
    (SUMOVER Out_RivTerminal IN {SelectByType(interface,OutRivTerminal)}:
    Out_RivTerminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
            (In_RivTerminal[Comp_Index]);
    };

    {state.Q_In = (0.000001
                  * state.InFluxPerComponent[rH2O]);
    };
  
   

  state.Dt = (independent.t - previous(independent.t))*24;
  
  state.C0 = (state.Dt - 2*parameters.k*parameters.x)/(state.Dt + 2*parameters.k*(1-parameters.x));
  state.C1 = (state.Dt + 2*parameters.k*parameters.x)/(state.Dt + 2*parameters.k*(1-parameters.x));
  state.C2 = 1 - state.C0 - state.C1 ;
  
  state.Q_help = state.C0*state.Q_In + state.C1*previous(state.Q_In) + state.C2*previous(state.Q_Out);
  
  state.Q_Out = IF (state.Q_help <= 0) 
  THEN 0 
  ELSE state.Q_help;
  
  
	state.V_help = (SUMOVER Comp_Index IN {1 .. RivNrOfComponents}:
	(0.000001*state.M[Comp_Index]));		
	state.V =  IF (state.V_help <= parameters.Vol_min) 
	THEN parameters.Vol_min 
	ELSE state.V_help;



	state.A = state.V / parameters.L;
	state.vel_water = state.Q_Out / state.A;  
	state.d = IF (parameters.z > 0)
	THEN  sqrt(state.A / parameters.z + pow((parameters.W_b / 2 / parameters.z),2)) - (parameters.W_b / 2 / parameters.z)
	ELSE  state.A / parameters.W_b ; 
  
   {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:state.C[Comp_Index] = IF (state.V == 0)
			   THEN 0
			   ELSE state.M[Comp_Index]/state.V;
			   };

   {FOREACH Comp_Index IN {1 .. rBOD2p}:
     interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ;
     };	
	
	interface.Outflow[rBODs] = 0;
	

 
  state.OTR = interface.kLa * (state.CS - state.C[rO2]) * state.V;
  state.SOTR = state.OTR * state.CS / (state.CS - state.C[rO2]) / parameters.alpha;
	
	state.T_wat_help = interface.T + (parameters.T_ref - interface.T) / parameters.T_par;
	state.T_wat = IF (state.T_wat_help > 0)
				        THEN state.T_wat_help
				        ELSE 0;

	state.CS = 14.652 - 0.41022 * state.T_wat + 0.007991 * pow(state.T_wat,2.0) - 0.000077774 * pow(state.T_wat,3.0);
	state.KL20_help = parameters.VKL * pow((state.vel_water/3600/24),0.67) * pow(state.d,-0.85);
	state.KL20 = IF (state.KL20_help < parameters.KLmin)
			         THEN parameters.KLmin
				       ELSE state.KL20_help;
	state.KLT = state.KL20 * pow(parameters.TKL,(state.T_wat-20));
	state.PO2M = (parameters.ProdM * interface.I0 - parameters.ResM) * parameters.MB / state.d * pow(parameters.TKp,(state.T_wat-20));
	state.SedO2 = (- parameters.SOD / state.d) * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.REAR = (state.KLT / state.d + interface.kLa) * (state.CS - state.C[rO2]);
	state.Nitrif = -4.57 * parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KNO2);
	state.BODox = (- parameters.Kd1 * (state.C[rBOD1] + state.C[rBOD1p]) - parameters.Kd2 * (state.C[rBOD2] + state.C[rBOD2p])  ) * pow(parameters.TKd,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KO2);
	state.SODT = - state.C[rBODs] * parameters.KBODs * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.BOD = state.C[rBOD1] + state.C[rBOD2] + state.C[rBOD1p] + state.C[rBOD2p];
	
	state.ConversionTermPerComponent[rO2] = (state.REAR + state.PO2M + state.SedO2 + state.BODox + state.Nitrif + state.SODT / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD1] = (- parameters.Kd1 * state.C[rBOD1] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD1 / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD2] = (- parameters.Kd2 * state.C[rBOD2] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD2 / state.d) * state.V;
  state.ConversionTermPerComponent[rBOD1p] = (- parameters.Vs1 / state.d - parameters.Kd1 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD1p] * state.V;
	state.ConversionTermPerComponent[rBOD2p] = (- parameters.Vs2 / state.d - parameters.Kd2 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD2p] * state.V;
	state.ConversionTermPerComponent[rNH4] = (- parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) 
										      * state.C[rO2] / (state.C[rO2] + parameters.KNO2) + parameters.SNH4 / state.d) * state.V;
	state.ConversionTermPerComponent[rBODs] = (parameters.Vs1 * state.C[rBOD1p] + parameters.Vs2 * state.C[rBOD2p] + state.SODT) / state.d * state.V;
	interface.DO = state.C[rO2];
  interface.NH4 = state.C[rNH4];
  interface.Q = state.Q_Out;
  state.DO_sat_perc = state.C[rO2] / state.CS;
  state.UIamm = state.C[rNH4] * 1 / (pow(10,(0.090182 + 2729.92 / (273.15 + state.T_wat) - parameters.pH)) +1);
  state.UIamm_corr = IF (state.C[rO2] >= 5)
										 THEN state.UIamm
										 ELSE state.UIamm * 2;
  state.DO_corr = IF (state.UIamm < 0.02)
									THEN state.C[rO2]
									ELSE IF (state.UIamm <= 0.15)
											 THEN state.C[rO2] - 0.97 * log(state.UIamm) - 3.8
											 ELSE state.C[rO2] - 2;
 
   };
   
 :};
# 168 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.Volume_MuskingumCungeTodini.msl" 1
 
 
 
 
 
 

CLASS RivVarVolumeRIVER_MCT
 (* icon = "River" *)
 SPECIALISES RivVarVolumeConversionModel :=
 {:
  comments <- "Model for a bulk water unit with a variable volume and biochemistry from muskingum-Cunge Todini approximation for the diffusive term of wave propagation. DO NOT USE IT, the implementation presents numerical instabilities";
  interface <-{};
  parameters <-{
   
	OBJ W_b "Width of channel at bottom of bank" : Length := {: value <- 10; group <- "River characteristics" :};
	OBJ L "Length of channel" : Length := {:value <- 2000; group <- "River characteristics" :};
	OBJ z "Banks slope" : Real := {:value <- 0.5; group <- "River characteristics" :};	
	OBJ slp "Average channel slope along channel length" : Ratio := {:value <- 0.0005; group <- "River characteristics" :};
	OBJ n "Manning's 'n' value for channel" : Real := {:value <- 0.035; group <- "River characteristics" :};
	
  OBJ d_min "Minimum depth of water" : Length := {:value <- 0.05; group <- "River characteristics" :};
	OBJ Vol_min "Minimum volume of water" : Volume := {: group <- "River characteristics" :};
	OBJ Vol_init "Initial volume of water as ratio on minimum" : Real := {:value <- 1.5; group <- "River characteristics" :};  
	
	 
  OBJ Niter "N iterations of the newton raphson routine, calculation of depth from flow for trapezoidal section" : Real := {:value <- 10; group <- "Newton Raphson Parameters" :};	
  
   

   
  OBJ alpha "Alpha factor for artificial aeration" : Real := {:value <- 0.85:};	
  OBJ pH "pH" : Real := {:value <- 7.5:};	
  OBJ KLmin "Minimum mass transfer constant reaeration": Velocity := {:value <- 0.1; unit <- "m/d":};
	OBJ TKL "Temperature coefficient mass transfer": Real := {:value <- 1.02:};
	OBJ Kd1 "Decay rate BOD1": RateConstant := {:value <- 0.4; unit <- "1/d":};
	OBJ Kd2 "Decay rate BOD2": RateConstant := {:value <- 0.3; unit <- "1/d":};
	OBJ KBODs "Decay rate temporary sediment BOD": RateConstant := {:value <- 0.7; unit <- "1/d":};
	OBJ Vs1 "Sedimentation rate particulate BOD1": Velocity := {:value <- 10; unit <- "m/d":};
	OBJ Vs2 "Sedimentation rate particulate BOD2": Velocity := {:value <- 50; unit <- "m/d":};
	OBJ KO2 "Monod constant O2 on BOD decay": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ TKd "Temperature coefficient DOD decay": Real := {:value <- 1.05:};
	OBJ TKp "Temperature coefficient plant growth/decay": Real := {:value <- 1.03:};
	OBJ Knit "Nitrification rate": RateConstant := {:value <- 0.2; unit <- "1/d":};
	OBJ TKnit "Temperature coefficient nitrification": Real := {:value <- 1.06:};
	OBJ KNO2 "Monod constant O2 on nitrification": Concentration := {:value <- 3.0; unit <- "mg/l":};
	OBJ KSO2 "Monod constant O2 on sediment oxygen demand": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ ProdM "Oxygen production Macrophyte Biomass (gO2/gM)/(W/m2)/day": Real := {:value <- 0.0002:};
	OBJ ResM "Oxygen respiration Macrophyte Biomass (gO2/gM)/day": RateConstant := {:value <- 0.04; unit <- "1/d":};
	OBJ TSOD "Temperature coefficient SOD": Real := {:value <- 1.08:};
	OBJ SBOD1 "Diffuse source BOD1, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SBOD2 "Diffuse source BOD2, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SNH4 "Diffuse source NH4, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SOD "Sediment Oxygen Demand (g/m2/day)" : Real := {:value <- 5.0; group <- "Inputs":};	
	OBJ VKL "Velocity reaeration coefficient": Real := {:value <- 3.2:};

	OBJ MB "Macrophyte biomass" : SurfaceDensity := {:value <- 50; group <- "Inputs":};

	OBJ T_ref "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : CelsiusTemperature := {:value <- 15:};
	OBJ T_par "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : Real := {:value <- 3:};
	 
	};
  state <-{
   
  OBJ C0 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
  OBJ C1 "Muskingum coefficient C1" : Real:= {: group <- "Muskingum routing" :};
  OBJ C2 "Muskingum coefficient C2" : Real:= {: group <- "Muskingum routing" :};
 
  OBJ Dt "Timestep" : Real:= {: group <- "Muskingum routing" :};
  OBJ Q_help "Flow" : FlowRate := {: group <- "River characteristics" :};
  
  OBJ Q_Out_i "Flow" : FlowRate := {: group <- "River characteristics" :};
  OBJ Q_ref "Flow" : FlowRate := {: group <- "River characteristics" :};
	OBJ d_ref "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
  OBJ c_ref  "Celerity wave water tank initial" : Velocity:= {: group <- "River characteristics" :};
  OBJ b_ref  "Correcting factor for steady state compliance" : Real:= {: group <- "River characteristics" :};
  OBJ Cour_ref "Corrected Courant number" : Real:= {: group <- "River characteristics" :};
  OBJ Cour_help "Corrected Courant number" : Real:= {: group <- "River characteristics" :};  
  OBJ Dre_ref "Corrected cell Reynolds number" : Real:= {: group <- "River characteristics" :};
  OBJ A_ref "Cross-sectional area bulk water tank" : Area:= {: group <- "River characteristics" :};
  OBJ P_ref "Cross-sectional area bulk water tank" : Length:= {: group <- "River characteristics" :};
  OBJ B_ref "Cross-sectional area bulk water tank" : Length:= {: group <- "River characteristics" :};
  
	OBJ A "Cross-sectional area bulk water tank" : Area:= {: group <- "River characteristics" :};
	OBJ d "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
	OBJ d_help (* hidden="1" *) "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
	OBJ vel_water "Velocity of water" : Velocity := {: group <- "River characteristics" :};
	OBJ V_help (* hidden="0" *) "Help volume" : Volume:= {: group <- "River characteristics" :};
   
  	OBJ d_test "Depth of water in channel" : Length:= {: group <- "River characteristics" :};
   
  OBJ CS "saturation conc Oxygen" : Real ;
  OBJ DO_sat_perc "saturation percentage Oxygen" : Fraction ;
  OBJ UIamm "unionised ammonia" : Concentration ;
  OBJ UIamm_corr "unionised ammonia, corrected for DO" : Concentration ;
  OBJ DO_corr "DO, corrected fro UIamm" : Concentration ;
	OBJ KL20 "mass transfer at 20oC calculated form velocity and depth" : Real ;
	OBJ KLT "" : Real ;

	OBJ PO2M "net oxygen production/consumption Macrophytesn" : Real ;
	OBJ SedO2 "" : Real ;
	OBJ REAR "" : Real ;
	OBJ Nitrif "" : Real ;
	OBJ BODox "" : Real ;
	OBJ SODT "" : Real ;
	OBJ BOD "" : Real ;
	OBJ T_wat "Water temperature" : CelsiusTemperature ;
	
	OBJ KL20_help (* hidden = "1" *) "" : Real ;
	OBJ T_wat_help (* hidden = "1" *) "Water temperature" : CelsiusTemperature ;

	OBJ OTR "Actual oxygen transfer rate" : MassFlux;
  OBJ SOTR "Standard oxygen transfer rate" : MassFlux;
   
   	};
	  
   initial <-{   
   parameters.Vol_min = parameters.d_min * (parameters.W_b + parameters.d_min * parameters.z) * parameters.L;
    
    
    











    
    
   state.Q_Out = 10 * (3600*24);
   state.Q_In = 10 * (3600*24);
   state.Q_help = state.Q_Out;
   
   state.d= NewtonRaphson(1, 10/(3600*24), parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter);
   state.d_ref = state.d;
   state.M[rH2O] = 1000000 * state.d * ( parameters.W_b + state.d * parameters.z) * parameters.L; 
   state.V =  state.M[rH2O] * 0.000001;
    
   
   state.A_ref = state.d * ( parameters.W_b + state.d * parameters.z); 
   state.P_ref = parameters.W_b + 2 * state.d * sqrt(1+ pow(parameters.z,2)); 
   state.B_ref = parameters.W_b + 2 * state.d * parameters.z;
  
   state.c_ref = ((5.0 / 3.0) * (sqrt(parameters.slp) / parameters.n) * pow(state.A_ref, 2.0/3.0) / pow(state.P_ref,2.0/3.0) ) * (1- (4.0/5.0)*state.A_ref * sqrt(1+pow(parameters.z,2)) / (state.B_ref * state.P_ref)  );  
   state.b_ref = state.c_ref * state.A_ref / (state.Q_Out/(3600*24));  
  
   state.Cour_ref = state.c_ref * state.Dt * (3600*24) / (state.b_ref * parameters.L) ;
   state.Dre_ref = (state.Q_Out/(3600*24)) / (state.b_ref * state.B_ref * parameters.slp * state.c_ref * parameters.L);
   
    state.C0 = 1/3;
    state.C1 = 1/3;
    state.C2 = 1/3;
    };
 
 
  equations <-{
   
   
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

    (SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
    In_RivTerminal[Comp_Index])+
    (SUMOVER Out_RivTerminal IN {SelectByType(interface,OutRivTerminal)}:
    Out_RivTerminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};

     
     
    
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
            (In_RivTerminal[Comp_Index]);
    };

    {state.Q_In = (0.000001
                  * state.InFluxPerComponent[rH2O]);
    };
  
   

  state.Dt = (independent.t - previous(independent.t));  
    
   
   
  
     
  state.Q_Out_i =  IF (independent.t <= state.Dt) 
	THEN 10*3600*24   
	ELSE previous(state.Q_Out) + (state.Q_In - previous(state.Q_In));    
  
  
  
  state.Q_ref = (state.Q_In + state.Q_Out_i) / 2 ;  
  
  state.d_ref = IF( state.Q_ref> 0) 
                THEN NewtonRaphson(1, state.Q_ref / (3600*24), parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter) 
                ELSE 0.1;
  
 
  state.A_ref = state.d_ref * ( parameters.W_b + state.d_ref * parameters.z); 
  state.P_ref = parameters.W_b + 2 * state.d_ref * sqrt(1+ pow(parameters.z,2)); 
  state.B_ref = parameters.W_b + 2 * state.d_ref * parameters.z;
  
  state.c_ref = ((5.0 / 3.0) * (sqrt(parameters.slp) / parameters.n) * pow(state.A_ref, 2.0/3.0) / pow(state.P_ref,2.0/3.0) ) * (1- (4.0/5.0)*state.A_ref * sqrt(1+pow(parameters.z,2)) / (state.B_ref * state.P_ref)  ) * (3600*24);  

  state.b_ref = state.c_ref * state.A_ref / state.Q_ref;
  state.Cour_help = (state.c_ref / state.b_ref)*( state.Dt / parameters.L);
  state.Cour_ref = IF(state.Cour_help<=0.001) 
                   THEN 0.001 
                   ELSE state.Cour_help;
                   
  state.Dre_ref = (state.Q_ref) / (state.b_ref * state.B_ref * parameters.slp * state.c_ref * parameters.L);
  
    
  state.C0 = (-1 + state.Cour_ref + state.Dre_ref) / (1 + state.Cour_ref + state.Dre_ref);
  state.C1 = ((1 + previous(state.Cour_ref) - previous(state.Dre_ref)) / (1 + state.Cour_ref + state.Dre_ref) ) * (state.Cour_ref / previous(state.Cour_ref));
  state.C2 = ((1 - previous(state.Cour_ref) + previous(state.Dre_ref)) / (1 + state.Cour_ref + state.Dre_ref) ) * (state.Cour_ref / previous(state.Cour_ref));
  
  
  state.Q_help = state.C0*state.Q_In + state.C1*previous(state.Q_In) + state.C2*previous(state.Q_Out);
  
  state.Q_Out = IF (state.Q_help <= 0) 
  THEN 0 
  ELSE state.Q_help;
  
  

  state.d = IF( state.Q_Out > 0) 
            THEN NewtonRaphson(1, state.Q_Out / (3600*24), parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter) 
            ELSE 0.1;
  
  
  
	state.V_help = (SUMOVER Comp_Index IN {1 .. RivNrOfComponents}:
	(0.000001*state.M[Comp_Index]));		
	state.V =  IF (state.V_help <= parameters.Vol_min) 
	THEN parameters.Vol_min 
	ELSE state.d*(parameters.W_b + state.d * parameters.z) * parameters.L;

	state.A = state.V / parameters.L;
	state.vel_water = state.Q_Out / state.A;  
	 
	 
	 
  
   {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:state.C[Comp_Index] = IF (state.V == 0)
			   THEN 0
			   ELSE state.M[Comp_Index]/state.V;
			   };

   {FOREACH Comp_Index IN {1 .. rBOD2p}:
     interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ;
     };	
	 
	interface.Outflow[rBODs] = 0;
	

 
  state.OTR = interface.kLa * (state.CS - state.C[rO2]) * state.V;
  state.SOTR = state.OTR * state.CS / (state.CS - state.C[rO2]) / parameters.alpha;
	
	state.T_wat_help = interface.T + (parameters.T_ref - interface.T) / parameters.T_par;
	state.T_wat = IF (state.T_wat_help > 0)
				        THEN state.T_wat_help
				        ELSE 0;

	state.CS = 14.652 - 0.41022 * state.T_wat + 0.007991 * pow(state.T_wat,2.0) - 0.000077774 * pow(state.T_wat,3.0);
	state.KL20_help = parameters.VKL * pow((state.vel_water/3600/24),0.67) * pow(state.d,-0.85);
	state.KL20 = IF (state.KL20_help < parameters.KLmin)
			         THEN parameters.KLmin
				       ELSE state.KL20_help;
	state.KLT = state.KL20 * pow(parameters.TKL,(state.T_wat-20));
	state.PO2M = (parameters.ProdM * interface.I0 - parameters.ResM) * parameters.MB / state.d * pow(parameters.TKp,(state.T_wat-20));
	state.SedO2 = (- parameters.SOD / state.d) * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.REAR = (state.KLT / state.d + interface.kLa) * (state.CS - state.C[rO2]);
	state.Nitrif = -4.57 * parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KNO2);
	state.BODox = (- parameters.Kd1 * (state.C[rBOD1] + state.C[rBOD1p]) - parameters.Kd2 * (state.C[rBOD2] + state.C[rBOD2p])  ) * pow(parameters.TKd,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KO2);
	state.SODT = - state.C[rBODs] * parameters.KBODs * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.BOD = state.C[rBOD1] + state.C[rBOD2] + state.C[rBOD1p] + state.C[rBOD2p];
	
	state.ConversionTermPerComponent[rO2] = (state.REAR + state.PO2M + state.SedO2 + state.BODox + state.Nitrif + state.SODT / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD1] = (- parameters.Kd1 * state.C[rBOD1] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD1 / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD2] = (- parameters.Kd2 * state.C[rBOD2] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD2 / state.d) * state.V;
  state.ConversionTermPerComponent[rBOD1p] = (- parameters.Vs1 / state.d - parameters.Kd1 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD1p] * state.V;
	state.ConversionTermPerComponent[rBOD2p] = (- parameters.Vs2 / state.d - parameters.Kd2 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD2p] * state.V;
	state.ConversionTermPerComponent[rNH4] = (- parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) 
										      * state.C[rO2] / (state.C[rO2] + parameters.KNO2) + parameters.SNH4 / state.d) * state.V;
	state.ConversionTermPerComponent[rBODs] = (parameters.Vs1 * state.C[rBOD1p] + parameters.Vs2 * state.C[rBOD2p] + state.SODT) / state.d * state.V;
	interface.DO = state.C[rO2];
  interface.NH4 = state.C[rNH4];
  interface.Q = state.Q_Out;
  state.DO_sat_perc = state.C[rO2] / state.CS;
  state.UIamm = state.C[rNH4] * 1 / (pow(10,(0.090182 + 2729.92 / (273.15 + state.T_wat) - parameters.pH)) +1);
  state.UIamm_corr = IF (state.C[rO2] >= 5)
										 THEN state.UIamm
										 ELSE state.UIamm * 2;
  state.DO_corr = IF (state.UIamm < 0.02)
									THEN state.C[rO2]
									ELSE IF (state.UIamm <= 0.15)
											 THEN state.C[rO2] - 0.97 * log(state.UIamm) - 3.8
											 ELSE state.C[rO2] - 2;
 
   };
   
 :};
# 169 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 2

 
# 1 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.Volume_MuskingumVariableParametersPrice2013.msl" 1
 
 
 
 
 
 
 
 
 
 
 
 
 

CLASS RivVarVolumeRIVER_McCarthy_Muskingum
 (* icon = "River" *)
 SPECIALISES RivVarVolumeConversionModel :=
 {:
  comments <- "Model for a bulk water unit with a variable volume. Muskingum approximation for the diffusive term of wave propagation";
  interface <-{};
  parameters <-{
   
	OBJ W_b "Width of channel at bottom of bank" : Length := {: value <- 10; group <- "River characteristics" :};
	OBJ L "Length of channel" : Length := {:value <- 2000; group <- "River characteristics" :};
	OBJ z "Banks slope" : Real := {:value <- 0.5; group <- "River characteristics" :};	
	OBJ slp "Average channel slope along channel length" : Ratio := {:value <- 0.0005; group <- "River characteristics" :};
	OBJ n "Manning's 'n' value for channel" : Real := {:value <- 0.035; group <- "River characteristics" :};
	

  OBJ d_min "Minimum depth of water" : Length := {:value <- 0.05; group <- "River characteristics" :};
	OBJ Vol_min "Minimum volume of water" : Volume := {: group <- "River characteristics" :};
	OBJ Vol_init "Initial volume of water as ratio on minimum" : Real := {:value <- 1.5; group <- "River characteristics" :};  
	
	
	OBJ Q_initial "Initial Flow in m3/s" : Real := {:value <- 5; group <- "River characteristics" :};
	 
  OBJ Niter "N iterations of the newton raphson routine, calculation of depth from flow for trapezoidal section" : Real := {:value <- 10; group <- "Newton Raphson Parameters" :};	
  
   

   
  OBJ alpha "Alpha factor for artificial aeration" : Real := {:value <- 0.85:};	
  OBJ pH "pH" : Real := {:value <- 7.5:};	
  OBJ KLmin "Minimum mass transfer constant reaeration": Velocity := {:value <- 0.1; unit <- "m/d":};
	OBJ TKL "Temperature coefficient mass transfer": Real := {:value <- 1.02:};
	OBJ Kd1 "Decay rate BOD1": RateConstant := {:value <- 0.4; unit <- "1/d":};
	OBJ Kd2 "Decay rate BOD2": RateConstant := {:value <- 0.3; unit <- "1/d":};
	OBJ KBODs "Decay rate temporary sediment BOD": RateConstant := {:value <- 0.7; unit <- "1/d":};
	OBJ Vs1 "Sedimentation rate particulate BOD1": Velocity := {:value <- 10; unit <- "m/d":};
	OBJ Vs2 "Sedimentation rate particulate BOD2": Velocity := {:value <- 50; unit <- "m/d":};
	OBJ KO2 "Monod constant O2 on BOD decay": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ TKd "Temperature coefficient DOD decay": Real := {:value <- 1.05:};
	OBJ TKp "Temperature coefficient plant growth/decay": Real := {:value <- 1.03:};
	OBJ Knit "Nitrification rate": RateConstant := {:value <- 0.2; unit <- "1/d":};
	OBJ TKnit "Temperature coefficient nitrification": Real := {:value <- 1.06:};
	OBJ KNO2 "Monod constant O2 on nitrification": Concentration := {:value <- 3.0; unit <- "mg/l":};
	OBJ KSO2 "Monod constant O2 on sediment oxygen demand": Concentration := {:value <- 2.0; unit <- "mg/l":};
	OBJ ProdM "Oxygen production Macrophyte Biomass (gO2/gM)/(W/m2)/day": Real := {:value <- 0.0002:};
	OBJ ResM "Oxygen respiration Macrophyte Biomass (gO2/gM)/day": RateConstant := {:value <- 0.04; unit <- "1/d":};
	OBJ TSOD "Temperature coefficient SOD": Real := {:value <- 1.08:};
	OBJ SBOD1 "Diffuse source BOD1, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SBOD2 "Diffuse source BOD2, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SNH4 "Diffuse source NH4, sediment (g/m2/day)" : Real := {:value <- 0.0; group <- "Inputs":};
	OBJ SOD "Sediment Oxygen Demand (g/m2/day)" : Real := {:value <- 5.0; group <- "Inputs":};	
	OBJ VKL "Velocity reaeration coefficient": Real := {:value <- 3.2:};

	OBJ MB "Macrophyte biomass" : SurfaceDensity := {:value <- 50; group <- "Inputs":};

	OBJ T_ref "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : CelsiusTemperature := {:value <- 15:};
	OBJ T_par "Air/water T conversion: T_wat=T_air+(T_ref-T_air)/T_par" : Real := {:value <- 3:};
	 
	};
  state <-{
   
  OBJ d_initial "Initial Water depth. Serves as a Volume initialization" : Length := {:value <- 1; group <- "River characteristics" :};
   
  OBJ x "Muskingum parameter X" : Real := {: group <- "Muskingum Parameters" :};	
  OBJ k "Muskingum k" : Time:= {: group <- "Muskingum Parameters" :};
  OBJ x_i (* hidden="1" *) "Muskingum parameter X internal" : Real := {: group <- "Muskingum Parameters" :};	
  OBJ k_i (* hidden="1" *) "Muskingum k internal" : Time:= {: group <- "Muskingum Parameters" :};
  

   
  OBJ A0 (* hidden="1" *) "Cross-sectional area bulk water tank initial" : Area:= {: group <- "River characteristics" :};
  OBJ B0 (* hidden="1" *) "Top width water tank initial" : Length:= {: group <- "River characteristics" :};
  OBJ P0 (* hidden="1" *) "Wet perimeter tank initial" : Area:= {: group <- "River characteristics" :};  

   
  OBJ Q0 (* hidden="1" *) "Flow normal water tank initial" : FlowRate:= {: group <- "River characteristics" :};
  OBJ v0 (* hidden="1" *) "Velocity water tank initial" : Velocity:= {: group <- "River characteristics" :};
  OBJ c0 (* hidden="1" *) "Celerity wave water tank initial" : Velocity:= {: group <- "River characteristics" :};
  OBJ F0 (* hidden="1" *) "Froud number water tank initial" : Real:= {: group <- "River characteristics" :};  
  OBJ dR_dd0 (* hidden="1" *) "Derivative of Hydraulic radius with depth" : Real:= {: group <- "River characteristics" :};  
  
   
  OBJ Dt "Timestep" : Time:= {: group <- "Muskingum routing" :};

  OBJ C0_i (* hidden="1" *) "Muskingum coefficient C0 first iteration" : Real:= {: group <- "Muskingum routing" :};
  OBJ C1_i (* hidden="1" *) "Muskingum coefficient C1 first iteration" : Real:= {: group <- "Muskingum routing" :};
  OBJ C2_i (* hidden="1" *) "Muskingum coefficient C2 first iteration" : Real:= {: group <- "Muskingum routing" :};
  
  OBJ C0 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
  OBJ C1 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};
  OBJ C2 "Muskingum coefficient C0" : Real:= {: group <- "Muskingum routing" :};  
  
   
  OBJ Q_Out_i (* hidden="1" *) "Outflow at the first iteration i+1" : FlowRate:= {: group <- "Muskingum routing" :};
  OBJ Q_3_i (* hidden="1" *) "Outflow at the first iteration at the section 3" : FlowRate:= {: group <- "Muskingum routing" :};
  
   
  OBJ d_m_i (* hidden="1" *) "Normal flow depth at the middle section first iteration" : Length:= {: group <- "Muskingum routing" :};  
   
  OBJ Am_i (* hidden="1" *) "Cross-sectional area bulk water tank 1st iteration" : Area:= {: group <- "River characteristics" :};
  OBJ Bm_i (* hidden="1" *) "Top width water tank 1st iteration" : Length:= {: group <- "River characteristics" :};
  OBJ Pm_i (* hidden="1" *) "Wet perimeter tank 1st iteration" : Area:= {: group <- "River characteristics" :};  

  OBJ vm_i (* hidden="1" *) "Velocity water tank 1st iteration" : Velocity:= {: group <- "River characteristics" :};  
  OBJ Qm_i (* hidden="1" *) "Flow normal at the middle section water tank 1st iteration" : FlowRate:= {: group <- "River characteristics" :};
  OBJ cm_i (* hidden="1" *) "Celerity wave water tank first iteration" : Velocity:= {: group <- "River characteristics" :};  
  OBJ Fm_i (* hidden="1" *) "Froud number water tank 1st iteration" : Real:= {: group <- "River characteristics" :};    
  OBJ dR_ddm_i (* hidden="1" *) "Derivative of Hydraulic radius with depth" : Real:= {: group <- "River characteristics" :};  

   
  OBJ Q_3 (* hidden="1" *) "Outflow at the section 3" : FlowRate:= {: group <- "Muskingum routing" :};
  
   
  OBJ d_m (* hidden="1" *) "Normal flow depth at the middle section" : Length:= {: group <- "Muskingum routing" :};  
  OBJ Qm (* hidden="1" *) "Flow normal at the middle section water tank" : FlowRate:= {: group <- "River characteristics" :};
	OBJ d "Depth of water in channel" : Length:= {: group <- "River characteristics" :}; 
  OBJ A_d (* hidden="1" *) "Cross-sectional area bulk water with final depth" : Area:= {: group <- "River characteristics" :};	
  
  OBJ Am (* hidden="1" *) "Cross-sectional area bulk water tank 1st iteration" : Area:= {: group <- "River characteristics" :};
  OBJ Bm (* hidden="1" *) "Top width water tank 1st iteration" : Area:= {: group <- "River characteristics" :};
  OBJ Pm (* hidden="1" *) "Wet perimeter tank 1st iteration" : Area:= {: group <- "River characteristics" :};  

  OBJ vm (* hidden="1" *) "Velocity water tank 1st iteration" : Velocity:= {: group <- "River characteristics" :};  
  OBJ cm (* hidden="1" *) "Celerity wave water tank first iteration" : Velocity:= {: group <- "River characteristics" :};  
  OBJ dR_ddm (* hidden="1" *) "Derivative of Hydraulic radius with depth" : Real:= {: group <- "River characteristics" :};  
  
   
  OBJ Q_help (* hidden="1" *)"Q_help" : FlowRate:= {: group <- "Muskingum routing" :};
	OBJ vel_water "Velocity of water" : Velocity := {: group <- "River characteristics" :};
	OBJ V_help (* hidden="1" *) "Help volume" : Volume:= {: group <- "Muskingum routing" :};
	OBJ V_components (* hidden="1" *) "Help volume" : Volume:= {: group <- "Muskingum routing" :};
	OBJ d_help (* hidden="1" *)"d_help" : Length:= {: group <- "Muskingum routing" :};

  OBJ V_Muskingum (* hidden="0" *) "Reach storage as per muskingum" : Mass:= {: group <- "Muskingum routing" :};
	
   
  
  
  
   
  OBJ CS "saturation conc Oxygen" : Real ;
  OBJ DO_sat_perc "saturation percentage Oxygen" : Fraction ;
  OBJ UIamm "unionised ammonia" : Concentration ;
  OBJ UIamm_corr "unionised ammonia, corrected for DO" : Concentration ;
  OBJ DO_corr "DO, corrected fro UIamm" : Concentration ;
	OBJ KL20 "mass transfer at 20oC calculated form velocity and depth" : Real ;
	OBJ KLT "" : Real ;

	OBJ PO2M "net oxygen production/consumption Macrophytesn" : Real ;
	OBJ SedO2 "" : Real ;
	OBJ REAR "" : Real ;
	OBJ Nitrif "" : Real ;
	OBJ BODox "" : Real ;
	OBJ SODT "" : Real ;
	OBJ BOD "" : Real ;
	OBJ T_wat "Water temperature" : CelsiusTemperature ;
	
	OBJ KL20_help (* hidden = "1" *) "" : Real ;
	OBJ T_wat_help (* hidden = "1" *) "Water temperature" : CelsiusTemperature ;

	OBJ OTR "Actual oxygen transfer rate" : MassFlux;
  OBJ SOTR "Standard oxygen transfer rate" : MassFlux;
   
   	};
	  
   initial <-{   
   parameters.Vol_min = parameters.d_min * (parameters.W_b + parameters.d_min * parameters.z) * parameters.L;
    
   state.d = NewtonRaphson(1.0, parameters.Q_initial, parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter); 
   state.M[rH2O] = parameters.L * state.d*(parameters.W_b + state.d*parameters.z) * 1000000;
   state.V = state.M[1] * 0.000001 ;
   state.V_Muskingum = state.M[1];
   
   state.Q_Out = 3600*24*(sqrt(parameters.slp)/parameters.n)* (pow( parameters.W_b * state.d + parameters.z * pow(state.d, 2)  ,(5.0/3.0))   ) / pow(parameters.W_b + 2* state.d * sqrt(1 + pow(parameters.z,2) ), (2.0/3.0)); 
   state.Q_In = state.Q_Out;
   
   state.k = 0.03;
   state.x = 0.2;
    };
 
  equations <-{
 
 
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.FluxPerComponent[Comp_Index] =

    (SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
    In_RivTerminal[Comp_Index])+
    (SUMOVER Out_RivTerminal IN {SelectByType(interface,OutRivTerminal)}:
    Out_RivTerminal[Comp_Index]);};

     
     
     
     

    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      DERIV(state.M[Comp_Index],[independent.t]) = 
      state.FluxPerComponent[Comp_Index]
      +state.ConversionTermPerComponent[Comp_Index];};
     

     
     
    
    {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:
      state.InFluxPerComponent[Comp_Index] =
         SUMOVER In_RivTerminal IN {SelectByType(interface,InRivTerminal)}:
            (In_RivTerminal[Comp_Index]);
    };

    {state.Q_In = (0.000001* state.InFluxPerComponent[rH2O]);
    };
   
  
  state.Dt = (independent.t - previous(independent.t));  

 
  state.A0 = parameters.W_b * previous(state.d) + parameters.z * pow(previous(state.d),2);
  state.B0 = parameters.W_b + 2*parameters.z * previous(state.d);
  state.P0 = parameters.W_b + 2*previous(state.d)*sqrt(1+pow(parameters.z,2));
  
  state.Q0 =  pow((state.A0/state.P0),(2.0/3.0)) * state.A0 * sqrt(parameters.slp) / (parameters.n) * (3600 * 24);   
  state.v0 = state.Q0/state.A0;
  
  state.dR_dd0 = (2*previous(state.d)*parameters.z + parameters.W_b)/(2*previous(state.d)* sqrt(1 + pow(parameters.z,2) ) + parameters.W_b ) - (2*sqrt(1 + pow(parameters.z,2) ) * (pow(previous(state.d),2) * parameters.z + previous(state.d) * parameters.W_b))/( pow(   (2 * previous(state.d) * sqrt(1 + pow(parameters.z,2) ) + parameters.W_b),2)) ;
  
  state.c0 = (1 + (2.0/3.0) * state.P0/state.B0 * state.dR_dd0) * state.v0;  
  state.F0 = sqrt( pow(state.v0/(3600*24),2) * state.B0 / (9.81 * state.A0) );  
  
   
  state.k_i = parameters.L / state.v0;
  state.x_i = 0.5 - state.Q0 * ( 1 -( (4.0/9.0)*pow(state.F0,2)* pow((state.P0*state.dR_dd0/state.B0),2) ) ) / (2*parameters.slp*state.B0*state.c0 * parameters.L);

 
  state.C0_i = (state.Dt - 2*state.k_i*state.x_i)/(state.Dt + 2*state.k_i*(1-state.x_i));
  state.C1_i = (state.Dt + 2*previous(state.k)*previous(state.x) )/(state.Dt + 2*state.k_i*(1-state.x_i));
  state.C2_i = (-state.Dt + 2*previous(state.k)*(1-previous(state.x)))/(state.Dt + 2*state.k_i*(1-state.x_i));
  
 
   
  state.Q_Out_i =  IF (independent.t <= state.Dt) 
	THEN state.Q_In 
	ELSE state.C0_i*state.Q_In + state.C1_i*previous(state.Q_In) + state.C2_i*previous(state.Q_Out);
  
 
  state.Q_3_i = state.x_i * state.Q_In + (1 - state.x_i) * state.Q_Out_i;  
 
  state.d_m_i = NewtonRaphson(previous(state.d), state.Q_3_i/(3600*24), parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter);
   
  state.Am_i = parameters.W_b * state.d_m_i + parameters.z * pow(state.d_m_i,2);
  state.Bm_i = parameters.W_b + 2*parameters.z * state.d_m_i;
  state.Pm_i = parameters.W_b + 2*state.d_m_i*sqrt(1+pow(parameters.z,2));
  state.vm_i = state.Q_3_i/state.Am_i;  
  state.dR_ddm_i = (2*state.d_m_i*parameters.z + parameters.W_b)/(2*state.d_m_i* sqrt(1 + pow(parameters.z,2) ) + parameters.W_b ) - (2*sqrt(1 + pow(parameters.z,2) ) * (pow(state.d_m_i,2) * parameters.z + state.d_m_i * parameters.W_b))/( pow(   (2 * state.d_m_i * sqrt(1 + pow(parameters.z,2) ) + parameters.W_b),2)) ;
 
  state.Qm_i = 0.5*(state.Q_In+state.Q_Out_i);
 
  state.Fm_i = sqrt( pow(state.Qm_i/(3600*24),2) * state.Bm_i / (9.81 * pow(state.Am_i,3)) );  
 
  state.cm_i = (1 + 2/3 * state.Pm_i/state.Bm_i * state.dR_ddm_i) * state.vm_i;

 
  state.k = parameters.L / state.vm_i;
  state.x = 0.5 - state.Qm_i*(1-  4.0/9.0 * pow(state.Fm_i,2) * ( pow(state.Pm_i/state.Bm_i * state.dR_ddm_i , 2) ) ) / ( 2 * parameters.slp * state.Bm_i * state.cm_i * parameters.L);
  
 
  state.C0 = (state.Dt - 2*state.k*state.x)/(state.Dt + 2*state.k*(1-state.x));
  state.C1 = (state.Dt + 2*previous(state.k)*previous(state.x) )/(state.Dt + 2*state.k*(1-state.x));
  state.C2 = (-state.Dt + 2*previous(state.k)*(1-previous(state.x)))/(state.Dt + 2*state.k*(1-state.x));

 
  state.Q_help =  IF (independent.t<= state.Dt)  
	THEN state.Q_In 
	ELSE state.C0*state.Q_In + state.C1*previous(state.Q_In) + state.C2*previous(state.Q_Out);
 
  state.Q_3 = state.x * state.Q_In + (1 - state.x) * state.Q_help; 
   
  state.d_m = NewtonRaphson(previous(state.d), state.Q_3/(3600*24), parameters.W_b, parameters.slp, parameters.z, parameters.n, parameters.Niter);    
   
  state.Am = parameters.W_b * state.d_m + parameters.z * pow(state.d_m,2);
  state.Bm = parameters.W_b + 2*parameters.z * state.d_m;
  state.Pm = parameters.W_b + 2*state.d_m*sqrt(1+pow(parameters.z,2));
  state.vm = state.Q_3/state.Am;  
  state.dR_ddm = (2*state.d_m*parameters.z + parameters.W_b)/(2*state.d_m* sqrt(1 + pow(parameters.z,2) ) + parameters.W_b ) - (2*sqrt(1 + pow(parameters.z,2) ) * (pow(state.d_m,2) * parameters.z + state.d_m * parameters.W_b))/( pow(   (2 * state.d_m * sqrt(1 + pow(parameters.z,2) ) + parameters.W_b),2)) ;  
  state.cm = (1 + 2.0/3.0 * state.Pm/state.Bm * state.dR_ddm) * state.vm;  
 
  state.Qm = 0.5*(state.Q_In + state.Q_help);    
 
  state.d_help = state.d_m + (state.Q_help - state.Qm)/(state.Bm*state.cm); 
  state.Q_Out = IF (state.Q_help <= 0) 
  THEN 0
  ELSE state.Q_help;
  
  state.d = IF (state.d_help <= 0) 
  THEN parameters.d_min 
  ELSE state.d_help;
  
  state.A_d = parameters.W_b * state.d + parameters.z * pow(state.d,2);  
  state.vel_water = state.Q_Out / state.A_d;
  
  state.V_Muskingum = (state.k * state.x * state.Q_In + state.Q_Out*(1-state.x)*state.k) * 1000000 ;  
   
	state.V_help = (SUMOVER Comp_Index IN {2 .. RivNrOfComponents}:
	(0.000001*state.M[Comp_Index])) + 0.000001*state.V_Muskingum;		
   
	
	state.V =  IF (state.V_help <= parameters.Vol_min) 
	THEN parameters.Vol_min 
	ELSE state.V_help;   
 
  
   
   {FOREACH Comp_Index IN {1 .. RivNrOfComponents}:state.C[Comp_Index] = IF (state.V == 0)
			   THEN 0
			   ELSE state.M[Comp_Index]/state.V;
	 };

   {FOREACH Comp_Index IN {1 .. rBOD2p}:
     interface.Outflow[Comp_Index] = - state.C[Comp_Index] * state.Q_Out ;
   };
   
	interface.Outflow[rBODs] = 0;




 
  state.OTR = interface.kLa * (state.CS - state.C[rO2]) * state.V;
  state.SOTR = state.OTR * state.CS / (state.CS - state.C[rO2]) / parameters.alpha;
	
	state.T_wat_help = interface.T + (parameters.T_ref - interface.T) / parameters.T_par;
	state.T_wat = IF (state.T_wat_help > 0)
				        THEN state.T_wat_help
				        ELSE 0;

	state.CS = 14.652 - 0.41022 * state.T_wat + 0.007991 * pow(state.T_wat,2.0) - 0.000077774 * pow(state.T_wat,3.0);
	state.KL20_help = parameters.VKL * pow((state.vel_water/3600/24),0.67) * pow(state.d,-0.85);
	state.KL20 = IF (state.KL20_help < parameters.KLmin)
			         THEN parameters.KLmin
				       ELSE state.KL20_help;
	state.KLT = state.KL20 * pow(parameters.TKL,(state.T_wat-20));
	state.PO2M = (parameters.ProdM * interface.I0 - parameters.ResM) * parameters.MB / state.d * pow(parameters.TKp,(state.T_wat-20));
	state.SedO2 = (- parameters.SOD / state.d) * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.REAR = (state.KLT / state.d + interface.kLa) * (state.CS - state.C[rO2]);
	state.Nitrif = -4.57 * parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KNO2);
	state.BODox = (- parameters.Kd1 * (state.C[rBOD1] + state.C[rBOD1p]) - parameters.Kd2 * (state.C[rBOD2] + state.C[rBOD2p])  ) * pow(parameters.TKd,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KO2);
	state.SODT = - state.C[rBODs] * parameters.KBODs * pow(parameters.TSOD,(state.T_wat-20)) * state.C[rO2] / (state.C[rO2] + parameters.KSO2);
	state.BOD = state.C[rBOD1] + state.C[rBOD2] + state.C[rBOD1p] + state.C[rBOD2p];
	
	state.ConversionTermPerComponent[rO2] = (state.REAR + state.PO2M + state.SedO2 + state.BODox + state.Nitrif + state.SODT / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD1] = (- parameters.Kd1 * state.C[rBOD1] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD1 / state.d) * state.V;
	state.ConversionTermPerComponent[rBOD2] = (- parameters.Kd2 * state.C[rBOD2] * pow(parameters.TKd,(state.T_wat-20)) 
											   * state.C[rO2] / (state.C[rO2] + parameters.KO2) + parameters.SBOD2 / state.d) * state.V;
  state.ConversionTermPerComponent[rBOD1p] = (- parameters.Vs1 / state.d - parameters.Kd1 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD1p] * state.V;
	state.ConversionTermPerComponent[rBOD2p] = (- parameters.Vs2 / state.d - parameters.Kd2 * pow(parameters.TKd,(state.T_wat-20)) 
											    * state.C[rO2] / (state.C[rO2] + parameters.KO2)) * state.C[rBOD2p] * state.V;
	state.ConversionTermPerComponent[rNH4] = (- parameters.Knit * state.C[rNH4] * pow(parameters.TKnit,(state.T_wat-20)) 
										      * state.C[rO2] / (state.C[rO2] + parameters.KNO2) + parameters.SNH4 / state.d) * state.V;
	state.ConversionTermPerComponent[rBODs] = (parameters.Vs1 * state.C[rBOD1p] + parameters.Vs2 * state.C[rBOD2p] + state.SODT) / state.d * state.V;
	interface.DO = state.C[rO2];
  interface.NH4 = state.C[rNH4];
  interface.Q = state.Q_Out;
  state.DO_sat_perc = state.C[rO2] / state.CS;
  state.UIamm = state.C[rNH4] * 1 / (pow(10,(0.090182 + 2729.92 / (273.15 + state.T_wat) - parameters.pH)) +1);
  state.UIamm_corr = IF (state.C[rO2] >= 5)
										 THEN state.UIamm
										 ELSE state.UIamm * 2;
  state.DO_corr = IF (state.UIamm < 0.02)
									THEN state.C[rO2]
									ELSE IF (state.UIamm <= 0.15)
											 THEN state.C[rO2] - 0.97 * log(state.UIamm) - 3.8
											 ELSE state.C[rO2] - 2;
 
   };
   
 :};
# 170 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.base_Duflow_simple.msl" 2

 
 
# 14 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\river.msl" 2


  CLASS simple_Duflow_generator
 (* icon = "River_input" *)
 "A generator model for simple Duflow"
 SPECIALISES PhysicalDAEModelType :=
 {:
  interface <-
  {
    OBJ rainfall (* terminal = "in_1" *) "Rainfall" : Velocity := {: causality <- "CIN" :};
		OBJ NH4_in (* terminal = "in_1"; manip = "1"; *) "NH4" : Concentration := {: causality <- "CIN"; value <- 0.05:};
		OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutRivTerminal := {: causality <- "COUT" :};
  };

  parameters <-
  {
  OBJ surface: Area;
	OBJ BOD1_in: Concentration := {:value <- 3:};
	OBJ BOD2_in: Concentration := {:value <- 1:};
	OBJ O2_in: Concentration := {:value <- 9:};
	OBJ BOD1p_in: Concentration := {:value <- 0.01:};
	OBJ BOD2p_in: Concentration := {:value <- 0.01:};
	OBJ BODs_in: Concentration := {:value <- 0.01:};
  };
		
	state <-
  {
    OBJ Q "Flow": FlowRate ;
  };

  independent <-
  {
    OBJ t "Time": Time ;
  };

  equations <-
  {
	 state.Q = - interface.Outflow[rH2O] / 1000000;
   interface.Outflow[rH2O] = - interface.rainfall * parameters.surface * 1000000;
   interface.Outflow[rO2] = - parameters.O2_in * state.Q;
   interface.Outflow[rBOD1] = - parameters.BOD1_in * state.Q;
   interface.Outflow[rBOD2] = - parameters.BOD2_in * state.Q;
   interface.Outflow[rBOD1p] = - parameters.BOD1p_in * state.Q;
   interface.Outflow[rBOD2p] = - parameters.BOD2p_in * state.Q;
   interface.Outflow[rBODs] = - parameters.BODs_in * state.Q;
   interface.Outflow[rNH4] = - interface.NH4_in * state.Q;
  };
  
 :};
 

  CLASS simple_Duflow_generator_CSOload
 (* icon = "River_input" *)
 "A generator model for simple Duflow to emulate CSO discharges with input pollution loads"
 SPECIALISES PhysicalDAEModelType :=
 {:
  interface <-
  {
    OBJ rainfall (* terminal = "in_1" *) "Rainfall" : Velocity := {: causality <- "CIN" :};
		OBJ U_BOD_in (* terminal = "in_1"; manip = "1"; *) "BOD" : Concentration := {: causality <- "CIN"; value <- 42:};
		OBJ U_COD_in (* terminal = "in_1"; manip = "1"; *) "COD" : Concentration := {: causality <- "CIN"; value <- 150:};
		OBJ U_NH4_in (* terminal = "in_1"; manip = "1"; *) "NH4" : Concentration := {: causality <- "CIN"; value <- 0.05:};
		OBJ U_O2_in (* terminal = "in_1"; manip = "1"; *) "O2" : Concentration := {: causality <- "CIN"; value <- 7:};	
		
		OBJ Outflow (* terminal = "out_1" *) "Outflow" : OutRivTerminal := {: causality <- "COUT" :};
  };

  parameters <-
  {
  OBJ FactorEffluent: Area:= {: value <- 1 :};

   
  OBJ fBOD1_BOD "Fraction of BODfast in BOD" : Fraction := {: value <- 0.85 ; group <- "Fractionation" :};
  OBJ fBOD2_CODmBOD "Fraction of BODslow in COD minus BOD" : Fraction := {: value <- 0.4 ; group <- "Fractionation" :};
  OBJ fBOD1p_BODf "Fraction of BOD1p in BODfast" : Fraction := {: value <- 0.3 ; group <- "Fractionation" :};
  OBJ fBOD2p_BODs "Fraction of BOD2p in BODslow" : Fraction := {: value <- 0.5 ; group <- "Fractionation" :};
  OBJ settling "Settling efficiency for BOD2" : Fraction := {: value <- 0 ; group <- "Fractionation" :};
  OBJ yesno "0 for no CSO effluent, 1 for 100 percent CSO effluent" : Real := {: value <- 1 :};
  
  OBJ Mult_O2 "Multiplier for O2 input concentration" : Real := {: value <- 1 :};
  OBJ Mult_COD "Multiplier for COD input concentration" : Real := {: value <- 1 :};
  OBJ Mult_BOD "Multiplier for BOD input concentration" : Real := {: value <- 1 :};
  OBJ Mult_NH4 "Multiplier for NH4 input concentration" : Real := {: value <- 1 :};  
  };
		
	state <-
  {
    OBJ Q "Flow": FlowRate ;
  };

  independent <-
  {
    OBJ t "Time": Time ;
  };

  equations <-
  {
	 state.Q = - interface.Outflow[rH2O] / 1000000;
   interface.Outflow[rH2O] = - interface.rainfall * parameters.FactorEffluent * 1000000;
   interface.Outflow[rO2]   = - parameters.Mult_O2 * parameters.yesno * interface.U_O2_in * state.Q ;
   interface.Outflow[rNH4] =  - parameters.Mult_NH4 * parameters.yesno * interface.U_NH4_in * state.Q;
   interface.Outflow[rBOD1]   = - parameters.yesno * parameters.fBOD1_BOD * (1-parameters.fBOD1p_BODf) * parameters.Mult_BOD * interface.U_BOD_in * state.Q ;
   interface.Outflow[rBOD1p]   = - parameters.yesno * parameters.fBOD1_BOD * parameters.fBOD1p_BODf * parameters.Mult_BOD * interface.U_BOD_in * state.Q * (1 - parameters.settling);
   interface.Outflow[rBOD2]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * (1-parameters.fBOD2p_BODs) * parameters.Mult_BOD * interface.U_BOD_in + parameters.fBOD2_CODmBOD * (parameters.Mult_COD * interface.U_COD_in - parameters.Mult_BOD * interface.U_BOD_in)) * state.Q ;  
   interface.Outflow[rBOD2p]   = - parameters.yesno * ((1-parameters.fBOD1_BOD) * parameters.fBOD2p_BODs * parameters.Mult_BOD * interface.U_BOD_in + parameters.fBOD2_CODmBOD * (parameters.Mult_COD * interface.U_COD_in - parameters.Mult_BOD * interface.U_BOD_in)) * state.Q* (1 - parameters.settling);  
  };
  
 :};




 
# 22 "C:\\Users\\localadmin.TUD278183\\Desktop\\pyWEST\\WESTforIUWS_modelLibrary_little\\Models\\iuws.msl" 2


 



 

# 4 "Model_dummy_1.Project.msl" 2

# 1 "_Model_dummy_1_.msl" 1
# 1 "Model_dummy_1.msl" 1





CLASS Model_dummy_1 (* icon = ""; file = ""; *)  SPECIALISES CoupledModelType := 
{:
  comments <- "";

  interface <-
  {
    OBJ Rural_baseflow (*terminal = ""; *) "" : Real := {: causality <- "CIN"; :};
    OBJ Urban_CSO_flow (*terminal = ""; *) "" : Real := {: causality <- "CIN"; :};
    OBJ Temperature_water (*terminal = ""; *) "" : CelsiusTemperature := {: causality <- "CIN"; :};
    OBJ Solar_Radiation (*terminal = ""; *) "" : DensityOfHeatFlowRate := {: causality <- "CIN"; :};
  };

  parameters <-
  {
  };

  sub_models <-
  {
    OBJ River_2 "" : RivVarVolumeRIVER;
    OBJ River_3 "" : RivVarVolumeRIVER;
    OBJ River_4 "" : RivVarVolumeRIVER;
    OBJ River_5 "" : RivVarVolumeRIVER;
    OBJ Urban_InputEmulator "" : simple_Duflow_generator_CSOload;
    OBJ River_1 "" : RivVarVolumeRIVER;
    OBJ Rural_inflow "" : simple_Duflow_generator;
  };

  coupling <-
  {

    connect(interface.Temperature_water, sub_models.River_4.interface.T),
    connect(sub_models.River_1.interface.Outflow, sub_models.River_2.interface.Inflow1),
    connect(interface.Temperature_water, sub_models.River_5.interface.T),
    connect(interface.Solar_Radiation, sub_models.River_2.interface.I0),
    connect(interface.Temperature_water, sub_models.River_3.interface.T),
    connect(interface.Temperature_water, sub_models.River_2.interface.T),
    connect(interface.Solar_Radiation, sub_models.River_3.interface.I0),
    connect(sub_models.River_4.interface.Outflow, sub_models.River_5.interface.Inflow1),
    connect(sub_models.Urban_InputEmulator.interface.Outflow, sub_models.River_2.interface.Inflow2),
    connect(interface.Solar_Radiation, sub_models.River_4.interface.I0),
    connect(interface.Temperature_water, sub_models.River_1.interface.T),
    connect(interface.Rural_baseflow, sub_models.Rural_inflow.interface.rainfall),
    connect(interface.Urban_CSO_flow, sub_models.Urban_InputEmulator.interface.rainfall),
    connect(sub_models.River_3.interface.Outflow, sub_models.River_4.interface.Inflow1),
    connect(interface.Solar_Radiation, sub_models.River_1.interface.I0),
    connect(sub_models.Rural_inflow.interface.Outflow, sub_models.River_1.interface.Inflow1),
    connect(interface.Solar_Radiation, sub_models.River_5.interface.I0),
    connect(sub_models.River_2.interface.Outflow, sub_models.River_3.interface.Inflow1),

  };
:};



# 1 "_Model_dummy_1_.msl" 2


OBJ _Model_dummy_1_ : Model_dummy_1;

# 5 "Model_dummy_1.Project.msl" 2



